<!DOCTYPE html>
<html>

<head>
  <title>Mozilla Developer Network JavaScript Programming Notes</title>
  <script src="/initialize.js"></script>
</head>

<body class="w3-light-gray">

  <main class="w3-container">

    <!-- Ariticle tags -->
    <div class="w3-card w3-white w3-padding" id="tags">
      <span>Tags:</span> 

      <a class="w3-tag w3-black w3-btn w3-padding-small my-margin-small" href="blog.html">MDN</a>
      <a class="w3-tag w3-black w3-btn w3-padding-small my-margin-small" href="blog.html">JavaScript</a>
      <a class="w3-tag w3-black w3-btn w3-padding-small my-margin-small" href="blog.html">Programming</a>
      <a class="w3-tag w3-black w3-btn w3-padding-small my-margin-small" href="blog.html">Notes</a>        
    </div>

    <div class="w3-card w3-white w3-padding w3-margin-top" id="entry">

      <!-- Event -->
      <section>
        <h3><b>Events</b></h3>

        <section>
          <h4><b><code class="w3-light-gray">addEventListener()</code> and <code class="w3-light-gray">removeEventListener()</code></b></h4>
          <p>The main advantages of the DOM Level 2 Events <code class="w3-light-gray">addEventListener()</code> and <code class="w3-light-gray">removeEventListener()</code> are that you can remove event handler code if needed, using <code class="w3-light-gray">removeEventListener()</code>, and you can add multiple listeners of the same type to elements if required. For example, you can call <code class="w3-light-gray">addEventListener('click', function() { ... })</code> on an element multiple times, with different functions specified in the second argument. This is impossible with event handler properties, because any subsequent attempts to set a property will overwrite earlier ones, e.g.:</p>
          
          <pre><code class="js w3-code w3-panel w3-card w3-leftbar w3-light-gray">
            element.onclick = function1;
            element.onclick = function2; // element.onclick is function2 now
          </code></pre>

        </section>

        <section>
          <h4><b>Event Object</b></h4>
          <p><code>e.target</code> is incredibly useful when you want to set the <b>same</b> event handler on multiple elements, and do something to all of them when an event occurs on them after you assign the handler.</p>

          <pre><code class="js w3-code w3-panel w3-card w3-leftbar w3-light-gray">
            /* Looping through images */ 
            for (var i = 1; i &lt;= 5; i++) { 
              var newImage = document.createElement('img'); 
              newImage.setAttribute('src', 'images/pic' + i + '.jpg'); 
              thumbBar.appendChild(newImage); 
              // When click event occur, newImage.src = images/pic5.jpg'
              newImage.onclick = function(e) { // Use e.target to match the element 
                displayedImage.setAttribute('src', e.target.getAttribute('src')); 
              } 
            }
          </code></pre>

        </section>

      </section> <!-- Event -->

      <hr />

      <!-- Object -->
      <section>
        <h3><b>Object</b></h3>
        <p>a fairly common pattern for more object definitions is to define the properties inside the constructor, and the methods on the prototype. This makes the code easier to read, as the constructor only contains the property definitions, and the methods are split off into separate blocks. For example:</p>

        <pre><code class="js w3-code w3-panel w3-card w3-leftbar w3-light-gray">
          // Constructor with property definitions  
          function Test(a, b, c, d) {
          // property definitions
          }
          
          // First method definition
          Test.prototype.x = function() { ... };
          
          // Second method definition
          Test.prototype.y = function() { ... };
          
          // etc.
        </code></pre>

      </section> <!-- Object -->

      <hr />

      <!-- Declaration -->
      <section>
        <h3><b>Declaration</b></h3>
        <p>a fairly common pattern for more object definitions is to define the properties inside the constructor, and the methods on the prototype. This makes the code easier to read, as the constructor only contains the property definitions, and the methods are split off into separate blocks. For example:</p>

        <pre><code class="js w3-code w3-panel w3-card w3-leftbar w3-light-gray">
          // Constructor with property definitions  
          function Test(a, b, c, d) {
          // property definitions
          }
          
          // First method definition
          Test.prototype.x = function() { ... };
          
          // Second method definition
          Test.prototype.y = function() { ... };
          
          // etc.
        </code></pre>

      </section> <!-- Decalare -->

    </div>

  </main>

</body>

</html>