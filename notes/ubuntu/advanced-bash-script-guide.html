<div class="BOOK"><a name="AEN1"></a><div class="TITLEPAGE"><h1 class="TITLE"><a name="AEN2"></a>Advanced Bash-Scripting Guide</h1><h2 class="SUBTITLE">An in-depth exploration of the art of shell scripting</h2><h3 class="AUTHOR"><a name="AEN5"></a>Mendel Cooper</h3><div class="AFFILIATION"><span class="ORGNAME"><br></span><div class="ADDRESS"><p class="ADDRESS"><tt class="EMAIL">&lt;<a href="mailto:thegrendel.abs@gmail.com">thegrendel.abs@gmail.com</a>&gt;</tt></p></div></div><span class="RELEASEINFO">10<br></span><p class="PUBDATE">10 Mar 2014<br></p><div class="REVHISTORY"><table width="100%" border="0"><tbody><tr><th align="LEFT" valign="TOP" colspan="3"><b>Revision History</b></th></tr><tr><td align="LEFT">Revision 6.5</td><td align="LEFT">05 Apr 2012</td><td align="LEFT">Revised by: mc</td></tr><tr><td align="LEFT" colspan="3">'TUNGSTENBERRY' release</td></tr><tr><td align="LEFT">Revision 6.6</td><td align="LEFT">27 Nov 2012</td><td align="LEFT">Revised by: mc</td></tr><tr><td align="LEFT" colspan="3">'YTTERBIUMBERRY' release</td></tr><tr><td align="LEFT">Revision 10</td><td align="LEFT">10 Mar 2014</td><td align="LEFT">Revised by: mc</td></tr><tr><td align="LEFT" colspan="3">'PUBLICDOMAIN' release</td></tr></tbody></table></div><div><div class="ABSTRACT"><a name="AEN31"></a><p></p><p>This tutorial assumes no previous knowledge of
    scripting or programming, yet progresses rapidly toward an
    intermediate/advanced level of instruction <em>. . . all
    the while sneaking in little nuggets of <span class="TRADEMARK">UNIX</span>Â® wisdom and lore</em>. It
    serves as a textbook, a manual for self-study, and as a reference and
    source of knowledge on shell scripting techniques. The exercises
    and heavily-commented examples invite active reader participation,
    under the premise that <tt class="USERINPUT"><b>the only way to really learn
    scripting is to write scripts</b></tt>.</p><p>This book is suitable for classroom use as a
          general introduction to programming concepts.</p><p>This document is herewith granted to the Public Domain.
        <tt class="USERINPUT"><b>No copyright!</b></tt></p><p></p></div></div><hr></div><hr><h1><a name="AEN39"></a>Dedication</h1><p>For Anita, the source of all the magic</p><div class="TOC"><dl><dt><b>Table of Contents</b></dt><dt>Part 1. <a href="#PART1">Introduction</a></dt><dd><dl><dt>1. <a href="#WHY-SHELL">Shell Programming!</a></dt><dt>2. <a href="#SHA-BANG">Starting Off With a Sha-Bang</a></dt></dl></dd><dt>Part 2. <a href="#PART2">Basics</a></dt><dd><dl><dt>3. <a href="#SPECIAL-CHARS">Special Characters</a></dt><dt>4. <a href="#VARIABLES">Introduction to Variables and Parameters</a></dt><dt>5. <a href="#QUOTING">Quoting</a></dt><dt>6. <a href="#EXIT-STATUS">Exit and Exit Status</a></dt><dt>7. <a href="#TESTS">Tests</a></dt><dt>8. <a href="#OPERATIONS">Operations and Related Topics</a></dt></dl></dd><dt>Part 3. <a href="#PART3">Beyond the Basics</a></dt><dd><dl><dt>9. <a href="#VARIABLES2">Another Look at Variables</a></dt><dt>10. <a href="#MANIPULATINGVARS">Manipulating Variables</a></dt><dt>11. <a href="#LOOPS">Loops and Branches</a></dt><dt>12. <a href="#COMMANDSUB">Command Substitution</a></dt><dt>13. <a href="#ARITHEXP">Arithmetic Expansion</a></dt><dt>14. <a href="#RECESS-TIME">Recess Time</a></dt></dl></dd><dt>Part 4. <a href="#PART4">Commands</a></dt><dd><dl><dt>15. <a href="#INTERNAL">Internal Commands and Builtins</a></dt><dt>16. <a href="#EXTERNAL">External Filters, Programs and Commands</a></dt><dt>17. <a href="#SYSTEM">System and Administrative Commands</a></dt></dl></dd><dt>Part 5. <a href="#PART5">Advanced Topics</a></dt><dd><dl><dt>18. <a href="#REGEXP">Regular Expressions</a></dt><dt>19. <a href="#HERE-DOCS">Here Documents</a></dt><dt>20. <a href="#IO-REDIRECTION">I/O Redirection</a></dt><dt>21. <a href="#SUBSHELLS">Subshells</a></dt><dt>22. <a href="#RESTRICTED-SH">Restricted Shells</a></dt><dt>23. <a href="#PROCESS-SUB">Process Substitution</a></dt><dt>24. <a href="#FUNCTIONS">Functions</a></dt><dt>25. <a href="#ALIASES">Aliases</a></dt><dt>26. <a href="#LIST-CONS">List Constructs</a></dt><dt>27. <a href="#ARRAYS">Arrays</a></dt><dt>28. <a href="#IVR">Indirect References</a></dt><dt>29. <a href="#DEVPROC"><tt class="FILENAME">/dev</tt> and <tt class="FILENAME">/proc</tt></a></dt><dt>30. <a href="#NETWORKPROGRAMMING">Network Programming</a></dt><dt>31. <a href="#ZEROS">Of Zeros and Nulls</a></dt><dt>32. <a href="#DEBUGGING">Debugging</a></dt><dt>33. <a href="#OPTIONS">Options</a></dt><dt>34. <a href="#GOTCHAS">Gotchas</a></dt><dt>35. <a href="#SCRSTYLE">Scripting With Style</a></dt><dt>36. <a href="#MISCELLANY">Miscellany</a></dt><dt>37. <a href="#BASH2">Bash, versions 2, 3, and 4</a></dt></dl></dd><dt>38. <a href="#ENDNOTES">Endnotes</a></dt><dd><dl><dt>38.1. <a href="#AUTHORSNOTE">Author's Note</a></dt><dt>38.2. <a href="#ABOUTAUTHOR">About the Author</a></dt><dt>38.3. <a href="#WHEREHELP">Where to Go For Help</a></dt><dt>38.4. <a href="#TOOLSUSED">Tools Used to Produce This Book</a></dt><dt>38.5. <a href="#CREDITS">Credits</a></dt><dt>38.6. <a href="#DISCLAIMER">Disclaimer</a></dt></dl></dd><dt><a href="#BIBLIO">Bibliography</a></dt><dt>A. <a href="#CONTRIBUTED-SCRIPTS">Contributed Scripts</a></dt><dt>B. <a href="#REFCARDS">Reference Cards</a></dt><dt>C. <a href="#SEDAWK">A Sed and Awk Micro-Primer</a></dt><dd><dl><dt>C.1. <a href="#AEN23170">Sed</a></dt><dt>C.2. <a href="#AWK">Awk</a></dt></dl></dd><dt>D. <a href="#PATHMANAGEMENT">Parsing and Managing Pathnames</a></dt><dt>E. <a href="#EXITCODES">Exit Codes With Special Meanings</a></dt><dt>F. <a href="#IOREDIRINTRO">A Detailed Introduction to I/O and I/O Redirection</a></dt><dt>G. <a href="#COMMAND-LINE-OPTIONS">Command-Line Options</a></dt><dd><dl><dt>G.1. <a href="#STANDARD-OPTIONS">Standard Command-Line Options</a></dt><dt>G.2. <a href="#BASH-OPTIONS">Bash Command-Line Options</a></dt></dl></dd><dt>H. <a href="#FILES">Important Files</a></dt><dt>I. <a href="#SYSTEMDIRS">Important System Directories</a></dt><dt>J. <a href="#TABEXPANSION">An Introduction to Programmable Completion</a></dt><dt>K. <a href="#LOCALIZATION">Localization</a></dt><dt>L. <a href="#HISTCOMMANDS">History Commands</a></dt><dt>M. <a href="#SAMPLE-BASHRC">Sample <tt class="FILENAME">.bashrc</tt>  and
        <tt class="FILENAME">.bash_profile</tt> Files</a></dt><dt>N. <a href="#DOSBATCH">Converting DOS Batch Files to Shell Scripts</a></dt><dt>O. <a href="#EXERCISES">Exercises</a></dt><dd><dl><dt>O.1. <a href="#SCRIPTANALYSIS">Analyzing Scripts</a></dt><dt>O.2. <a href="#WRITINGSCRIPTS">Writing Scripts</a></dt></dl></dd><dt>P. <a href="#REVISIONHISTORY">Revision History</a></dt><dt>Q. <a href="#MIRRORSITES">Download and Mirror Sites</a></dt><dt>R. <a href="#TODOLIST">To Do List</a></dt><dt>S. <a href="#COPYRIGHT">Copyright</a></dt><dt>T. <a href="#ASCIITABLE">ASCII Table</a></dt><dt><a href="#XREFINDEX">Index</a></dt></dl></div><div class="LOT"><dl class="LOT"><dt><b>List of Tables</b></dt><dt>8-1. <a href="#AEN4294">Operator Precedence</a></dt><dt>15-1. <a href="#JOBIDTABLE">Job identifiers</a></dt><dt>33-1. <a href="#AEN19601">Bash options</a></dt><dt>36-1. <a href="#AEN20327">Numbers representing colors in Escape Sequences</a></dt><dt>B-1. <a href="#AEN22402">Special Shell Variables</a></dt><dt>B-2. <a href="#AEN22473">TEST Operators: Binary Comparison</a></dt><dt>B-3. <a href="#AEN22593">TEST Operators: Files</a></dt><dt>B-4. <a href="#AEN22728">Parameter Substitution and Expansion</a></dt><dt>B-5. <a href="#AEN22828">String Operations</a></dt><dt>B-6. <a href="#AEN22979">Miscellaneous Constructs</a></dt><dt>C-1. <a href="#AEN23200">Basic sed operators</a></dt><dt>C-2. <a href="#AEN23271">Examples of sed operators</a></dt><dt>E-1. <a href="#AEN23549"><i class="FIRSTTERM">Reserved</i> Exit Codes</a></dt><dt>N-1. <a href="#AEN24336">Batch file keywords / variables / operators, and their shell equivalents</a></dt><dt>N-2. <a href="#AEN24545">DOS commands and their UNIX equivalents</a></dt><dt>P-1. <a href="#AEN25364">Revision History</a></dt></dl></div><div class="LOT"><dl class="LOT"><dt><b>List of Examples</b></dt><dt>2-1. <a href="#EX1"><i class="FIRSTTERM">cleanup</i>: A script to clean up log
        files in /var/log</a></dt><dt>2-2. <a href="#EX1A"><i class="FIRSTTERM">cleanup</i>: An improved clean-up
        script</a></dt><dt>2-3. <a href="#EX2"><i class="FIRSTTERM">cleanup</i>: An enhanced
        and generalized version of above scripts.</a></dt><dt>3-1. <a href="#EX8">Code blocks and I/O redirection</a></dt><dt>3-2. <a href="#RPMCHECK">Saving the output of a code block to a file</a></dt><dt>3-3. <a href="#BGLOOP">Running a loop in the background</a></dt><dt>3-4. <a href="#EX58">Backup of all files changed in last day</a></dt><dt>4-1. <a href="#EX9">Variable assignment and substitution</a></dt><dt>4-2. <a href="#EX15">Plain Variable Assignment</a></dt><dt>4-3. <a href="#EX16">Variable Assignment, plain and fancy</a></dt><dt>4-4. <a href="#INTORSTRING">Integer or string?</a></dt><dt>4-5. <a href="#EX17">Positional Parameters</a></dt><dt>4-6. <a href="#EX18"><i class="FIRSTTERM">wh</i>, <i class="FIRSTTERM">                whois</i> domain name lookup</a></dt><dt>4-7. <a href="#EX19">Using <i class="FIRSTTERM">shift</i></a></dt><dt>5-1. <a href="#WEIRDVARS">Echoing Weird Variables</a></dt><dt>5-2. <a href="#ESCAPED">Escaped Characters</a></dt><dt>5-3. <a href="#BASHEK">Detecting key-presses</a></dt><dt>6-1. <a href="#EX5">exit / exit status</a></dt><dt>6-2. <a href="#NEGCOND">Negating a condition using <span class="TOKEN">!</span></a></dt><dt>7-1. <a href="#EX10">What is truth?</a></dt><dt>7-2. <a href="#EX11">Equivalence of <i class="FIRSTTERM">test</i>,
      <tt class="FILENAME">/usr/bin/test</tt>, <span class="TOKEN">[ ]</span>,
      and <tt class="FILENAME">/usr/bin/[</tt></a></dt><dt>7-3. <a href="#ARITHTESTS">Arithmetic Tests using <span class="TOKEN">(( ))</span></a></dt><dt>7-4. <a href="#BROKENLINK">Testing for broken links</a></dt><dt>7-5. <a href="#EX13">Arithmetic and string comparisons</a></dt><dt>7-6. <a href="#STRTEST">Testing whether a string is <i class="FIRSTTERM">null</i></a></dt><dt>7-7. <a href="#EX14"><i class="FIRSTTERM">zmore</i></a></dt><dt>8-1. <a href="#GCD">Greatest common divisor</a></dt><dt>8-2. <a href="#ARITHOPS">Using Arithmetic Operations</a></dt><dt>8-3. <a href="#ANDOR">Compound Condition Tests Using &amp;&amp; and ||</a></dt><dt>8-4. <a href="#NUMBERS">Representation of numerical constants</a></dt><dt>8-5. <a href="#CVARS">C-style manipulation of variables</a></dt><dt>9-1. <a href="#IFSH">$IFS and whitespace</a></dt><dt>9-2. <a href="#TMDIN">Timed Input</a></dt><dt>9-3. <a href="#TIMEOUT">Once more, timed input</a></dt><dt>9-4. <a href="#TOUT">Timed <i class="FIRSTTERM">read</i></a></dt><dt>9-5. <a href="#AMIROOT">Am I root?</a></dt><dt>9-6. <a href="#ARGLIST"><i class="FIRSTTERM">arglist</i>: Listing arguments
          with $* and $@</a></dt><dt>9-7. <a href="#INCOMPAT">Inconsistent <tt class="VARNAME">$*</tt> and <tt class="VARNAME">$@</tt> behavior</a></dt><dt>9-8. <a href="#IFSEMPTY"><tt class="VARNAME">$*</tt> and <tt class="VARNAME">$@</tt> when
            <tt class="VARNAME">$IFS</tt> is empty</a></dt><dt>9-9. <a href="#USCREF">Underscore variable</a></dt><dt>9-10. <a href="#EX20">Using <i class="FIRSTTERM">declare</i> to type variables</a></dt><dt>9-11. <a href="#EX21">Generating random numbers</a></dt><dt>9-12. <a href="#PICKCARD">Picking a random card from a deck</a></dt><dt>9-13. <a href="#BROWNIAN">Brownian Motion Simulation</a></dt><dt>9-14. <a href="#RANDOMBETWEEN">Random between values</a></dt><dt>9-15. <a href="#RANDOMTEST">Rolling a single die with RANDOM</a></dt><dt>9-16. <a href="#SEEDINGRANDOM">Reseeding RANDOM</a></dt><dt>9-17. <a href="#RANDOM2">Pseudorandom numbers, using </a><a href="#AWKREF">awk</a></dt><dt>10-1. <a href="#PARAGRAPHSPACE">Inserting a blank line between paragraphs in a text file</a></dt><dt>10-2. <a href="#RANDSTRING">Generating an 8-character <span class="QUOTE">"random"</span>
            string</a></dt><dt>10-3. <a href="#CVT">Converting graphic file formats, with filename change</a></dt><dt>10-4. <a href="#RA2OGG">Converting streaming audio files to
          <i class="FIRSTTERM">ogg</i></a></dt><dt>10-5. <a href="#GETOPTSIMPLE">Emulating <i class="FIRSTTERM">getopt</i></a></dt><dt>10-6. <a href="#SUBSTRINGEX">Alternate ways of extracting and locating substrings</a></dt><dt>10-7. <a href="#EX6">Using parameter substitution and error messages</a></dt><dt>10-8. <a href="#USAGEMESSAGE">Parameter substitution and <span class="QUOTE">"usage"</span> messages</a></dt><dt>10-9. <a href="#LENGTH">Length of a variable</a></dt><dt>10-10. <a href="#PATTMATCHING">Pattern matching in parameter substitution</a></dt><dt>10-11. <a href="#RFE">Renaming file extensions<span class="TOKEN">:</span></a></dt><dt>10-12. <a href="#EX7">Using pattern matching to parse arbitrary strings</a></dt><dt>10-13. <a href="#VARMATCH">Matching patterns at prefix or suffix of string</a></dt><dt>11-1. <a href="#EX22">Simple <i class="FIRSTTERM">for</i> loops</a></dt><dt>11-2. <a href="#EX22A"><i class="FIRSTTERM">for</i> loop with two parameters in each
          [list] element</a></dt><dt>11-3. <a href="#FILEINFO"><em>Fileinfo:</em> operating on a file list
            contained in a variable</a></dt><dt>11-4. <a href="#FILEINFO01">Operating on a parameterized file list</a></dt><dt>11-5. <a href="#LISTGLOB">Operating on files with a <i class="FIRSTTERM">for</i> loop</a></dt><dt>11-6. <a href="#EX23">Missing <tt class="USERINPUT"><b>in [list]</b></tt> in a
      <i class="FIRSTTERM">for</i> loop</a></dt><dt>11-7. <a href="#FORLOOPCMD">Generating the <tt class="USERINPUT"><b>[list]</b></tt> in
          a <i class="FIRSTTERM">for</i> loop with command substitution</a></dt><dt>11-8. <a href="#BINGREP">A <i class="FIRSTTERM">grep</i> replacement
            for binary files</a></dt><dt>11-9. <a href="#USERLIST">Listing all users on the system</a></dt><dt>11-10. <a href="#FINDSTRING">Checking all the binaries in a directory for
          authorship</a></dt><dt>11-11. <a href="#SYMLINKS">Listing the <i class="FIRSTTERM">symbolic
            links</i> in a directory</a></dt><dt>11-12. <a href="#SYMLINKS2">Symbolic links in a directory, saved to a file</a></dt><dt>11-13. <a href="#FORLOOPC">A C-style <i class="FIRSTTERM">for</i> loop</a></dt><dt>11-14. <a href="#EX24">Using <i class="FIRSTTERM">efax</i> in batch mode</a></dt><dt>11-15. <a href="#EX25">Simple <i class="FIRSTTERM">while</i> loop</a></dt><dt>11-16. <a href="#EX26">Another <i class="FIRSTTERM">while</i> loop</a></dt><dt>11-17. <a href="#EX26A"><i class="FIRSTTERM">while</i> loop with multiple conditions</a></dt><dt>11-18. <a href="#WHLOOPC">C-style syntax in a <i class="FIRSTTERM">while</i> loop</a></dt><dt>11-19. <a href="#EX27"><i class="FIRSTTERM">until</i> loop</a></dt><dt>11-20. <a href="#NESTEDLOOP">Nested Loop</a></dt><dt>11-21. <a href="#EX28">Effects of <i class="FIRSTTERM">break</i> and
      <b class="COMMAND">continue</b> in a loop</a></dt><dt>11-22. <a href="#BREAKLEVELS">Breaking out of multiple loop levels</a></dt><dt>11-23. <a href="#CONTINUELEVELS">Continuing at a higher loop level</a></dt><dt>11-24. <a href="#CONTINUENEX">Using <i class="FIRSTTERM">continue N</i> in an actual task</a></dt><dt>11-25. <a href="#EX29">Using <i class="FIRSTTERM">case</i></a></dt><dt>11-26. <a href="#EX30">Creating menus using <i class="FIRSTTERM">case</i></a></dt><dt>11-27. <a href="#CASECMD">Using <i class="FIRSTTERM">command substitution</i>
          to generate the <i class="FIRSTTERM">case</i> variable</a></dt><dt>11-28. <a href="#MATCHSTRING">Simple string matching</a></dt><dt>11-29. <a href="#ISALPHA">Checking for alphabetic input</a></dt><dt>11-30. <a href="#EX31">Creating menus using <i class="FIRSTTERM">select</i></a></dt><dt>11-31. <a href="#EX32">Creating menus using <i class="FIRSTTERM">select</i>
          in a function</a></dt><dt>12-1. <a href="#STUPSCR">Stupid script tricks</a></dt><dt>12-2. <a href="#CSUBLOOP">Generating a variable from a loop</a></dt><dt>12-3. <a href="#AGRAM2">Finding anagrams</a></dt><dt>15-1. <a href="#SPAWNSCR">A script that spawns multiple instances of itself</a></dt><dt>15-2. <a href="#EX47"><i class="FIRSTTERM">printf</i> in action</a></dt><dt>15-3. <a href="#EX36">Variable assignment, using <i class="FIRSTTERM">read</i></a></dt><dt>15-4. <a href="#READNOVAR">What happens when <i class="FIRSTTERM">read</i> has no
            variable</a></dt><dt>15-5. <a href="#READR">Multi-line input to <i class="FIRSTTERM">read</i></a></dt><dt>15-6. <a href="#ARROWDETECT">Detecting the arrow keys</a></dt><dt>15-7. <a href="#READREDIR">Using <i class="FIRSTTERM">read</i> with
            </a><a href="#IOREDIRREF">file redirection</a></dt><dt>15-8. <a href="#READPIPE">Problems reading from a pipe</a></dt><dt>15-9. <a href="#EX37">Changing the current working directory</a></dt><dt>15-10. <a href="#EX46">Letting <i class="FIRSTTERM">let</i> do arithmetic.</a></dt><dt>15-11. <a href="#EX43">Showing the effect of <i class="FIRSTTERM">eval</i></a></dt><dt>15-12. <a href="#ARRCHOICE">Using <i class="FIRSTTERM">eval</i> to select
                        among variables</a></dt><dt>15-13. <a href="#ECHOPARAMS"><i class="FIRSTTERM">Echoing</i> the
            <i class="FIRSTTERM">command-line parameters</i></a></dt><dt>15-14. <a href="#EX44">Forcing a log-off</a></dt><dt>15-15. <a href="#ROT14">A version of <i class="FIRSTTERM">rot13</i></a></dt><dt>15-16. <a href="#EX34">Using <i class="FIRSTTERM">set</i> with positional
            parameters</a></dt><dt>15-17. <a href="#REVPOSPARAMS">Reversing the positional parameters</a></dt><dt>15-18. <a href="#SETPOS">Reassigning the positional parameters</a></dt><dt>15-19. <a href="#UNS"><span class="QUOTE">"Unsetting"</span> a variable</a></dt><dt>15-20. <a href="#COLTOTALER3">Using <i class="FIRSTTERM">export</i> to pass a variable to an
          embedded <i class="FIRSTTERM">awk</i> script</a></dt><dt>15-21. <a href="#EX33">Using <i class="FIRSTTERM">getopts</i> to read the
            options/arguments passed to a script</a></dt><dt>15-22. <a href="#EX38"><span class="QUOTE">"Including"</span> a data file</a></dt><dt>15-23. <a href="#SELFSOURCE">A (useless) script that sources itself</a></dt><dt>15-24. <a href="#EX54">Effects of <i class="FIRSTTERM">exec</i></a></dt><dt>15-25. <a href="#SELFEXEC">A script that <i class="FIRSTTERM">exec's</i> itself</a></dt><dt>15-26. <a href="#EX39">Waiting for a process to finish before proceeding</a></dt><dt>15-27. <a href="#SELFDESTRUCT">A script that kills itself</a></dt><dt>16-1. <a href="#EX40">Using <i class="FIRSTTERM">ls</i> to create a table of contents
      for burning a <span class="ABBREV">CDR</span> disk</a></dt><dt>16-2. <a href="#HELLOL">Hello or Good-bye</a></dt><dt>16-3. <a href="#EX57"><i class="FIRSTTERM">Badname</i>, eliminate file names
      in current directory containing bad characters and </a><a href="#WHITESPACEREF">whitespace</a>.</dt><dt>16-4. <a href="#IDELETE">Deleting a file by its <i class="FIRSTTERM">inode</i>
            number</a></dt><dt>16-5. <a href="#EX41">Logfile: Using <i class="FIRSTTERM">xargs</i> to monitor system log</a></dt><dt>16-6. <a href="#EX42">Copying files in current directory to another</a></dt><dt>16-7. <a href="#KILLBYNAME">Killing processes by name</a></dt><dt>16-8. <a href="#WF2">Word frequency analysis using
          <i class="FIRSTTERM">xargs</i></a></dt><dt>16-9. <a href="#EX45">Using <i class="FIRSTTERM">expr</i></a></dt><dt>16-10. <a href="#EX51">Using <i class="FIRSTTERM">date</i></a></dt><dt>16-11. <a href="#DATECALC"><i class="FIRSTTERM">Date</i> calculations</a></dt><dt>16-12. <a href="#WF">Word Frequency Analysis</a></dt><dt>16-13. <a href="#SCRIPTDETECTOR">Which files are scripts?</a></dt><dt>16-14. <a href="#RND">Generating 10-digit random numbers</a></dt><dt>16-15. <a href="#EX12">Using <i class="FIRSTTERM">tail</i> to monitor the system log</a></dt><dt>16-16. <a href="#FROMSH">Printing out the <i class="FIRSTTERM">From</i> lines in
            stored e-mail messages</a></dt><dt>16-17. <a href="#GRP">Emulating <i class="FIRSTTERM">grep</i> in a script</a></dt><dt>16-18. <a href="#CWSOLVER">Crossword puzzle solver</a></dt><dt>16-19. <a href="#DICTLOOKUP">Looking up definitions in Webster's 1913 Dictionary</a></dt><dt>16-20. <a href="#LOOKUP">Checking words in a list for validity</a></dt><dt>16-21. <a href="#EX49"><i class="FIRSTTERM">toupper</i>: Transforms a file
          to all uppercase.</a></dt><dt>16-22. <a href="#LOWERCASE"><i class="FIRSTTERM">lowercase</i>: Changes all
          filenames in working directory to lowercase.</a></dt><dt>16-23. <a href="#DU"><i class="FIRSTTERM">du</i>: DOS to UNIX text file conversion.</a></dt><dt>16-24. <a href="#ROT13"><i class="FIRSTTERM">rot13</i>: ultra-weak encryption.</a></dt><dt>16-25. <a href="#CRYPTOQUOTE">Generating <span class="QUOTE">"Crypto-Quote"</span> Puzzles</a></dt><dt>16-26. <a href="#EX50">Formatted file listing.</a></dt><dt>16-27. <a href="#COL">Using <i class="FIRSTTERM">column</i> to format a directory
            listing</a></dt><dt>16-28. <a href="#LNUM"><i class="FIRSTTERM">nl</i>: A self-numbering script.</a></dt><dt>16-29. <a href="#MANVIEW"><i class="FIRSTTERM">manview</i>: Viewing formatted manpages</a></dt><dt>16-30. <a href="#EX48">Using <i class="FIRSTTERM">cpio</i> to move a directory tree</a></dt><dt>16-31. <a href="#DERPM">Unpacking an <i class="FIRSTTERM">rpm</i> archive</a></dt><dt>16-32. <a href="#STRIPC">Stripping comments from C program files</a></dt><dt>16-33. <a href="#WHAT">Exploring <tt class="FILENAME">/usr/X11R6/bin</tt></a></dt><dt>16-34. <a href="#WSTRINGS">An <span class="QUOTE">"improved"</span>
          <i class="FIRSTTERM">strings</i> command</a></dt><dt>16-35. <a href="#FILECOMP">Using <i class="FIRSTTERM">cmp</i> to compare two files
            within a script.</a></dt><dt>16-36. <a href="#EX35"><i class="FIRSTTERM">basename</i> and
          <i class="FIRSTTERM">dirname</i></a></dt><dt>16-37. <a href="#SPLITCOPY">A script that copies itself in sections</a></dt><dt>16-38. <a href="#FILEINTEGRITY">Checking file integrity</a></dt><dt>16-39. <a href="#EX52">Uudecoding encoded files</a></dt><dt>16-40. <a href="#SPAMLOOKUP">Finding out where to report a spammer</a></dt><dt>16-41. <a href="#ISSPAMMER">Analyzing a spam domain</a></dt><dt>16-42. <a href="#QUOTEFETCH">Getting a stock quote</a></dt><dt>16-43. <a href="#FC4UPD">Updating FC4</a></dt><dt>16-44. <a href="#REMOTE">Using <i class="FIRSTTERM">ssh</i></a></dt><dt>16-45. <a href="#SELFMAILER">A script that mails itself</a></dt><dt>16-46. <a href="#PRIMES2">Generating prime numbers</a></dt><dt>16-47. <a href="#MONTHLYPMT">Monthly Payment on a Mortgage</a></dt><dt>16-48. <a href="#BASE">Base Conversion</a></dt><dt>16-49. <a href="#ALTBC">Invoking <i class="FIRSTTERM">bc</i> using a <i class="FIRSTTERM">here
            document</i></a></dt><dt>16-50. <a href="#CANNON">Calculating PI</a></dt><dt>16-51. <a href="#HEXCONVERT">Converting a decimal number to hexadecimal</a></dt><dt>16-52. <a href="#FACTR">Factoring</a></dt><dt>16-53. <a href="#HYPOT">Calculating the hypotenuse of a triangle</a></dt><dt>16-54. <a href="#EX53">Using <i class="FIRSTTERM">seq</i> to generate loop
          arguments</a></dt><dt>16-55. <a href="#LETTERCOUNT">Letter Count"</a></dt><dt>16-56. <a href="#EX33A">Using <i class="FIRSTTERM">getopt</i> to parse command-line
            options</a></dt><dt>16-57. <a href="#SELFCOPY">A script that copies itself</a></dt><dt>16-58. <a href="#EXERCISINGDD">Exercising <i class="FIRSTTERM">dd</i></a></dt><dt>16-59. <a href="#DDKEYPRESS">Capturing Keystrokes</a></dt><dt>16-60. <a href="#RPSDCARD">Preparing a bootable SD card for the
          <em>Raspberry Pi</em></a></dt><dt>16-61. <a href="#BLOTOUT">Securely deleting a file</a></dt><dt>16-62. <a href="#TEMPFILENAME">Filename generator</a></dt><dt>16-63. <a href="#UNITCONVERSION">Converting meters to miles</a></dt><dt>16-64. <a href="#M4">Using <i class="FIRSTTERM">m4</i></a></dt><dt>17-1. <a href="#SETNEWPW">Setting a new password</a></dt><dt>17-2. <a href="#ERASE">Setting an <i class="FIRSTTERM">erase</i> character</a></dt><dt>17-3. <a href="#SECRETPW"><i class="FIRSTTERM">secret password</i>:
          Turning off terminal echoing</a></dt><dt>17-4. <a href="#KEYPRESS">Keypress detection</a></dt><dt>17-5. <a href="#ISCAN">Checking a remote server for
                <i class="FIRSTTERM">identd</i></a></dt><dt>17-6. <a href="#KILLPROCESS"><i class="FIRSTTERM">pidof</i> helps kill a process</a></dt><dt>17-7. <a href="#ISOMOUNTREF">Checking a CD image</a></dt><dt>17-8. <a href="#CREATEFS">Creating a filesystem in a file</a></dt><dt>17-9. <a href="#ADDDRV">Adding a new hard drive</a></dt><dt>17-10. <a href="#ROT13A">Using <i class="FIRSTTERM">umask</i> to hide an output file
            from prying eyes</a></dt><dt>17-11. <a href="#BACKLIGHT"><i class="FIRSTTERM">Backlight</i>: changes
            the brightness of the (laptop) screen backlight</a></dt><dt>17-12. <a href="#EX55"><i class="FIRSTTERM">killall</i>, from <tt class="FILENAME">/etc/rc.d/init.d</tt></a></dt><dt>19-1. <a href="#EX70"><i class="FIRSTTERM">broadcast</i>: Sends message to everyone
    logged in</a></dt><dt>19-2. <a href="#EX69"><i class="FIRSTTERM">dummyfile</i>: Creates a 2-line dummy
    file</a></dt><dt>19-3. <a href="#EX71">Multi-line message using <i class="FIRSTTERM">cat</i></a></dt><dt>19-4. <a href="#EX71A">Multi-line message, with tabs suppressed</a></dt><dt>19-5. <a href="#EX71B">Here document with replaceable parameters</a></dt><dt>19-6. <a href="#EX72">Upload a file pair to <i class="FIRSTTERM">Sunsite</i> incoming
      directory</a></dt><dt>19-7. <a href="#EX71C">Parameter substitution turned off</a></dt><dt>19-8. <a href="#GENERATESCRIPT">A script that generates another script</a></dt><dt>19-9. <a href="#HF">Here documents and functions</a></dt><dt>19-10. <a href="#ANONHEREDOC"><span class="QUOTE">"Anonymous"</span> Here Document</a></dt><dt>19-11. <a href="#COMMENTBLOCK">Commenting out a block of code</a></dt><dt>19-12. <a href="#SELFDOCUMENT">A self-documenting script</a></dt><dt>19-13. <a href="#PREPENDEX">Prepending a line to a file</a></dt><dt>19-14. <a href="#MAILBOXGREP">Parsing a mailbox</a></dt><dt>20-1. <a href="#REDIR1">Redirecting <tt class="FILENAME">stdin</tt> using
      <i class="FIRSTTERM">exec</i></a></dt><dt>20-2. <a href="#REASSIGNSTDOUT">Redirecting <tt class="FILENAME">stdout</tt> using
      <i class="FIRSTTERM">exec</i></a></dt><dt>20-3. <a href="#UPPERCONV">Redirecting both <tt class="FILENAME">stdin</tt> and
      <tt class="FILENAME">stdout</tt> in the same script with
      <i class="FIRSTTERM">exec</i></a></dt><dt>20-4. <a href="#AVOIDSUBSHELL">Avoiding a subshell</a></dt><dt>20-5. <a href="#REDIR2">Redirected <i class="FIRSTTERM">while</i> loop</a></dt><dt>20-6. <a href="#REDIR2A">Alternate form of redirected <i class="FIRSTTERM">while</i> loop</a></dt><dt>20-7. <a href="#REDIR3">Redirected <i class="FIRSTTERM">until</i> loop</a></dt><dt>20-8. <a href="#REDIR4">Redirected <i class="FIRSTTERM">for</i> loop</a></dt><dt>20-9. <a href="#REDIR4A">Redirected <i class="FIRSTTERM">for</i> loop (both
      <tt class="FILENAME">stdin</tt> and <tt class="FILENAME">stdout</tt>
      redirected)</a></dt><dt>20-10. <a href="#REDIR5">Redirected <i class="FIRSTTERM">if/then</i> test</a></dt><dt>20-11. <a href="#NAMESDATA">Data file <i class="FIRSTTERM">names.data</i> for above
    examples</a></dt><dt>20-12. <a href="#LOGEVENTS">Logging events</a></dt><dt>21-1. <a href="#SUBSHELL">Variable scope in a subshell</a></dt><dt>21-2. <a href="#ALLPROFS">List User Profiles</a></dt><dt>21-3. <a href="#PARALLEL-PROCESSES">Running parallel processes in subshells</a></dt><dt>22-1. <a href="#RESTRICTED">Running a script in restricted mode</a></dt><dt>23-1. <a href="#WRPS">Code block redirection without forking</a></dt><dt>23-2. <a href="#PSUBP">Redirecting the output of <i class="FIRSTTERM">process
            substitution</i> into a loop.</a></dt><dt>24-1. <a href="#EX59">Simple functions</a></dt><dt>24-2. <a href="#EX60">Function Taking Parameters</a></dt><dt>24-3. <a href="#FUNCCMDLINEARG">Functions and command-line args passed to the script</a></dt><dt>24-4. <a href="#INDFUNC">Passing an indirect reference to a function</a></dt><dt>24-5. <a href="#DEREFERENCECL">Dereferencing a parameter passed to a function</a></dt><dt>24-6. <a href="#REFPARAMS">Again, dereferencing a parameter passed to a function</a></dt><dt>24-7. <a href="#MAX">Maximum of two numbers</a></dt><dt>24-8. <a href="#EX61">Converting numbers to Roman numerals</a></dt><dt>24-9. <a href="#RETURNTEST">Testing large return values in a function</a></dt><dt>24-10. <a href="#MAX2">Comparing two large integers</a></dt><dt>24-11. <a href="#REALNAME">Real name from username</a></dt><dt>24-12. <a href="#EX62">Local variable visibility</a></dt><dt>24-13. <a href="#RECURSIONDEMO">Demonstration of a simple recursive function</a></dt><dt>24-14. <a href="#RECURSIONDEMO2">Another simple demonstration</a></dt><dt>24-15. <a href="#EX63">Recursion, using a local variable</a></dt><dt>24-16. <a href="#FIBO"><i class="FIRSTTERM">The Fibonacci Sequence</i></a></dt><dt>24-17. <a href="#HANOI"><i class="FIRSTTERM">The Towers of Hanoi</i></a></dt><dt>25-1. <a href="#AL">Aliases within a script</a></dt><dt>25-2. <a href="#UNAL"><i class="FIRSTTERM">unalias</i>: Setting and unsetting
        an alias</a></dt><dt>26-1. <a href="#EX64">Using an <i class="FIRSTTERM">and list</i> to test
          for command-line arguments</a></dt><dt>26-2. <a href="#ANDLIST2">Another command-line arg test using an <i class="FIRSTTERM">and
          list</i></a></dt><dt>26-3. <a href="#EX65">Using <i class="FIRSTTERM">or lists</i> in combination
          with an <i class="FIRSTTERM">and list</i></a></dt><dt>27-1. <a href="#EX66">Simple array usage</a></dt><dt>27-2. <a href="#POEM">Formatting a poem</a></dt><dt>27-3. <a href="#ARRAYOPS">Various array operations</a></dt><dt>27-4. <a href="#ARRAYSTROPS">String operations on arrays</a></dt><dt>27-5. <a href="#SCRIPTARRAY">Loading the contents of a script into an array</a></dt><dt>27-6. <a href="#EX67">Some special properties of arrays</a></dt><dt>27-7. <a href="#EMPTYARRAY">Of empty arrays and empty elements</a></dt><dt>27-8. <a href="#ARRAYASSIGN">Initializing arrays</a></dt><dt>27-9. <a href="#COPYARRAY">Copying and concatenating arrays</a></dt><dt>27-10. <a href="#ARRAYAPPEND">More on concatenating arrays</a></dt><dt>27-11. <a href="#BUBBLE">The Bubble Sort</a></dt><dt>27-12. <a href="#EMBARR">Embedded arrays and indirect references</a></dt><dt>27-13. <a href="#EX68">The Sieve of Eratosthenes</a></dt><dt>27-14. <a href="#EX68A">The Sieve of Eratosthenes, Optimized</a></dt><dt>27-15. <a href="#STACKEX">Emulating a push-down stack</a></dt><dt>27-16. <a href="#QFUNCTION">Complex array application:
               <em>Exploring a weird mathematical series</em></a></dt><dt>27-17. <a href="#TWODIM">Simulating a two-dimensional array, then tilting it</a></dt><dt>28-1. <a href="#INDREF">Indirect Variable References</a></dt><dt>28-2. <a href="#COLTOTALER2">Passing an indirect reference to <i class="FIRSTTERM">awk</i></a></dt><dt>29-1. <a href="#DEVTCP">Using <tt class="FILENAME">/dev/tcp</tt> for
          troubleshooting</a></dt><dt>29-2. <a href="#MUSICSCR">Playing music</a></dt><dt>29-3. <a href="#PIDID">Finding the process associated with a PID</a></dt><dt>29-4. <a href="#CONSTAT">On-line connect status</a></dt><dt>30-1. <a href="#TESTCGI">Print the server environment</a></dt><dt>30-2. <a href="#IPADDRESSES">IP addresses</a></dt><dt>31-1. <a href="#COOKIES">Hiding the cookie jar</a></dt><dt>31-2. <a href="#EX73">Setting up a swapfile using <tt class="FILENAME">/dev/zero</tt></a></dt><dt>31-3. <a href="#RAMDISK">Creating a ramdisk</a></dt><dt>32-1. <a href="#EX74">A buggy script</a></dt><dt>32-2. <a href="#MISSINGKEYWORD">Missing </a><a href="#KEYWORDREF">keyword</a></dt><dt>32-3. <a href="#EX75"><i class="FIRSTTERM">test24</i>: another buggy script</a></dt><dt>32-4. <a href="#ASSERT">Testing a condition with an
          <i class="FIRSTTERM">assert</i></a></dt><dt>32-5. <a href="#EX76">Trapping at exit</a></dt><dt>32-6. <a href="#ONLINE">Cleaning up after <b class="KEYCAP">Control-C</b></a></dt><dt>32-7. <a href="#PROGRESSBAR2">A Simple Implementation of a Progress Bar</a></dt><dt>32-8. <a href="#VARTRACE">Tracing a variable</a></dt><dt>32-9. <a href="#MULTIPLEPROC">Running multiple processes (on an SMP box)</a></dt><dt>34-1. <a href="#BADOP">Numerical and string comparison are not equivalent</a></dt><dt>34-2. <a href="#SUBPIT">Subshell Pitfalls</a></dt><dt>34-3. <a href="#BADREAD">Piping the output of <i class="FIRSTTERM">echo</i> to a
    <i class="FIRSTTERM">read</i></a></dt><dt>36-1. <a href="#EX3"><i class="FIRSTTERM">shell wrapper</i></a></dt><dt>36-2. <a href="#EX4">A slightly more complex <i class="FIRSTTERM">shell
    wrapper</i></a></dt><dt>36-3. <a href="#LOGGINGWRAPPER">A generic <i class="FIRSTTERM">shell wrapper</i> that
    writes to a logfile</a></dt><dt>36-4. <a href="#PRASC">A <i class="FIRSTTERM">shell wrapper</i> around an awk
    script</a></dt><dt>36-5. <a href="#COLTOTALER">A <i class="FIRSTTERM">shell wrapper</i> around another
    awk script</a></dt><dt>36-6. <a href="#EX56">Perl embedded in a <i class="FIRSTTERM">Bash</i> script</a></dt><dt>36-7. <a href="#BASHANDPERL">Bash and Perl scripts combined</a></dt><dt>36-8. <a href="#EX56PY">Python embedded in a <i class="FIRSTTERM">Bash</i> script</a></dt><dt>36-9. <a href="#SPEECH0">A script that speaks</a></dt><dt>36-10. <a href="#RECURSE">A (useless) script that recursively calls itself</a></dt><dt>36-11. <a href="#PBOOK">A (useful) script that recursively calls itself</a></dt><dt>36-12. <a href="#USRMNT">Another (useful) script that recursively calls itself</a></dt><dt>36-13. <a href="#EX30A">A <span class="QUOTE">"colorized"</span> address database</a></dt><dt>36-14. <a href="#DRAW-BOX">Drawing a box</a></dt><dt>36-15. <a href="#COLORECHO">Echoing colored text</a></dt><dt>36-16. <a href="#HORSERACE">A <span class="QUOTE">"horserace"</span> game</a></dt><dt>36-17. <a href="#PROGRESSBAR">A Progress Bar</a></dt><dt>36-18. <a href="#MULTIPLICATION">Return value trickery</a></dt><dt>36-19. <a href="#SUMPRODUCT">Even more return value trickery</a></dt><dt>36-20. <a href="#ARRFUNC">Passing and returning arrays</a></dt><dt>36-21. <a href="#AGRAM">Fun with anagrams</a></dt><dt>36-22. <a href="#DIALOG">Widgets invoked from a shell script</a></dt><dt>36-23. <a href="#TESTSUITE">Test Suite</a></dt><dt>37-1. <a href="#EX77">String expansion</a></dt><dt>37-2. <a href="#EX78">Indirect variable references - the new way</a></dt><dt>37-3. <a href="#RESISTOR">Simple database application, using indirect variable
      referencing</a></dt><dt>37-4. <a href="#CARDS">Using arrays and other miscellaneous trickery
      to deal four random hands from a deck of cards</a></dt><dt>37-5. <a href="#FETCHADDRESS">A simple address database</a></dt><dt>37-6. <a href="#FETCHADDRESS2">A somewhat more elaborate address database</a></dt><dt>37-7. <a href="#CASE4">Testing characters</a></dt><dt>37-8. <a href="#READN">Reading N characters</a></dt><dt>37-9. <a href="#HERECOMMSUB">Using a <i class="FIRSTTERM">here document</i>
                         to set a variable</a></dt><dt>37-10. <a href="#LASTPIPEOPT">Piping input to a </a><a href="#READREF">read</a></dt><dt>37-11. <a href="#NEGARRAY">Negative array indices</a></dt><dt>37-12. <a href="#NEGOFFSET">Negative parameter in string-extraction
                        construct</a></dt><dt>A-1. <a href="#MAILFORMAT"><i class="FIRSTTERM">mailformat</i>: Formatting an e-mail
        message</a></dt><dt>A-2. <a href="#RN"><i class="FIRSTTERM">rn</i>: A simple-minded file renaming
        utility</a></dt><dt>A-3. <a href="#BLANKRENAME"><i class="FIRSTTERM">blank-rename</i>: Renames filenames containing
          blanks</a></dt><dt>A-4. <a href="#ENCRYPTEDPW"><i class="FIRSTTERM">encryptedpw</i>: Uploading to an ftp site,
        using a locally encrypted password</a></dt><dt>A-5. <a href="#COPYCD"><i class="FIRSTTERM">copy-cd</i>: Copying a data CD</a></dt><dt>A-6. <a href="#COLLATZ">Collatz series</a></dt><dt>A-7. <a href="#DAYSBETWEEN"><i class="FIRSTTERM">days-between</i>: Days between two
          dates</a></dt><dt>A-8. <a href="#MAKEDICT">Making a <i class="FIRSTTERM">dictionary</i></a></dt><dt>A-9. <a href="#SOUNDEX">Soundex conversion</a></dt><dt>A-10. <a href="#LIFESLOW"><i class="FIRSTTERM">Game of Life</i></a></dt><dt>A-11. <a href="#GEN0DATA">Data file for <i class="FIRSTTERM">Game of Life</i></a></dt><dt>A-12. <a href="#BEHEAD"><i class="FIRSTTERM">behead</i>: Removing mail and news
        message headers</a></dt><dt>A-13. <a href="#PW"><i class="FIRSTTERM">password</i>: Generating random
        8-character passwords</a></dt><dt>A-14. <a href="#FIFO"><i class="FIRSTTERM">fifo</i>: Making daily backups, using
        named pipes</a></dt><dt>A-15. <a href="#PRIMES">Generating prime numbers using the modulo operator</a></dt><dt>A-16. <a href="#TREE"><i class="FIRSTTERM">tree</i>: Displaying a directory tree</a></dt><dt>A-17. <a href="#TREE2"><i class="FIRSTTERM">tree2</i>: Alternate directory tree script</a></dt><dt>A-18. <a href="#STRING"><i class="FIRSTTERM">string functions</i>: C-style string
        functions</a></dt><dt>A-19. <a href="#DIRECTORYINFO">Directory information</a></dt><dt>A-20. <a href="#HASHLIB">Library of hash functions</a></dt><dt>A-21. <a href="#HASHEXAMPLE">Colorizing text using hash functions</a></dt><dt>A-22. <a href="#HASHEX2">More on hash functions</a></dt><dt>A-23. <a href="#USBINST">Mounting USB keychain storage devices</a></dt><dt>A-24. <a href="#TOHTML">Converting to HTML</a></dt><dt>A-25. <a href="#ARCHIVWEBLOGS">Preserving weblogs</a></dt><dt>A-26. <a href="#PROTECTLITERAL">Protecting literal strings</a></dt><dt>A-27. <a href="#UNPROTECTLITERAL">Unprotecting literal strings</a></dt><dt>A-28. <a href="#ISSPAMMER2">Spammer Identification</a></dt><dt>A-29. <a href="#WHX">Spammer Hunt</a></dt><dt>A-30. <a href="#WGETTER2">Making <i class="FIRSTTERM">wget</i> easier to use</a></dt><dt>A-31. <a href="#BASHPODDER">A <i class="FIRSTTERM">podcasting</i> script</a></dt><dt>A-32. <a href="#NIGHTLYBACKUP">Nightly backup to a firewire HD</a></dt><dt>A-33. <a href="#CDLL">An expanded <i class="FIRSTTERM">cd</i> command</a></dt><dt>A-34. <a href="#SOUNDCARDON">A soundcard setup script</a></dt><dt>A-35. <a href="#FINDSPLIT">Locating split paragraphs in a text file</a></dt><dt>A-36. <a href="#INSERTIONSORT">Insertion sort</a></dt><dt>A-37. <a href="#STDDEV">Standard Deviation</a></dt><dt>A-38. <a href="#PADSW">A <i class="FIRSTTERM">pad</i> file generator for shareware
          authors</a></dt><dt>A-39. <a href="#MANED">A <i class="FIRSTTERM">man page</i> editor</a></dt><dt>A-40. <a href="#PETALS">Petals Around the Rose</a></dt><dt>A-41. <a href="#QKY">Quacky: a Perquackey-type word game</a></dt><dt>A-42. <a href="#NIM">Nim</a></dt><dt>A-43. <a href="#STOPWATCH">A command-line stopwatch</a></dt><dt>A-44. <a href="#HOMEWORK">An all-purpose shell scripting homework assignment solution</a></dt><dt>A-45. <a href="#KTOUR">The Knight's Tour</a></dt><dt>A-46. <a href="#MSQUARE">Magic Squares</a></dt><dt>A-47. <a href="#FIFTEEN">Fifteen Puzzle</a></dt><dt>A-48. <a href="#HANOI2"><i class="FIRSTTERM">The Towers of Hanoi, graphic
            version</i></a></dt><dt>A-49. <a href="#HANOI2A"><i class="FIRSTTERM">The Towers of Hanoi, alternate graphic
            version</i></a></dt><dt>A-50. <a href="#USEGETOPT">An alternate version of the
        </a><a href="#GETOPTSIMPLE">getopt-simple.sh</a> script</dt><dt>A-51. <a href="#USEGETOPT2">The version of the
        <i class="FIRSTTERM">UseGetOpt.sh</i> example used in the </a><a href="#TABEXPANSION">Tab Expansion appendix</a></dt><dt>A-52. <a href="#SHOWALLC">Cycling through all the possible color backgrounds</a></dt><dt>A-53. <a href="#SAMORSE">Morse Code Practice</a></dt><dt>A-54. <a href="#BASE64">Base64 encoding/decoding</a></dt><dt>A-55. <a href="#SEDAPPEND">Inserting text in a file using
         <i class="FIRSTTERM">sed</i></a></dt><dt>A-56. <a href="#GRONSFELD">The Gronsfeld Cipher</a></dt><dt>A-57. <a href="#BINGO">Bingo Number Generator</a></dt><dt>A-58. <a href="#BASICSREVIEWED">Basics Reviewed</a></dt><dt>A-59. <a href="#TESTEXECTIME">Testing execution times of various commands</a></dt><dt>A-60. <a href="#ASSOCARRTEST">Associative arrays vs. conventional arrays (execution
        times)</a></dt><dt>C-1. <a href="#LETTERCOUNT2">Counting Letter Occurrences</a></dt><dt>J-1. <a href="#USEGETOPTEX">Completion script for
        <i class="FIRSTTERM">UseGetOpt.sh</i></a></dt><dt>M-1. <a href="#BASHRC">Sample <tt class="FILENAME">.bashrc</tt> file</a></dt><dt>M-2. <a href="#BASHPROF"><tt class="FILENAME">.bash_profile</tt> file</a></dt><dt>N-1. <a href="#VIEWDAT">VIEWDATA.BAT: DOS Batch File</a></dt><dt>N-2. <a href="#VIEWDATA"><i class="FIRSTTERM">viewdata.sh</i>: Shell Script Conversion
    of VIEWDATA.BAT</a></dt><dt>T-1. <a href="#ASCIISH">A script that generates an ASCII table</a></dt><dt>T-2. <a href="#ASCII2SH">Another ASCII table script</a></dt><dt>T-3. <a href="#ASCII3SH">A third ASCII table script, using
                     <i class="FIRSTTERM">awk</i></a></dt></dl></div><div class="PART"><a name="PART1"></a><div class="TITLEPAGE"><h1 class="TITLE">Part 1. Introduction</h1><div class="PARTINTRO"><a name="AEN43"></a><table border="0" width="100%" cellspacing="0" cellpadding="0" class="EPIGRAPH"><tbody><tr><td width="45%">&nbsp;</td><td width="45%" align="LEFT" valign="TOP"><i><p><i>Script: <em>A writing; a written
          document. [Obs.]</em></i></p><p><i>--<em>Webster's Dictionary</em>, 1913 ed.</i></p></i></td></tr></tbody></table><p><a name="WHATSASCRIPT"></a></p><p>The shell is a command interpreter. More than just the
        insulating layer between the operating system kernel and the user,
        it's also a fairly powerful programming language. A shell program,
        called a <i class="FIRSTTERM">script</i>, is an easy-to-use tool for
        building applications by <span class="QUOTE">"gluing together"</span> system
        calls, tools, utilities, and compiled binaries.  Virtually the
        entire repertoire of UNIX commands, utilities, and tools is
        available for invocation by a shell script. If that were
        not enough, internal shell commands, such as testing and loop
        constructs, lend additional power and flexibility to scripts.
        Shell scripts are especially well suited for administrative
        system tasks and other routine repetitive tasks not requiring the
        bells and whistles of a full-blown tightly structured programming
        language.</p></div><div class="TOC"><dl><dt><b>Table of Contents</b></dt><dt>1. <a href="#WHY-SHELL">Shell Programming!</a></dt><dt>2. <a href="#SHA-BANG">Starting Off With a Sha-Bang</a></dt><dd><dl><dt>2.1. <a href="#INVOKING">Invoking the script</a></dt><dt>2.2. <a href="#PRELIMEXER">Preliminary Exercises</a></dt></dl></dd></dl></div></div><div class="CHAPTER"><hr><h1><a name="WHY-SHELL"></a>Chapter 1. Shell Programming!</h1><table border="0" width="100%" cellspacing="0" cellpadding="0" class="EPIGRAPH"><tbody><tr><td width="45%">&nbsp;</td><td width="45%" align="LEFT" valign="TOP"><i><p><i>No programming language is perfect. There is not even a single
          best language; there are only languages well suited or perhaps
          poorly suited for particular purposes.</i></p><p><i>--Herbert Mayer</i></p></i></td></tr></tbody></table><p>A working knowledge of shell scripting is essential to anyone
        wishing to become reasonably proficient at system administration,
        even if they do not anticipate ever having to actually write a
        script. Consider that as a Linux machine boots up, it executes the
        shell scripts in <tt class="FILENAME">/etc/rc.d</tt>
        to restore the system configuration and set up services. A detailed
        understanding of these startup scripts is important for analyzing
        the behavior of a system, and possibly modifying it.</p><p>The craft of scripting is not hard to master,
        since scripts can be built in bite-sized sections and there
        is only a fairly small set of shell-specific operators and options
  
        <a name="AEN62" href="#FTN.AEN62"><span class="footnote">[1]</span></a>
  
        to learn. The syntax is simple -- even austere -- similar to
        that of invoking and chaining together utilities at the command
        line, and there are only a few <span class="QUOTE">"rules"</span> governing
        their use. Most short scripts work right the first time, and
        debugging even the longer ones is straightforward.</p><p>	    <a name="AEN67"></a></p><blockquote class="BLOCKQUOTE"><p class="LITERALLAYOUT">&nbsp;&nbsp;&nbsp;&nbsp;In&nbsp;the&nbsp;early&nbsp;days&nbsp;of&nbsp;personal&nbsp;computing,&nbsp;the&nbsp;BASIC&nbsp;language&nbsp;enabled<br>
  &nbsp;&nbsp;&nbsp;&nbsp;anyone&nbsp;reasonably&nbsp;computer&nbsp;proficient&nbsp;to&nbsp;write&nbsp;programs&nbsp;on&nbsp;an&nbsp;early<br>
  &nbsp;&nbsp;&nbsp;&nbsp;generation&nbsp;of&nbsp;microcomputers.&nbsp;Decades&nbsp;later,&nbsp;the&nbsp;Bash&nbsp;scripting<br>
  &nbsp;&nbsp;&nbsp;&nbsp;language&nbsp;enables&nbsp;anyone&nbsp;with&nbsp;a&nbsp;rudimentary&nbsp;knowledge&nbsp;of&nbsp;Linux&nbsp;or<br>
  &nbsp;&nbsp;&nbsp;&nbsp;UNIX&nbsp;to&nbsp;do&nbsp;the&nbsp;same&nbsp;on&nbsp;modern&nbsp;machines.<br>
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;We&nbsp;now&nbsp;have&nbsp;miniaturized&nbsp;single-board&nbsp;computers&nbsp;with&nbsp;amazing<br>
  &nbsp;&nbsp;&nbsp;&nbsp;capabilities,&nbsp;such&nbsp;as&nbsp;the&nbsp;<a href="http://www.raspberrypi.org/" target="_top">Raspberry Pi</a>.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;Bash&nbsp;scripting&nbsp;provides&nbsp;a&nbsp;way&nbsp;to&nbsp;explore&nbsp;the&nbsp;capabilities&nbsp;of&nbsp;these<br>
  &nbsp;&nbsp;&nbsp;&nbsp;fascinating&nbsp;devices.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p></blockquote>
      <p></p><p>A shell script is a quick-and-dirty method of prototyping
        a complex application. Getting even a limited subset of
        the functionality to work in a script is often a useful
        first stage in project development. In this way, the structure
        of the application can be tested and tinkered with, and the
        major pitfalls found before proceeding to the final coding
        in <i class="FIRSTTERM">C</i>, <i class="FIRSTTERM">C++</i>,
        <i class="FIRSTTERM">Java</i>, <a href="#PERLREF">Perl</a>,
        or <i class="FIRSTTERM">Python</i>.</p><p>Shell scripting hearkens back to the classic UNIX philosophy
        of breaking complex projects into simpler subtasks, of chaining
        together components and utilities. Many consider this a better,
        or at least more esthetically pleasing approach to problem solving
        than using one of the new generation of high-powered all-in-one
        languages, such as <i class="FIRSTTERM">Perl</i>, which attempt to
        be all things to all people, but at the cost of forcing you to
        alter your thinking processes to fit the tool.</p><p>According to <a href="#MAYERREF">Herbert Mayer</a>,
        <span class="QUOTE">"a useful language needs arrays, pointers,
    and a generic mechanism for building data structures."</span>
    By these criteria, shell scripting falls somewhat short of being
    <span class="QUOTE">"useful."</span> Or, perhaps not. . . .</p><table class="SIDEBAR" border="1" cellpadding="5"><tbody><tr><td><div class="SIDEBAR"><a name="AEN82"></a><p></p><p>When not to use shell scripts
  
        </p><p></p><ul><li><p>Resource-intensive tasks, especially where speed is
        a factor (sorting, hashing, recursion
  
              <a name="AEN87" href="#FTN.AEN87"><span class="footnote">[2]</span></a>
        
        ...)</p></li><li><p>Procedures involving heavy-duty math operations,
        especially floating point arithmetic, arbitrary
        precision calculations, or complex numbers (use
        <i class="FIRSTTERM">C++</i> or <i class="FIRSTTERM">FORTRAN</i>
        instead)</p></li><li><p>Cross-platform portability required (use
        <i class="FIRSTTERM">C</i> or <i class="FIRSTTERM">Java</i>
        instead)</p></li><li><p>Complex applications, where structured programming is
        a necessity (type-checking of variables, function
        prototypes, etc.)</p></li><li><p>Mission-critical applications upon which you are betting the
         future of the company</p></li><li><p>Situations where <em>security</em> is
        important, where you need to guarantee the integrity of
        your system and protect against intrusion, cracking, and
        vandalism</p></li><li><p>Project consists of subcomponents with interlocking
        dependencies</p></li><li><p>Extensive file operations required
        (<i class="FIRSTTERM">Bash</i> is limited to serial file access,
        and that only in a particularly clumsy and inefficient
        line-by-line fashion.)</p></li><li><p>Need native support for multi-dimensional arrays</p></li><li><p>Need data structures, such as linked lists or trees</p></li><li><p>Need to generate / manipulate graphics or GUIs</p></li><li><p>Need direct access to system hardware or
        external peripherals</p></li><li><p>Need port or <a href="#SOCKETREF">socket</a>
        I/O</p></li><li><p>Need to use libraries or interface with legacy code</p></li><li><p>Proprietary, closed-source applications (Shell scripts
        put the source code right out in the open for all the world
        to see.)</p></li></ul><p></p><p>If any of the above applies, consider a more powerful scripting
        language -- perhaps <i class="FIRSTTERM">Perl</i>,
        <i class="FIRSTTERM">Tcl</i>, <i class="FIRSTTERM">Python</i>,
        <i class="FIRSTTERM">Ruby</i> -- or possibly a
        compiled language such as <i class="FIRSTTERM">C</i>,
        <i class="FIRSTTERM">C++</i>, or <i class="FIRSTTERM">Java</i>. Even
        then, prototyping the application as a shell script might still
        be a useful development step.</p><p></p></div></td></tr></tbody></table><p><a name="BASHDEF"></a></p><p>We will be using <span class="ACRONYM">Bash</span>, an acronym
  
          <a name="AEN139" href="#FTN.AEN139"><span class="footnote">[3]</span></a>
  
        for <span class="QUOTE">"Bourne-Again shell"</span> and a pun on Stephen Bourne's
        now classic <i class="FIRSTTERM">Bourne</i> shell. Bash has become
        a <i class="FOREIGNPHRASE">de facto</i> standard for shell
        scripting on most flavors of UNIX. Most of the principles this
        book covers apply equally well to scripting with other shells,
        such as the <i class="FIRSTTERM">Korn Shell</i>, from which Bash
        derives some of its features,
  
         <a name="AEN147" href="#FTN.AEN147"><span class="footnote">[4]</span></a>
  
        and the <i class="FIRSTTERM">C Shell</i> and its variants. (Note that
        <i class="FIRSTTERM">C Shell</i> programming is not recommended due to
        certain inherent problems, as pointed out in an October, 1993 <a href="http://www.faqs.org/faqs/unix-faq/shell/csh-whynot/" target="_top">Usenet
        post</a> by Tom Christiansen.)  </p><p>What follows is a tutorial on shell scripting. It relies
        heavily on examples to illustrate various features of the shell.
        The example scripts work -- they've been tested, insofar as
        possible -- and some of them are even useful in real life. The
        reader can play with the actual working code of the examples
        in the source archive (<tt class="FILENAME">scriptname.sh</tt> or
        <tt class="FILENAME">scriptname.bash</tt>),
  
           <a name="AEN157" href="#FTN.AEN157"><span class="footnote">[5]</span></a>
  
        give them <i class="FIRSTTERM">execute</i> permission
        (<tt class="USERINPUT"><b>chmod u+rx scriptname</b></tt>),
        then run them to see what happens. Should the <a href="http://bash.deta.in/abs-guide-latest.tar.bz2" target="_top">source
        archive</a> not be available, then cut-and-paste from the <a href="http://www.tldp.org/LDP/abs/abs-guide.html.tar.gz" target="_top">HTML</a> or
        <a href="http://bash.deta.in/abs-guide.pdf" target="_top">pdf</a>
        rendered versions. Be aware that some of the scripts presented here
        introduce features before they are explained, and this may require
        the reader to temporarily skip ahead for enlightenment.</p><p>Unless otherwise noted, <a href="mailto:thegrendel.abs@gmail.com" target="_top">the author</a> of this
         book wrote the example scripts that follow.</p><table border="0" width="100%" cellspacing="0" cellpadding="0" class="EPIGRAPH"><tbody><tr><td width="45%">&nbsp;</td><td width="45%" align="LEFT" valign="TOP"><i><p><i>His countenance was bold and bashed not.</i></p><p><i>--Edmund Spenser</i></p></i></td></tr></tbody></table></div><div class="CHAPTER"><hr><h1><a name="SHA-BANG"></a>Chapter 2. Starting Off With a Sha-Bang</h1><table border="0" width="100%" cellspacing="0" cellpadding="0" class="EPIGRAPH"><tbody><tr><td width="45%">&nbsp;</td><td width="45%" align="LEFT" valign="TOP"><i><p><i>Shell programming is a 1950s juke box . . .</i></p><p><i>--Larry Wall</i></p></i></td></tr></tbody></table><p>In the simplest case, a script is nothing more than a list
        of system commands stored in a file. At the very least, this saves
        the effort of retyping that particular sequence of commands each
        time it is invoked.</p><div class="EXAMPLE"><a name="EX1"></a><p><b>Example 2-1. <i class="FIRSTTERM">cleanup</i>: A script to clean up log
        files in /var/log </b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Cleanup
  # Run as root, of course.
  
  cd /var/log
  cat /dev/null &gt; messages
  cat /dev/null &gt; wtmp
  echo "Log files cleaned up."</pre></font></td></tr></tbody></table></div><p>There is nothing unusual here, only a set of commands that
        could just as easily have been invoked one by one from the
        command-line on the console or in a terminal window.
        The advantages of placing the commands in a script go far beyond
        not having to retype them time and again. The script becomes a
        <i class="FIRSTTERM">program</i> -- a <em>tool</em> --
        and it can easily be modified or customized for a particular
        application.</p><div class="EXAMPLE"><a name="EX1A"></a><p><b>Example 2-2. <i class="FIRSTTERM">cleanup</i>: An improved clean-up
        script</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Proper header for a Bash script.
  
  # Cleanup, version 2
  
  # Run as root, of course.
  # Insert code here to print error message and exit if not root.
  
  LOG_DIR=/var/log
  # Variables are better than hard-coded values.
  cd $LOG_DIR
  
  cat /dev/null &gt; messages
  cat /dev/null &gt; wtmp
  
  
  echo "Logs cleaned up."
  
  exit #  The right and proper method of "exiting" from a script.
       #  A bare "exit" (no parameter) returns the exit status
       #+ of the preceding command. </pre></font></td></tr></tbody></table></div><p>Now <em>that's</em> beginning to look like a real
        script. But we can go even farther . . .</p><div class="EXAMPLE"><a name="EX2"></a><p><b>Example 2-3. <i class="FIRSTTERM">cleanup</i>: An enhanced
        and generalized version of above scripts.</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Cleanup, version 3
  
  #  Warning:
  #  -------
  #  This script uses quite a number of features that will be explained
  #+ later on.
  #  By the time you've finished the first half of the book,
  #+ there should be nothing mysterious about it.
  
  
  
  LOG_DIR=/var/log
  ROOT_UID=0     # Only users with $UID 0 have root privileges.
  LINES=50       # Default number of lines saved.
  E_XCD=86       # Can't change directory?
  E_NOTROOT=87   # Non-root exit error.
  
  
  # Run as root, of course.
  if [ "$UID" -ne "$ROOT_UID" ]
  then
    echo "Must be root to run this script."
    exit $E_NOTROOT
  fi  
  
  if [ -n "$1" ]
  # Test whether command-line argument is present (non-empty).
  then
    lines=$1
  else  
    lines=$LINES # Default, if not specified on command-line.
  fi  
  
  
  #  Stephane Chazelas suggests the following,
  #+ as a better way of checking command-line arguments,
  #+ but this is still a bit advanced for this stage of the tutorial.
  #
  #    E_WRONGARGS=85  # Non-numerical argument (bad argument format).
  #
  #    case "$1" in
  #    ""      ) lines=50;;
  #    *[!0-9]*) echo "Usage: `basename $0` lines-to-cleanup";
  #     exit $E_WRONGARGS;;
  #    *       ) lines=$1;;
  #    esac
  #
  #* Skip ahead to "Loops" chapter to decipher all this.
  
  
  cd $LOG_DIR
  
  if [ `pwd` != "$LOG_DIR" ]  # or   if [ "$PWD" != "$LOG_DIR" ]
                              # Not in /var/log?
  then
    echo "Can't change to $LOG_DIR."
    exit $E_XCD
  fi  # Doublecheck if in right directory before messing with log file.
  
  # Far more efficient is:
  #
  # cd /var/log || {
  #   echo "Cannot change to necessary directory." &gt;&amp;2
  #   exit $E_XCD;
  # }
  
  
  
  
  tail -n $lines messages &gt; mesg.temp # Save last section of message log file.
  mv mesg.temp messages               # Rename it as system log file.
  
  
  #  cat /dev/null &gt; messages
  #* No longer needed, as the above method is safer.
  
  cat /dev/null &gt; wtmp  #  ': &gt; wtmp' and '&gt; wtmp'  have the same effect.
  echo "Log files cleaned up."
  #  Note that there are other log files in /var/log not affected
  #+ by this script.
  
  exit 0
  #  A zero return value from the script upon exit indicates success
  #+ to the shell.</pre></font></td></tr></tbody></table></div><p>Since you may not wish to wipe out the entire system log,
        this version of the script keeps the last section of the message
        log intact. You will constantly discover ways of fine-tuning
        previously written scripts for increased effectiveness.</p><p><a name="SHABANGREF"></a>* * *</p><p><a name="MAGNUMREF"></a>The
        <i class="FIRSTTERM"> sha-bang</i>
        (<span class="TOKEN">	 #!</span>)
  
      <a name="AEN205" href="#FTN.AEN205"><span class="footnote">[6]</span></a>
  
        at the head of a script tells your system that this file is a set
        of commands to be fed to the command interpreter indicated. The
        <span class="TOKEN">#!</span> is actually a two-byte
  
          <a name="AEN214" href="#FTN.AEN214"><span class="footnote">[7]</span></a>
  
    
    <i class="FIRSTTERM">magic number</i>, a special marker that
    designates a file type, or in this case an executable shell
    script (type <tt class="USERINPUT"><b>man magic</b></tt> for more
    details on this fascinating topic). Immediately following
    the <i class="FIRSTTERM">sha-bang</i> is a <i class="FIRSTTERM">path
    name</i>. This is the path to the program that interprets
    the commands in the script, whether it be a shell, a programming
    language, or a utility. This command interpreter then executes
    the commands in the script, starting at the top (the line
    following the <i class="FIRSTTERM">sha-bang</i> line), and ignoring
    comments.
  
      <a name="AEN226" href="#FTN.AEN226"><span class="footnote">[8]</span></a>
  
    </p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/sh
  #!/bin/bash
  #!/usr/bin/perl
  #!/usr/bin/tcl
  #!/bin/sed -f
  #!/bin/awk -f</pre></font></td></tr></tbody></table></p><p>Each of the above script header lines calls a different command
        interpreter, be it <tt class="FILENAME">/bin/sh</tt>, the default shell
        (<b class="COMMAND">bash</b> in a Linux system) or otherwise.
  
          <a name="AEN242" href="#FTN.AEN242"><span class="footnote">[9]</span></a>
  
        Using <tt class="USERINPUT"><b>#!/bin/sh</b></tt>, the default Bourne shell
        in most commercial variants of UNIX, makes the script <a href="#PORTABILITYISSUES">portable</a> to non-Linux machines,
        though you <a href="#BINSH">sacrifice Bash-specific
        features</a>.  The script will, however, conform to the
        <span class="ACRONYM">POSIX</span>
  
     <a name="AEN256" href="#FTN.AEN256"><span class="footnote">[10]</span></a>
  
        <b class="COMMAND">sh</b> standard.</p><p>Note that the path given at the <span class="QUOTE">"sha-bang"</span> must
        be correct, otherwise an error message -- usually <span class="QUOTE">"Command
        not found."</span> -- will be the only result of running the
        script.
          <a name="AEN269" href="#FTN.AEN269"><span class="footnote">[11]</span></a>
        
        </p><p><span class="TOKEN">#!</span> can be omitted if the script consists only
        of a set of generic system commands, using no internal
        shell directives.  The second example, above, requires the
        initial <span class="TOKEN">#!</span>, since the variable assignment line,
        <tt class="USERINPUT"><b>lines=50</b></tt>, uses a shell-specific construct.
    <a name="AEN279" href="#FTN.AEN279"><span class="footnote">[12]</span></a>
        Note again that <tt class="USERINPUT"><b>#!/bin/sh</b></tt> invokes the default
        shell interpreter, which defaults to <tt class="FILENAME">/bin/bash</tt>
        on a Linux machine.</p><div class="TIP"><p></p><table class="TIP" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>This tutorial encourages a modular approach
    to constructing a script. Make note of and collect
    <span class="QUOTE">"boilerplate"</span> code snippets that might be useful
    in future scripts. Eventually you will build quite an extensive
    library of nifty routines. As an example, the following script
    prolog tests whether the script has been invoked with the correct
    number of parameters.</p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">E_WRONG_ARGS=85
  script_parameters="-a -h -m -z"
  #                  -a = all, -h = help, etc.
  
  if [ $# -ne $Number_of_expected_args ]
  then
    echo "Usage: `basename $0` $script_parameters"
    # `basename $0` is the script's filename.
    exit $E_WRONG_ARGS
  fi</pre></font></td></tr></tbody></table>
        </p><p>Many times, you will write a script that carries out one
          particular task. The first script in this chapter is an
          example. Later, it might occur to you to generalize
          the script to do other, similar tasks. Replacing the literal
          (<span class="QUOTE">"hard-wired"</span>) constants by variables is a step in
          that direction, as is replacing repetitive code blocks by <a href="#FUNCTIONREF">functions</a>.</p></td></tr></tbody></table></div><div class="SECT1"><hr><h1 class="SECT1"><a name="INVOKING"></a>2.1. Invoking the script</h1><p>Having written the script, you can invoke it by <tt class="USERINPUT"><b>sh
    scriptname</b></tt>,
  
      <a name="AEN300" href="#FTN.AEN300"><span class="footnote">[13]</span></a>
  
    or alternatively <tt class="USERINPUT"><b>bash scriptname</b></tt>. (Not
    recommended is using <tt class="USERINPUT"><b>sh &lt;scriptname</b></tt>,
    since this effectively disables reading from
    <a href="#STDINOUTDEF"><tt class="FILENAME">stdin</tt></a>
    within the script.) Much more convenient is to make
    the script itself directly executable with a <a href="#CHMODREF">chmod</a>.
  
    </p><p></p><div class="VARIABLELIST"><dl><dt>Either:</dt><dd><p><tt class="USERINPUT"><b>chmod 555 scriptname</b></tt> (gives
          everyone read/execute permission)
            <a name="AEN315" href="#FTN.AEN315"><span class="footnote">[14]</span></a>
          </p></dd><dt>or</dt><dd><p><tt class="USERINPUT"><b>chmod +rx scriptname</b></tt> (gives
          everyone read/execute permission)</p><p><tt class="USERINPUT"><b>chmod
          u+rx scriptname</b></tt> (gives only the
      script owner read/execute permission)</p></dd></dl></div>
        <p></p><p>Having made the script executable, you may now test it by
    <tt class="USERINPUT"><b>./scriptname</b></tt>.
    
      <a name="AEN327" href="#FTN.AEN327"><span class="footnote">[15]</span></a>
  
    If it begins with a <span class="QUOTE">"sha-bang"</span> line, invoking the
    script calls the correct command interpreter to run it.</p><p>As a final step, after testing and debugging,
    you would likely want to move it to <tt class="FILENAME">/usr/local/bin</tt> (as
    <i class="FIRSTTERM">root</i>, of course), to make the script
    available to yourself and all other users as a systemwide
    executable.  The script could then be invoked by simply typing
    <b class="COMMAND">scriptname</b> <b class="KEYCAP">[ENTER]</b> from the
    command-line.</p></div><div class="SECT1"><hr><h1 class="SECT1"><a name="PRELIMEXER"></a>2.2. Preliminary Exercises</h1><p></p><ol type="1"><li><p>System administrators often write scripts to automate common
      tasks. Give several instances where such scripts would be
      useful.</p></li><li><p>Write a script that upon invocation shows the
      <a href="#DATEREF">time and date</a>, <a href="#WHOREF">lists all logged-in users</a>, and gives
      the system <a href="#UPTIMEREF">uptime</a>. The script
      then <a href="#IOREDIRREF">saves this information</a>
      to a logfile.</p></li></ol></div></div></div><div class="PART"><a name="PART2"></a><div class="TITLEPAGE"><h1 class="TITLE">Part 2. Basics</h1><div class="TOC"><dl><dt><b>Table of Contents</b></dt><dt>3. <a href="#SPECIAL-CHARS">Special Characters</a></dt><dt>4. <a href="#VARIABLES">Introduction to Variables and Parameters</a></dt><dd><dl><dt>4.1. <a href="#VARSUBN">Variable Substitution</a></dt><dt>4.2. <a href="#VARASSIGNMENT">Variable Assignment</a></dt><dt>4.3. <a href="#UNTYPED">Bash Variables Are Untyped</a></dt><dt>4.4. <a href="#OTHERTYPESV">Special Variable Types</a></dt></dl></dd><dt>5. <a href="#QUOTING">Quoting</a></dt><dd><dl><dt>5.1. <a href="#QUOTINGVAR">Quoting Variables</a></dt><dt>5.2. <a href="#ESCAPINGSECTION">Escaping</a></dt></dl></dd><dt>6. <a href="#EXIT-STATUS">Exit and Exit Status</a></dt><dt>7. <a href="#TESTS">Tests</a></dt><dd><dl><dt>7.1. <a href="#TESTCONSTRUCTS">Test Constructs</a></dt><dt>7.2. <a href="#FTO">File test operators</a></dt><dt>7.3. <a href="#COMPARISON-OPS">Other Comparison Operators</a></dt><dt>7.4. <a href="#NESTEDIFTHEN">Nested <tt class="REPLACEABLE"><i>if/then</i></tt> Condition Tests</a></dt><dt>7.5. <a href="#TESTTEST">Testing Your Knowledge of Tests</a></dt></dl></dd><dt>8. <a href="#OPERATIONS">Operations and Related Topics</a></dt><dd><dl><dt>8.1. <a href="#OPS">Operators</a></dt><dt>8.2. <a href="#NUMERICAL-CONSTANTS">Numerical Constants</a></dt><dt>8.3. <a href="#DBLPARENS">The Double-Parentheses Construct</a></dt><dt>8.4. <a href="#OPPRECEDENCE">Operator Precedence</a></dt></dl></dd></dl></div></div><div class="CHAPTER"><hr><h1><a name="SPECIAL-CHARS"></a>Chapter 3. Special Characters</h1><p>What makes a character <i class="FIRSTTERM">special</i>?
          If it has a meaning beyond its
          <i class="FIRSTTERM">literal meaning</i>, a <a href="#METAMEANINGREF">meta-meaning</a>, then we refer
          to it as a <i class="FIRSTTERM">special character</i>. Along
          with commands and <a href="#KEYWORDREF">keywords</a>,
          <i class="FIRSTTERM">special characters</i> are building blocks
          of Bash scripts.</p><p></p><div class="VARIABLELIST"><p><b><a name="SCHARLIST1"></a>Special Characters Found In
            Scripts and Elsewhere</b></p><dl><dt><a name="HASHMARKREF"></a><span class="TOKEN">#</span></dt><dd><div class="FORMALPARA"><p><b>Comments. </b>Lines beginning with a <span class="TOKEN">#</span>
          (with the exception of <a href="#MAGNUMREF">	      <span class="TOKEN">#!</span></a>) are comments and will
          <em>not</em> be executed.</p></div><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># This line is a comment.</pre></font></td></tr></tbody></table></p><p>Comments may also occur following the end of a command.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo "A comment will follow." # Comment here.
  #                            ^ Note whitespace before #</pre></font></td></tr></tbody></table></p><p><a name="WSBCOMM"></a> Comments may also follow <a href="#WHITESPACEREF">whitespace</a> at the beginning
          of a line.</p><p>             <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">     # A tab precedes this comment.</pre></font></td></tr></tbody></table>
       </p><p><a name="COMMINPIPE"></a>Comments may even be embedded
                within a <a href="#PIPEREF">pipe</a>.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">initial=( `cat "$startfile" | sed -e '/#/d' | tr -d '\n' |\
  # Delete lines containing '#' comment character.
             sed -e 's/\./\. /g' -e 's/_/_ /g'` )
  # Excerpted from life.sh script</pre></font></td></tr></tbody></table>
        </p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>A command may not follow a comment on the
          same line. There is no method of terminating the comment,
          in order for <span class="QUOTE">"live code"</span> to begin on the same
          line. Use a new line for the next command.</p></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>Of course, a <a href="#QUOTINGREF">quoted</a>
        or an <a href="#ESCP">escaped</a> <span class="TOKEN">#</span>
        in an <a href="#ECHOREF">echo</a> statement does
        <em>not</em> begin a comment. Likewise, a
        <span class="TOKEN">#</span> appears in <a href="#PSUB2">certain
        parameter-substitution constructs</a> and in <a href="#NUMCONSTANTS"> numerical constant expressions</a>.
  
        <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo "The # here does not begin a comment."
  echo 'The # here does not begin a comment.'
  echo The \# here does not begin a comment.
  echo The # here begins a comment.
  
  echo ${PATH#*:}       # Parameter substitution, not a comment.
  echo $(( 2#101011 ))  # Base conversion, not a comment.
  
  # Thanks, S.C.</pre></font></td></tr></tbody></table>
  
      The standard <a href="#QUOTINGREF">quoting and
      escape</a> characters (" ' \) escape the #.
      </p></td></tr></tbody></table></div><p>Certain <a href="#PSOREX1">pattern matching
        operations</a> also use the <span class="TOKEN">#</span>.</p></dd><dt><a name="SEMICOLONREF"></a><span class="TOKEN">;</span></dt><dd><div class="FORMALPARA"><p><b>Command separator [semicolon]. </b>Permits putting two or more commands on the same
            line.</p></div><p>	      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo hello; echo there
  
  
  if [ -x "$filename" ]; then    #  Note the space after the semicolon.
  #+                   ^^
    echo "File $filename exists."; cp $filename $filename.bak
  else   #                       ^^
    echo "File $filename not found."; touch $filename
  fi; echo "File test complete."</pre></font></td></tr></tbody></table></p><p>Note that the <span class="QUOTE">"<span class="TOKEN">;</span>"</span>
          <a href="#FINDREF0">sometimes needs to be
          <i class="FIRSTTERM">escaped</i></a>.</p></dd><dt><span class="TOKEN">;;</span></dt><dd><div class="FORMALPARA"><p><b>Terminator in a <a href="#CASEESAC1">case</a> option [double semicolon]. </b><a name="DOUBLESEMICOLON"></a></p></div><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">case "$variable" in
    abc)  echo "\$variable = abc" ;;
    xyz)  echo "\$variable = xyz" ;;
  esac</pre></font></td></tr></tbody></table></p></dd><dt><span class="TOKEN">;;&amp;</span>, <span class="TOKEN">;&amp;</span></dt><dd><div class="FORMALPARA"><p><b><a href="#NCTERM">Terminators</a>
             in a <i class="FIRSTTERM">case</i> option (<a href="#BASH4REF">version 4+</a> of Bash). </b></p></div></dd><dt><span class="TOKEN">.</span></dt><dd><p><a name="DOTREF"></a></p><div class="FORMALPARA"><p><b><span class="QUOTE">"dot"</span> command [period]. </b>Equivalent to <a href="#SOURCEREF">source</a> (see
      <a href="#EX38">Example 15-22</a>). This is a bash <a href="#BUILTINREF">builtin</a>.</p></div></dd><dt><span class="TOKEN">.</span></dt><dd><div class="FORMALPARA"><p><b><span class="QUOTE">"dot"</span>, as a component of a filename. </b>When working with filenames, a leading dot is the prefix
      of a <span class="QUOTE">"hidden"</span> file, a file that an
      <a href="#LSREF">ls</a> will not normally show.
            <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>touch .hidden-file</b></tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -l</b></tt>	      
  <tt class="COMPUTEROUTPUT">total 10
   -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook
   -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak
   -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbook</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -al</b></tt>	      
  <tt class="COMPUTEROUTPUT">total 14
   drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./
   drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../
   -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook
   -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak
   -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook
   -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file</tt>
            </pre></font></td></tr></tbody></table>
          </p></div><p><a name="DOTDIRECTORY"></a></p><p>When considering directory names, <i class="FIRSTTERM">a single
      dot</i> represents the current working directory,
      and <i class="FIRSTTERM">two dots</i> denote the parent
      directory.</p><p>	        <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>pwd</b></tt>
  <tt class="COMPUTEROUTPUT">/home/bozo/projects</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cd .</b></tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>pwd</b></tt>
  <tt class="COMPUTEROUTPUT">/home/bozo/projects</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cd ..</b></tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>pwd</b></tt>
  <tt class="COMPUTEROUTPUT">/home/bozo/</tt>
            </pre></font></td></tr></tbody></table>
          </p><p>The <i class="FIRSTTERM">dot</i> often appears as the
            destination (directory) of a file movement command,
                  in this context meaning <i class="FIRSTTERM">current
                  directory</i>.</p><p>	        <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cp /home/bozo/current_work/junk/* .</b></tt>
            </pre></font></td></tr></tbody></table>
      Copy all the <span class="QUOTE">"junk"</span> files to
      <a href="#PWDREF">$PWD</a>.</p></dd><dt><span class="TOKEN">.</span></dt><dd><div class="FORMALPARA"><p><b><span class="QUOTE">"dot"</span> character match. </b>When <a href="#REGEXDOT">matching
            characters</a>, as part of a <a href="#REGEXREF">regular expression</a>, a
      <span class="QUOTE">"dot"</span> <a href="#REGEXDOT">matches a
      single character</a>.</p></div></dd><dt><span class="TOKEN">"</span></dt><dd><div class="FORMALPARA"><p><b><a href="#DBLQUO">partial
        quoting</a> [double quote]. </b><em>"STRING"</em> preserves (from
          interpretation) most of the special characters within
          <em>STRING</em>. See <a href="#QUOTING">Chapter 5</a>.</p></div></dd><dt><span class="TOKEN">'</span></dt><dd><div class="FORMALPARA"><p><b><a href="#SNGLQUO">full
        quoting</a> [single quote]. </b><em>'STRING'</em> preserves all special
          characters within <em>STRING</em>. This is a
          stronger form of quoting than <em>"STRING"</em>.
          See <a href="#QUOTING">Chapter 5</a>.</p></div></dd><dt><span class="TOKEN">,</span></dt><dd><div class="FORMALPARA"><p><b><a href="#COMMAOP">comma
        operator</a>. </b>The <i class="FIRSTTERM">comma operator</i>
  
      <a name="AEN612" href="#FTN.AEN612"><span class="footnote">[16]</span></a>
  
          links together a
      series of arithmetic operations. All are evaluated,
      but only the last one is returned.
           <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">let "t2 = ((a = 9, 15 / 3))"
  # Set "a = 9" and "t2 = 15 / 3"</pre></font></td></tr></tbody></table>
          </p></div><p><a name="COMMAOP2"></a>The <i class="FIRSTTERM">comma</i>
          operator can also concatenate strings.
           <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">for file in /{,usr/}bin/*calc
  #             ^    Find all executable files ending in "calc"
  #+                 in /bin and /usr/bin directories.
  do
          if [ -x "$file" ]
          then
            echo $file
          fi
  done
  
  # /bin/ipcalc
  # /usr/bin/kcalc
  # /usr/bin/oidcalc
  # /usr/bin/oocalc
  
  
  # Thank you, Rory Winston, for pointing this out.</pre></font></td></tr></tbody></table>
          </p></dd><dt><span class="TOKEN">,</span>, <span class="TOKEN">,</span></dt><dd><div class="FORMALPARA"><p><b><a href="#CASEMODPARAMSUB">Lowercase
              conversion</a> in <i class="FIRSTTERM">parameter substitution</i>
              (added in <a href="#BASH4REF">version 4</a> of Bash). </b></p></div></dd><dt><span class="TOKEN">\</span></dt><dd><div class="FORMALPARA"><p><b><a href="#ESCP">escape</a> [backslash]. </b>A quoting mechanism for single characters.</p></div><p><tt class="USERINPUT"><b>\X</b></tt>
      <i class="FIRSTTERM">escapes</i> the character
      <em>X</em>. This has the effect of
      <span class="QUOTE">"quoting"</span> <em>X</em>, equivalent
      to <em>'X'</em>.  The <span class="TOKEN">\</span> may
      be used to quote <span class="TOKEN">"</span> and <span class="TOKEN">'</span>,
      so they are expressed literally.</p><p>See <a href="#QUOTING">Chapter 5</a> for an in-depth explanation
            of escaped characters.</p></dd><dt><span class="TOKEN">/</span></dt><dd><div class="FORMALPARA"><p><b>Filename path separator [forward slash]. </b>Separates the components of a filename (as in
            <tt class="FILENAME">/home/bozo/projects/Makefile</tt>).</p></div><p>This is also the division <a href="#AROPS1">arithmetic operator</a>.</p></dd><dt><a name="BACKTICKSREF"></a><span class="TOKEN">`</span></dt><dd><div class="FORMALPARA"><p><b><a href="#COMMANDSUBREF">command substitution</a>. </b>The <b class="COMMAND">`command`</b> construct makes
      available the output of <b class="COMMAND">command</b>
      for assignment to a variable. This is also known as
      <a href="#BACKQUOTESREF">backquotes</a> or
      backticks.</p></div></dd><dt><a name="COLON0REF"></a><span class="TOKEN">:</span></dt><dd><p><a name="NULLREF"></a></p><div class="FORMALPARA"><p><b>null command [colon]. </b>This is the shell equivalent of a
      <span class="QUOTE">"NOP"</span> (<tt class="REPLACEABLE"><i>no op</i></tt>, a
      do-nothing operation). It may be considered a synonym for
      the shell builtin <a href="#TRUEREF">true</a>. The
      <span class="QUOTE">"<span class="TOKEN">:</span>"</span> command is itself a
      <i class="FIRSTTERM">Bash</i> <a href="#BUILTINREF">builtin</a>, and its <a href="#EXITSTATUSREF">exit status</a> is
      <i class="FIRSTTERM">true</i>
      (<span class="RETURNVALUE">0</span>).</p></div><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">:
  echo $?   # 0</pre></font></td></tr></tbody></table></p><p>Endless loop:</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">while :
  do
     operation-1
     operation-2
     ...
     operation-n
  done
  
  # Same as:
  #    while true
  #    do
  #      ...
  #    done</pre></font></td></tr></tbody></table>
        </p><p>Placeholder in if/then test:</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">if condition
  then :   # Do nothing and branch ahead
  else     # Or else ...
     take-some-action
  fi</pre></font></td></tr></tbody></table>
        </p><p>Provide a placeholder where a binary operation is
          expected, see <a href="#ARITHOPS">Example 8-2</a> and <a href="#DEFPARAM">default parameters</a>.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">: ${username=`whoami`}
  # ${username=`whoami`}   Gives an error without the leading :
  #                        unless "username" is a command or builtin...
  
  : ${1?"Usage: $0 ARGUMENT"}     # From "usage-message.sh example script.</pre></font></td></tr></tbody></table></p><p>Provide a placeholder where a command is expected in a
          <a href="#HEREDOCREF">here document</a>. See <a href="#ANONHEREDOC">Example 19-10</a>.</p><p>Evaluate string of variables using
      <a href="#PARAMSUBREF">parameter substitution</a>
      (as in <a href="#EX6">Example 10-7</a>).
  
        <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">: ${HOSTNAME?} ${USER?} ${MAIL?}
  #  Prints error message
  #+ if one or more of essential environmental variables not set.</pre></font></td></tr></tbody></table></p><p><b class="COMMAND"><a href="#EXPREPL1">Variable expansion / substring
          replacement</a></b>.</p><p>In combination with the <span class="TOKEN">&gt;</span> <a href="#IOREDIRREF">redirection operator</a>,
          truncates a file to zero length, without changing its
          permissions. If the file did not previously exist,
          creates it.
  
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">: &gt; data.xxx   # File "data.xxx" now empty.	      
  
  # Same effect as   cat /dev/null &gt;data.xxx
  # However, this does not fork a new process, since ":" is a builtin.</pre></font></td></tr></tbody></table>
                See also <a href="#EX12">Example 16-15</a>.</p><p>In combination with the <span class="TOKEN">&gt;&gt;</span>
          redirection operator, has no effect on a pre-existing
          target file (<tt class="USERINPUT"><b>: &gt;&gt; target_file</b></tt>).
          If the file did not previously exist, creates it.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p><a name="REGFILEREF"></a>This applies to regular files,
          not pipes, symlinks, and certain special files.</p></td></tr></tbody></table></div><p>May be used to begin a comment line, although this is not
          recommended. Using <span class="TOKEN">#</span> for a comment turns
          off error checking for the remainder of that line, so
          almost anything may appear in a comment. However,
          this is not the case with
          <span class="TOKEN">:</span>.
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">: This is a comment that generates an error, ( if [ $x -eq 3] ).</pre></font></td></tr></tbody></table>
        </p><p>The <span class="QUOTE">"<span class="TOKEN">:</span>"</span> serves as a <a href="#FIELDREF">field</a>
          separator, in <a href="#DATAFILESREF1"><tt class="FILENAME">/etc/passwd</tt></a>,
          and in the <a href="#PATHREF">$PATH</a> variable.
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $PATH</b></tt>
  <tt class="COMPUTEROUTPUT">/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games</tt></pre></font></td></tr></tbody></table>
        </p><p><a name="COLONFNAME"></a></p><p>A <i class="FIRSTTERM">colon</i> is <a href="#FSTRANGEREF">acceptable as a function name</a>.
                <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">:()
  {
    echo "The name of this function is "$FUNCNAME" "
    # Why use a colon as a function name?
    # It's a way of obfuscating your code.
  }
  
  :
  
  # The name of this function is :</pre></font></td></tr></tbody></table>
  
         This is not <a href="#PORTABILITYISSUES">portable</a>
         behavior, and therefore not a recommended practice.
               In fact, more recent releases of Bash do not permit
         this usage. An underscore <b class="COMMAND">_</b> works,
         though.</p><p><a name="COLONINFUNCTION"></a></p><p>A <i class="FIRSTTERM">colon</i> can serve
            as a placeholder in an otherwise empty
            function.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">not_empty ()
  {
    :
  } # Contains a : (null command), and so is not empty.</pre></font></td></tr></tbody></table></p></dd><dt><a name="NOTREF"></a><span class="TOKEN">!</span></dt><dd><div class="FORMALPARA"><p><b>reverse (or negate) the sense of
      a test or exit status [bang]. </b>The <span class="TOKEN">!</span> operator inverts the <a href="#EXITSTATUSREF">exit status</a>
      of the command to which it is applied (see
      <a href="#NEGCOND">Example 6-2</a>). It also inverts
      the meaning of a test operator. This can, for
      example, change the sense of <i class="FIRSTTERM">equal</i>
      ( <a href="#EQUALSIGNREF">=</a>
      ) to <i class="FIRSTTERM">not-equal</i> ( != ). The
      <span class="TOKEN">!</span> operator is a Bash <a href="#KEYWORDREF">keyword</a>.</p></div><p>In a different context, the <span class="TOKEN">!</span>
            also appears in <a href="#IVRREF">indirect variable
      references</a>.</p><p>In yet another context, from the <i class="FIRSTTERM">command
      line</i>, the <span class="TOKEN">!</span> invokes the
      Bash <i class="FIRSTTERM">history mechanism</i> (see <a href="#HISTCOMMANDS">Appendix L</a>). Note that within a script,
      the history mechanism is disabled.</p></dd><dt><a name="ASTERISKREF"></a><span class="TOKEN">*</span></dt><dd><div class="FORMALPARA"><p><b>wild card [asterisk]. </b>The <span class="TOKEN">*</span> character serves as a <span class="QUOTE">"wild
            card"</span> for filename expansion in
      <a href="#GLOBBINGREF">globbing</a>. By itself,
      it matches every filename in a given directory.</p></div><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo *</b></tt>
  <tt class="COMPUTEROUTPUT">abs-book.sgml add-drive.sh agram.sh alias.sh</tt>
          </pre></font></td></tr></tbody></table>
        </p><p><a name="ASTERISKREF2"></a></p><p>The <span class="TOKEN">*</span> also represents <a href="#ASTERISKREG">any number
          (or zero) characters</a> in a <a href="#REGEXREF">regular expression</a>.</p></dd><dt><span class="TOKEN">*</span></dt><dd><div class="FORMALPARA"><p><b><a href="#AROPS1">arithmetic operator</a>. </b>In the context of arithmetic operations, the
            <span class="TOKEN">*</span> denotes multiplication.</p></div><p><span class="TOKEN">**</span> A double asterisk can represent the
                <a href="#EXPONENTIATIONREF">exponentiation</a>
                operator or <a href="#GLOBSTARREF">extended
                file-match</a> <i class="FIRSTTERM">globbing</i>.</p></dd><dt><span class="TOKEN">?</span></dt><dd><div class="FORMALPARA"><p><b>test operator. </b>Within certain expressions, the <span class="TOKEN">?</span> indicates
            a test for a condition.</p></div><p><a name="CSTRINARY"></a></p><p>In a <a href="#DBLPARENS">double-parentheses
            construct</a>, the <span class="TOKEN">?</span>
      can serve as an element of a C-style
      <i class="FIRSTTERM">trinary</i> operator.
      <a name="AEN888" href="#FTN.AEN888"><span class="footnote">[17]</span></a>
    </p><p><tt class="VARNAME">condition</tt><b class="COMMAND">?</b><tt class="VARNAME">result-if-true</tt><b class="COMMAND">:</b><tt class="VARNAME">result-if-false</tt></p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">(( var0 = var1&lt;98?9:21 ))
  #                ^ ^
  
  # if [ "$var1" -lt 98 ]
  # then
  #   var0=9
  # else
  #   var0=21
  # fi</pre></font></td></tr></tbody></table></p><p>In a <a href="#PARAMSUBREF">parameter
            substitution</a> expression, the <span class="TOKEN">?</span>
      <a href="#QERRMSG">tests whether a variable has been
      set</a>.</p></dd><dt><a name="WILDCARDQU"></a><span class="TOKEN">?</span></dt><dd><div class="FORMALPARA"><p><b>wild card. </b><a name="QUEXWC"></a>The <span class="TOKEN">?</span> character
      serves as a single-character <span class="QUOTE">"wild card"</span>
      for filename expansion in <a href="#GLOBBINGREF">globbing</a>, as well as <a href="#QUEXREGEX">representing one character</a>
      in an <a href="#EXTREGEX">extended regular
      expression</a>.</p></div></dd><dt><span class="TOKEN">$</span></dt><dd><div class="FORMALPARA"><p><b><a href="#VARSUBN">Variable
                substitution</a> (contents of a variable). </b>	       <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">var1=5
  var2=23skidoo
  
  echo $var1     # 5
  echo $var2     # 23skidoo</pre></font></td></tr></tbody></table>
           </p></div><p><a name="VARPREFIXREF"></a></p><p>A <span class="TOKEN">$</span> prefixing a variable name
      indicates the <i class="FIRSTTERM">value</i> the variable
      holds.</p></dd><dt><span class="TOKEN">$</span></dt><dd><div class="FORMALPARA"><p><b>end-of-line. </b>In a <a href="#REGEXREF">regular expression</a>, a
      <span class="QUOTE">"$"</span> addresses the <a href="#DOLLARSIGNREF">end of a line</a> of
      text.</p></div></dd><dt><span class="TOKEN">${}</span></dt><dd><div class="FORMALPARA"><p><b><a href="#PARAMSUBREF">Parameter
                substitution</a>. </b></p></div></dd><dt><span class="TOKEN">$' ... '</span></dt><dd><div class="FORMALPARA"><p><b><a href="#STRQ">Quoted string
                      expansion</a>. </b>This construct expands single or multiple
            escaped octal or hex values into ASCII
  
            <a name="AEN1001" href="#FTN.AEN1001"><span class="footnote">[18]</span></a>
            
            or <a href="#UNICODEREF">Unicode</a>
            characters.</p></div></dd><dt><span class="TOKEN">$*</span>, <span class="TOKEN">$@</span></dt><dd><div class="FORMALPARA"><p><b><a href="#APPREF">positional
        parameters</a>. </b></p></div></dd><dt><span class="TOKEN">$?</span></dt><dd><div class="FORMALPARA"><p><b>exit status variable. </b>The <a href="#EXSREF">$? variable</a>
            holds the <a href="#EXITSTATUSREF">exit status</a>
      of a command, a <a href="#FUNCTIONREF">function</a>,
      or of the script itself.</p></div></dd><dt><a name="PROCESSIDREF"></a><span class="TOKEN">$$</span></dt><dd><div class="FORMALPARA"><p><b>process ID variable. </b>The <a href="#PROCCID">$$ variable</a>
            holds the <i class="FIRSTTERM">process ID</i>
        <a name="AEN1071" href="#FTN.AEN1071"><span class="footnote">[19]</span></a>
      of the script in which it appears.</p></div></dd><dt><a name="PARENSREF"></a><span class="TOKEN">()</span></dt><dd><div class="FORMALPARA"><p><b>command group. </b><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">(a=hello; echo $a)</pre></font></td></tr></tbody></table></p></div><div class="IMPORTANT"><p></p><table class="IMPORTANT" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/important.gif" hspace="5" alt="Important"></td><td align="LEFT" valign="TOP"><p>A listing of commands within
          <tt class="REPLACEABLE"><i>parentheses</i></tt> starts a <a href="#SUBSHELLSREF">subshell</a>.</p><p>Variables inside parentheses, within the subshell, are not
          visible to the rest of the script. The parent process,
          the script, <a href="#PARVIS">cannot read variables
          created in the child process</a>, the subshell.
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">a=123
  ( a=321; )	      
  
  echo "a = $a"   # a = 123
  # "a" within parentheses acts like a local variable.</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div><div class="FORMALPARA"><p><b>array initialization. </b>	      <a name="ARRAYINIT1"></a>
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">Array=(element1 element2 element3)</pre></font></td></tr></tbody></table>
        </p></div></dd><dt><span class="TOKEN">{xxx,yyy,zzz,...}</span></dt><dd><div class="FORMALPARA"><p><b>Brace expansion. </b><a name="BRACEEXPREF"></a>
  <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo \"{These,words,are,quoted}\"   # " prefix and suffix
  # "These" "words" "are" "quoted"
  
  
  cat {file1,file2,file3} &gt; combined_file
  # Concatenates the files file1, file2, and file3 into combined_file.
  
  cp file22.{txt,backup}
  # Copies "file22.txt" to "file22.backup"</pre></font></td></tr></tbody></table></p></div><p>A command may act upon a comma-separated list of file specs within
      <tt class="REPLACEABLE"><i>braces</i></tt>.
  
         <a name="AEN1124" href="#FTN.AEN1124"><span class="footnote">[20]</span></a>
      
      Filename expansion (<a href="#GLOBBINGREF">globbing</a>)
      applies to the file specs between the braces.</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>No spaces allowed within the braces
        <em>unless</em> the spaces are quoted or escaped.</p><p><tt class="USERINPUT"><b>echo {file1,file2}\ :{\ A," B",' C'}</b></tt></p><p><tt class="COMPUTEROUTPUT">file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C</tt></p></td></tr></tbody></table></div></dd><dt><a name="BRACEEXPREF33"></a><span class="TOKEN">{a..z}</span></dt><dd><div class="FORMALPARA"><p><b>Extended Brace expansion. </b><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z
  # Echoes characters between a and z.
  
  echo {0..3} # 0 1 2 3
  # Echoes characters between 0 and 3.
  
  
  base64_charset=( {A..Z} {a..z} {0..9} + / = )
  # Initializing an array, using extended brace expansion.
  # From vladz's "base64.sh" example script.</pre></font></td></tr></tbody></table>
          </p></div><p>The <i class="FIRSTTERM">{a..z}</i>
        <a href="#BRACEEXPREF3">extended brace
        expansion</a> construction is a feature introduced
        in <a href="#BASH3REF">version 3</a> of
        <i class="FIRSTTERM">Bash</i>.</p></dd><dt><a name="CODEBLOCKREF"></a><span class="TOKEN">{}</span></dt><dd><div class="FORMALPARA"><p><b>Block of code [curly brackets]. </b>Also referred to as an <i class="FIRSTTERM">inline group</i>,
      this construct, in effect, creates an <i class="FIRSTTERM">anonymous
      function</i> (a function without a
      name). However, unlike in a <span class="QUOTE">"standard"</span> <a href="#FUNCTIONREF">function</a>, the variables
      inside a code block remain visible to the remainder of the
      script.</p></div><p> <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>{ local a;
          a=123; }</b></tt>
  <tt class="COMPUTEROUTPUT">bash: local: can only be used in a
  function</tt>
          </pre></font></td></tr></tbody></table> </p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">a=123
  { a=321; }
  echo "a = $a"   # a = 321   (value inside code block)
  
  # Thanks, S.C.</pre></font></td></tr></tbody></table></p><p><a name="BLOCKIO"></a></p><p>The code block enclosed in braces may have <a href="#IOREDIRREF">I/O redirected</a> to and from
          it.</p><div class="EXAMPLE"><a name="EX8"></a><p><b>Example 3-1. Code blocks and I/O redirection</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Reading lines in /etc/fstab.
  
  File=/etc/fstab
  
  {
  read line1
  read line2
  } &lt; $File
  
  echo "First line in $File is:"
  echo "$line1"
  echo
  echo "Second line in $File is:"
  echo "$line2"
  
  exit 0
  
  # Now, how do you parse the separate fields of each line?
  # Hint: use awk, or . . .
  # . . . Hans-Joerg Diers suggests using the "set" Bash builtin.</pre></font></td></tr></tbody></table></div><p><a name="BLOCKIO2"></a></p><div class="EXAMPLE"><a name="RPMCHECK"></a><p><b>Example 3-2. Saving the output of a code block to a file</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # rpm-check.sh
  
  #  Queries an rpm file for description, listing,
  #+ and whether it can be installed.
  #  Saves output to a file.
  # 
  #  This script illustrates using a code block.
  
  SUCCESS=0
  E_NOARGS=65
  
  if [ -z "$1" ]
  then
    echo "Usage: `basename $0` rpm-file"
    exit $E_NOARGS
  fi  
  
  { # Begin code block.
    echo
    echo "Archive Description:"
    rpm -qpi $1       # Query description.
    echo
    echo "Archive Listing:"
    rpm -qpl $1       # Query listing.
    echo
    rpm -i --test $1  # Query whether rpm file can be installed.
    if [ "$?" -eq $SUCCESS ]
    then
      echo "$1 can be installed."
    else
      echo "$1 cannot be installed."
    fi  
    echo              # End code block.
  } &gt; "$1.test"       # Redirects output of everything in block to file.
  
  echo "Results of rpm test in file $1.test"
  
  # See rpm man page for explanation of options.
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>Unlike a command group within (parentheses),
          as above, a code block enclosed by {braces} will
          <em>not</em> normally launch a <a href="#SUBSHELLSREF">subshell</a>.
  
      <a name="AEN1199" href="#FTN.AEN1199"><span class="footnote">[21]</span></a>
  
                  </p><p>It is possible to <a href="#ITERATIONREF">iterate</a> a code block
                  using a <a href="#NODODONE">non-standard
                  <i class="FIRSTTERM">for-loop</i></a>.</p></td></tr></tbody></table></div></dd><dt><span class="TOKEN">{}</span></dt><dd><div class="FORMALPARA"><p><b>placeholder for text. </b>Used after <a href="#XARGSCURLYREF">xargs
      <tt class="OPTION">-i</tt></a> (<i class="FIRSTTERM">replace
      strings</i> option). The <span class="TOKEN">{}</span> double
      curly brackets are a placeholder for output text.</p></div><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">ls . | xargs -i -t cp ./{} $1
  #            ^^         ^^
  
  # From "ex42.sh" (copydir.sh) example.</pre></font></td></tr></tbody></table></p><p><a name="SEMICOLONESC"></a></p></dd><dt><span class="TOKEN">{} \;</span></dt><dd><div class="FORMALPARA"><p><b>pathname. </b>Mostly used in <a href="#FINDREF">find</a>
      constructs. This is <em>not</em> a shell
      <a href="#BUILTINREF">builtin</a>.</p></div><table class="SIDEBAR" border="1" cellpadding="5"><tbody><tr><td><div class="SIDEBAR"><a name="AEN1234"></a><p></p><p><a name="PATHNAMEREF"></a></p><p>Definition: A <i class="FIRSTTERM">pathname</i>
                is a <i class="FIRSTTERM">filename</i> that includes the
                complete <a href="#PATHREF">path</a>.  As an example,
                <tt class="FILENAME">/home/bozo/Notes/Thursday/schedule.txt</tt>.
                This is sometimes referred to as the <i class="FIRSTTERM">absolute
                path</i>.</p><p></p></div></td></tr></tbody></table><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <span class="QUOTE">"<span class="TOKEN">;</span>"</span> ends
      the <tt class="OPTION">-exec</tt> option of a
      <b class="COMMAND">find</b> command sequence.  It needs
      to be escaped to protect it from interpretation by the
      shell.</p></td></tr></tbody></table></div></dd><dt><a name="LEFTBRACKET"></a><span class="TOKEN">[ ]</span></dt><dd><div class="FORMALPARA"><p><b>test. </b><a name="BRACKTEST"></a></p></div><p><a href="#IFTHEN">Test</a> expression between
           <b class="COMMAND">[ ]</b>.	Note that <b class="COMMAND">[</b>
           is part of the shell <i class="FIRSTTERM">builtin</i> <a href="#TTESTREF">test</a> (and a synonym for it),
           <em>not</em> a link to the external command
           <tt class="FILENAME">/usr/bin/test</tt>.</p></dd><dt><span class="TOKEN">[[ ]]</span></dt><dd><div class="FORMALPARA"><p><b>test. </b></p></div><p>Test expression between <span class="TOKEN">[[ ]]</span>. More
         flexible than the single-bracket <span class="TOKEN">[ ]</span> test,
         this is a shell <a href="#KEYWORDREF">keyword</a>.</p><p>See the
         discussion on the <a href="#DBLBRACKETS">[[ ... ]]
         construct</a>.</p></dd><dt><span class="TOKEN">[ ]</span></dt><dd><div class="FORMALPARA"><p><b>array element. </b></p></div><p>In the context of an <a href="#ARRAYREF">array</a>,
           brackets set off the numbering of each element of that array.
             <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">Array[1]=slot_1
  echo ${Array[1]}</pre></font></td></tr></tbody></table></p></dd><dt><span class="TOKEN">[ ]</span></dt><dd><div class="FORMALPARA"><p><b>range of characters. </b></p></div><p>As part of a <a href="#REGEXREF">regular
           expression</a>, brackets delineate a <a href="#BRACKETSREF">range of characters</a> to
           match.</p></dd><dt><a name="BRACKETARITH"></a><span class="TOKEN">$[ ... ]</span></dt><dd><div class="FORMALPARA"><p><b>integer expansion. </b></p></div><p>Evaluate integer expression between
           <span class="TOKEN">$[ ]</span>.
                 <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">a=3
  b=7
  
  echo $[$a+$b]   # 10
  echo $[$a*$b]   # 21</pre></font></td></tr></tbody></table></p><p>Note that this usage is <em>deprecated</em>,
                 and has been replaced by the
                 <a href="#DBLPARENS">(( ... ))</a> construct.</p></dd><dt><span class="TOKEN">(( ))</span></dt><dd><div class="FORMALPARA"><p><b>integer expansion. </b></p></div><p>Expand and evaluate integer expression between
           <span class="TOKEN">(( ))</span>.</p><p>See the discussion on the <a href="#DBLPARENS">(( ... )) construct</a>.</p></dd><dt><span class="TOKEN">&gt;</span> <span class="TOKEN">&amp;&gt;</span> <span class="TOKEN">&gt;&amp;</span> <span class="TOKEN">&gt;&gt;</span> <span class="TOKEN">&lt;</span> <span class="TOKEN">&lt;&gt;</span></dt><dd><div class="FORMALPARA"><p><b><a href="#IOREDIRREF">redirection</a>. </b></p></div><p><tt class="USERINPUT"><b>scriptname &gt;filename</b></tt> redirects the output of
          <tt class="FILENAME">scriptname</tt> to file
          <tt class="FILENAME">filename</tt>. Overwrite
          <tt class="FILENAME">filename</tt> if it already exists.</p><p><a name="REDIROUTERROR"></a></p><p><tt class="USERINPUT"><b>command &amp;&gt;filename</b></tt> redirects
          both the <a href="#STDINOUTDEF"><tt class="FILENAME">stdout</tt></a>
          and the
          <tt class="FILENAME">stderr</tt> of <tt class="FILENAME">command</tt>
          to <tt class="FILENAME">filename</tt>.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>                <a name="DEVNULLREDIRECT"></a>
            This is useful for suppressing output when
                  testing for a condition. For example, let us
                  test whether a certain command exists.
                </p><p>		    <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>type bogus_command &amp;&gt;/dev/null</b></tt>
  <tt class="COMPUTEROUTPUT"></tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $?</b></tt>
  <tt class="COMPUTEROUTPUT">1</tt>
                      </pre></font></td></tr></tbody></table>
                </p><p>Or in a script:</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">command_test () { type "$1" &amp;&gt;/dev/null; }
  #                                      ^
  
  cmd=rmdir            # Legitimate command.
  command_test $cmd; echo $?   # 0
  
  
  cmd=bogus_command    # Illegitimate command
  command_test $cmd; echo $?   # 1</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div><p><a name="REDIROUTERROR2"></a></p><p><tt class="USERINPUT"><b>command &gt;&amp;2</b></tt> redirects
          <tt class="FILENAME">stdout</tt> of <tt class="FILENAME">command</tt>
          to <tt class="FILENAME">stderr</tt>.</p><p><tt class="USERINPUT"><b>scriptname &gt;&gt;filename</b></tt> appends
          the output of <tt class="FILENAME">scriptname</tt>
          to file <tt class="FILENAME">filename</tt>. If
          <tt class="FILENAME">filename</tt> does not already exist,
          it is created.</p><p><a name="REDIRRW"></a></p><p><tt class="USERINPUT"><b>[i]&lt;&gt;filename</b></tt>
                 opens file <tt class="FILENAME">filename</tt> for reading
                 and writing, and assigns <a href="#FDREF">file
                 descriptor</a> <span class="TOKEN">i</span> to it. If
                 <tt class="FILENAME">filename</tt> does not exist, it is
                 created.</p><div class="FORMALPARA"><p><b><a href="#PROCESSSUBREF">process substitution</a>. </b></p></div><p><tt class="USERINPUT"><b>(command)&gt;</b></tt></p><p><tt class="USERINPUT"><b>&lt;(command)</b></tt></p><p><a href="#LTREF">In a different context</a>,
          the <span class="QUOTE">"<span class="TOKEN">&lt;</span>"</span> and
          <span class="QUOTE">"<span class="TOKEN">&gt;</span>"</span> characters act
          as <a href="#SCOMPARISON1">string comparison
          operators</a>.</p><p><a href="#INTLT">In yet another context</a>,
          the <span class="QUOTE">"<span class="TOKEN">&lt;</span>"</span> and
          <span class="QUOTE">"<span class="TOKEN">&gt;</span>"</span> characters act
          as <a href="#ICOMPARISON1">integer comparison
          operators</a>. See also <a href="#EX45">Example 16-9</a>.</p></dd><dt><a name="HEREDOCRRREF"></a><span class="TOKEN">&lt;&lt;</span></dt><dd><div class="FORMALPARA"><p><b>redirection used in a <a href="#HEREDOCREF">here document</a>. </b></p></div></dd><dt><a name="HERESTRINGREF"></a><span class="TOKEN">&lt;&lt;&lt;</span></dt><dd><div class="FORMALPARA"><p><b>redirection used in a <a href="#HERESTRINGSREF">here string</a>. </b></p></div></dd><dt><span class="TOKEN">&lt;</span>, <span class="TOKEN">&gt;</span></dt><dd><div class="FORMALPARA"><p><b><a href="#LTREF">ASCII
        comparison</a>. </b><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">veg1=carrots
  veg2=tomatoes
  
  if [[ "$veg1" &lt; "$veg2" ]]
  then
    echo "Although $veg1 precede $veg2 in the dictionary,"
    echo -n "this does not necessarily imply anything "
    echo "about my culinary preferences."
  else
    echo "What kind of dictionary are you using, anyhow?"
  fi</pre></font></td></tr></tbody></table></p></div></dd><dt><span class="TOKEN">\&lt;</span>, <span class="TOKEN">\&gt;</span></dt><dd><div class="FORMALPARA"><p><b><a href="#ANGLEBRAC">word
        boundary</a> in a <a href="#REGEXREF">regular
        expression</a>. </b></p></div><p><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>grep '\&lt;the\&gt;' textfile</b></tt></p></dd><dt><span class="TOKEN">|</span></dt><dd><p><a name="PIPEREF"></a></p><div class="FORMALPARA"><p><b>pipe. </b>Passes the output (<tt class="FILENAME">stdout</tt>)
      of a previous command to the input
      (<tt class="FILENAME">stdin</tt>) of the next one, or
      to the shell. This is a method of chaining commands
      together.</p></div><p>              <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo ls -l | sh
  #  Passes the output of "echo ls -l" to the shell,
  #+ with the same result as a simple "ls -l".
  
  
  cat *.lst | sort | uniq
  # Merges and sorts all ".lst" files, then deletes duplicate lines.</pre></font></td></tr></tbody></table>
        </p><table class="SIDEBAR" border="1" cellpadding="5"><tbody><tr><td><div class="SIDEBAR"><a name="AEN1555"></a><p></p><p>	      A pipe, as a classic method of interprocess
          communication, sends the <tt class="FILENAME">stdout</tt>
          of one <a href="#PROCESSREF">process</a> to the
          <tt class="FILENAME">stdin</tt> of another. In a typical case,
          a command, such as <a href="#CATREF">cat</a> or
          <a href="#ECHOREF">echo</a>, pipes a stream of
          data to a
          <a name="FILTERDEF"></a>
          <i class="FIRSTTERM">filter</i>, a command that
          transforms its input for processing.
      <a name="AEN1564" href="#FTN.AEN1564"><span class="footnote">[22]</span></a>
          </p><p>  
          <tt class="USERINPUT"><b>cat $filename1 $filename2 | grep $search_word</b></tt>
              </p><p>For an interesting note on the complexity of using UNIX
          pipes, see <a href="http://www.faqs.org/faqs/unix-faq/faq/part3/" target="_top">the UNIX FAQ,
          Part 3</a>.</p><p></p></div></td></tr></tbody></table><p><a name="UCREF"></a>The output of a command or commands
          may be piped to a script.
  
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # uppercase.sh : Changes input to uppercase.
  
  tr 'a-z' 'A-Z'
  #  Letter ranges must be quoted
  #+ to prevent filename generation from single-letter filenames.
  
  exit 0</pre></font></td></tr></tbody></table>
                Now, let us pipe the output of <b class="COMMAND">ls -l</b> to this
          script.
  
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -l | ./uppercase.sh</b></tt>
  <tt class="COMPUTEROUTPUT">-RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT
   -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT
   -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE</tt>
          </pre></font></td></tr></tbody></table>
        </p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <tt class="FILENAME">stdout</tt> of each process in
           a pipe must be read as the <tt class="FILENAME">stdin</tt>
           of the next. If this is not the case, the data stream
           will <i class="FIRSTTERM">block</i>, and the pipe will not
           behave as expected.
             <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">cat file1 file2 | ls -l | sort
  # The output from "cat file1 file2" disappears.</pre></font></td></tr></tbody></table>
               </p><p>A pipe runs as a <a href="#CHILDREF">child
           process</a>, and therefore cannot alter script
           variables.
             <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">variable="initial_value"
  echo "new_value" | read variable
  echo "variable = $variable"     # variable = initial_value</pre></font></td></tr></tbody></table>
               </p><p>If one of the commands in the pipe
           aborts, this prematurely terminates execution of the
           pipe. Called a <i class="FIRSTTERM">broken pipe</i>, this
           condition sends a <tt class="REPLACEABLE"><i>SIGPIPE</i></tt> <a href="#SIGNALD">signal</a>.</p></td></tr></tbody></table></div></dd><dt><span class="TOKEN">&gt;|</span></dt><dd><div class="FORMALPARA"><p><b>force redirection (even if
      the <a href="#NOCLOBBERREF">noclobber option</a>
      is set). </b>This will forcibly overwrite an existing file.</p></div></dd><dt><span class="TOKEN">||</span></dt><dd><div class="FORMALPARA"><p><b><a href="#ORREF">OR logical operator</a>. </b>In a <a href="#TESTCONSTRUCTS1">test
      construct</a>, the <span class="TOKEN">||</span> operator causes
      a return of <span class="RETURNVALUE">0</span> (success) if
      <em>either</em> of the linked test conditions
      is true.</p></div></dd><dt><a name="BGJOB"></a><span class="TOKEN">&amp;</span></dt><dd><div class="FORMALPARA"><p><b>Run job in background. </b>A command followed by an <span class="TOKEN">&amp;</span>
            will run in the background.</p></div><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>sleep 10 &amp;</b></tt>
  <tt class="COMPUTEROUTPUT">[1] 850</tt>
  <tt class="COMPUTEROUTPUT">[1]+  Done                    sleep 10</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>Within a script, commands and even <a href="#FORLOOPREF1">loops</a> may run in the
          background.</p><p><a name="BGLOOP0"></a></p><div class="EXAMPLE"><a name="BGLOOP"></a><p><b>Example 3-3. Running a loop in the background</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # background-loop.sh
  
  for i in 1 2 3 4 5 6 7 8 9 10            # First loop.
  do
    echo -n "$i "
  done &amp; # Run this loop in background.
         # Will sometimes execute after second loop.
  
  echo   # This 'echo' sometimes will not display.
  
  for i in 11 12 13 14 15 16 17 18 19 20   # Second loop.
  do
    echo -n "$i "
  done  
  
  echo   # This 'echo' sometimes will not display.
  
  # ======================================================
  
  # The expected output from the script:
  # 1 2 3 4 5 6 7 8 9 10 
  # 11 12 13 14 15 16 17 18 19 20 
  
  # Sometimes, though, you get:
  # 11 12 13 14 15 16 17 18 19 20 
  # 1 2 3 4 5 6 7 8 9 10 bozo $
  # (The second 'echo' doesn't execute. Why?)
  
  # Occasionally also:
  # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
  # (The first 'echo' doesn't execute. Why?)
  
  # Very rarely something like:
  # 11 12 13 1 2 3 4 5 6 7 8 9 10 14 15 16 17 18 19 20 
  # The foreground loop preempts the background one.
  
  exit 0
  
  #  Nasimuddin Ansari suggests adding    sleep 1
  #+ after the   echo -n "$i"   in lines 6 and 14,
  #+ for some real fun.</pre></font></td></tr></tbody></table></div><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>A command run in the background within a
          script may cause the script to hang, waiting
          for a keystroke. Fortunately, there is a <a href="#WAITHANG">remedy</a> for this.</p></td></tr></tbody></table></div></dd><dt><a name="LOGICALAND"></a><span class="TOKEN">&amp;&amp;</span></dt><dd><div class="FORMALPARA"><p><b><a href="#LOGOPS1">AND logical
        operator</a>. </b>In a <a href="#TESTCONSTRUCTS1">test
      construct</a>, the <span class="TOKEN">&amp;&amp;</span> operator causes
      a return of <span class="RETURNVALUE">0</span> (success) only if
      <em>both</em> the linked test conditions
      are true.</p></div></dd><dt><a name="DASHREF"></a><span class="TOKEN">-</span></dt><dd><div class="FORMALPARA"><p><b>option, prefix. </b>Option flag for a command or filter. Prefix for
      an operator. Prefix for a <a href="#DEFPARAM1">default parameter</a>
      in <a href="#PARAMSUBREF">parameter
      substitution</a>.</p></div><p><tt class="USERINPUT"><b>COMMAND -[Option1][Option2][...]</b></tt></p><p><tt class="USERINPUT"><b>ls -al</b></tt></p><p><tt class="USERINPUT"><b>sort -dfu $filename</b></tt></p><p>	      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">if [ $file1 -ot $file2 ]
  then #      ^
    echo "File $file1 is older than $file2."
  fi
  
  if [ "$a" -eq "$b" ]
  then #    ^
    echo "$a is equal to $b."
  fi
  
  if [ "$c" -eq 24 -a "$d" -eq 47 ]
  then #    ^              ^
    echo "$c equals 24 and $d equals 47."
  fi
  
  
  param2=${param1:-$DEFAULTVAL}
  #               ^</pre></font></td></tr></tbody></table>  
          </p><p><a name="DOUBLEDASHREF"></a></p><p><b class="COMMAND">--</b></p><p>The <i class="FIRSTTERM">double-dash</i>
      <tt class="OPTION">--</tt> prefixes <i class="FIRSTTERM">long</i>
      (verbatim) options to commands.</p><p><tt class="USERINPUT"><b>sort --ignore-leading-blanks</b></tt></p><p>Used with a <a href="#BUILTINREF">Bash
            builtin</a>, it means the <i class="FIRSTTERM">end of
      options</i> to that particular command.</p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>This provides a handy means of removing
        files whose <em>names begin with a dash</em>.
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -l</b></tt>
  <tt class="COMPUTEROUTPUT">-rw-r--r-- 1 bozo bozo 0 Nov 25 12:29 -badname</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>rm -- -badname</b></tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -l</b></tt>
  <tt class="COMPUTEROUTPUT">total 0</tt></pre></font></td></tr></tbody></table>
        </p></td></tr></tbody></table></div><p>The <i class="FIRSTTERM">double-dash</i> is also used in
            conjunction with <a href="#SETREF">set</a>.</p><p><tt class="USERINPUT"><b>set -- $variable</b></tt> (as in <a href="#SETPOS">Example 15-18</a>)</p></dd><dt><a name="DASHREF2"></a><span class="TOKEN">-</span></dt><dd><div class="FORMALPARA"><p><b>redirection from/to <tt class="FILENAME">stdin</tt> or <tt class="FILENAME">stdout</tt> [dash]. </b><a name="COXEX"></a></p></div><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cat -</b></tt>
  <tt class="USERINPUT"><b>abc</b></tt>
  <tt class="COMPUTEROUTPUT">abc</tt>
  
  <tt class="COMPUTEROUTPUT">...</tt>
  
  <tt class="USERINPUT"><b>Ctl-D</b></tt></pre></font></td></tr></tbody></table>
        </p><p>As expected, <tt class="USERINPUT"><b>cat -</b></tt> echoes
        <tt class="FILENAME">stdin</tt>, in this case keyboarded user input,
        to <tt class="FILENAME">stdout</tt>. But, does I/O redirection using
        <b class="COMMAND">-</b> have real-world applications?</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)
  # Move entire file tree from one directory to another
  # [courtesy Alan Cox &lt;a.cox@swansea.ac.uk&gt;, with a minor change]
  
  # 1) cd /source/directory
  #    Source directory, where the files to be moved are.
  # 2) &amp;&amp;
  #   "And-list": if the 'cd' operation successful,
  #    then execute the next command.
  # 3) tar cf - .
  #    The 'c' option 'tar' archiving command creates a new archive,
  #    the 'f' (file) option, followed by '-' designates the target file
  #    as stdout, and do it in current directory tree ('.').
  # 4) |
  #    Piped to ...
  # 5) ( ... )
  #    a subshell
  # 6) cd /dest/directory
  #    Change to the destination directory.
  # 7) &amp;&amp;
  #   "And-list", as above
  # 8) tar xpvf -
  #    Unarchive ('x'), preserve ownership and file permissions ('p'),
  #    and send verbose messages to stdout ('v'),
  #    reading data from stdin ('f' followed by '-').
  #
  #    Note that 'x' is a command, and 'p', 'v', 'f' are options.
  #
  # Whew!
  
  
  
  # More elegant than, but equivalent to:
  #   cd source/directory
  #   tar cf - . | (cd ../dest/directory; tar xpvf -)
  #
  #     Also having same effect:
  # cp -a /source/directory/* /dest/directory
  #     Or:
  # cp -a /source/directory/* /source/directory/.[^.]* /dest/directory
  #     If there are hidden files in /source/directory.</pre></font></td></tr></tbody></table></p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">bunzip2 -c linux-2.6.16.tar.bz2 | tar xvf -
  #  --uncompress tar file--      | --then pass it to "tar"--
  #  If "tar" has not been patched to handle "bunzip2",
  #+ this needs to be done in two discrete steps, using a pipe.
  #  The purpose of the exercise is to unarchive "bzipped" kernel source.</pre></font></td></tr></tbody></table></p><p>Note that in this context the <span class="QUOTE">"-"</span> is not
              itself a Bash operator, but rather an option recognized by
        certain UNIX utilities that write to
        <tt class="FILENAME">stdout</tt>, such as <b class="COMMAND">tar</b>,
        <b class="COMMAND">cat</b>, etc.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo "whatever" | cat -</b></tt>
  <tt class="COMPUTEROUTPUT">whatever</tt> </pre></font></td></tr></tbody></table>
        </p><p>Where a filename is expected,
          <tt class="REPLACEABLE"><i>-</i></tt> redirects output to
          <tt class="FILENAME">stdout</tt> (sometimes seen with
          <tt class="USERINPUT"><b>tar cf</b></tt>), or accepts input from
          <tt class="FILENAME">stdin</tt>, rather than from a file.
          <a name="FILTERDASH"></a>
          This is a method of using a file-oriented utility as a
          filter in a pipe.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>file</b></tt>
  <tt class="COMPUTEROUTPUT">Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...</tt>
          </pre></font></td></tr></tbody></table>
  
        By itself on the command-line, <a href="#FILEREF">file</a> fails with an error message.
        </p><p>	    Add a <span class="QUOTE">"-"</span> for a more useful result. This causes the
          shell to await user input.
  
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>file -</b></tt>
  <tt class="USERINPUT"><b>abc</b></tt>
  <tt class="COMPUTEROUTPUT">standard input:              ASCII text</tt>
  
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>file -</b></tt>
  <tt class="USERINPUT"><b>#!/bin/bash</b></tt>
  <tt class="COMPUTEROUTPUT">standard input:              Bourne-Again shell script text executable</tt>
          </pre></font></td></tr></tbody></table>
  
          Now the command accepts input from <tt class="FILENAME">stdin</tt>
            and analyzes it.
        </p><p>The <span class="QUOTE">"-"</span> can be used to pipe
          <tt class="FILENAME">stdout</tt> to other commands. This permits
          such stunts as <a href="#PREPENDREF">prepending lines
          to a file</a>.</p><p>Using <a href="#DIFFREF">diff</a> to
          compare a file with a <em>section</em>
          of another:</p><p><tt class="USERINPUT"><b>grep Linux file1 | diff file2 -</b></tt></p><p>Finally, a real-world example using
          <tt class="REPLACEABLE"><i>-</i></tt> with <a href="#TARREF">tar</a>.</p><div class="EXAMPLE"><a name="EX58"></a><p><b>Example 3-4. Backup of all files changed in last day</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  #  Backs up all files in current directory modified within last 24 hours
  #+ in a "tarball" (tarred and gzipped file).
  
  BACKUPFILE=backup-$(date +%m-%d-%Y)
  #                 Embeds date in backup filename.
  #                 Thanks, Joshua Tschida, for the idea.
  archive=${1:-$BACKUPFILE}
  #  If no backup-archive filename specified on command-line,
  #+ it will default to "backup-MM-DD-YYYY.tar.gz."
  
  tar cvf - `find . -mtime -1 -type f -print` &gt; $archive.tar
  gzip $archive.tar
  echo "Directory $PWD backed up in archive file \"$archive.tar.gz\"."
  
  
  #  Stephane Chazelas points out that the above code will fail
  #+ if there are too many files found
  #+ or if any filenames contain blank characters.
  
  # He suggests the following alternatives:
  # -------------------------------------------------------------------
  #   find . -mtime -1 -type f -print0 | xargs -0 tar rvf "$archive.tar"
  #      using the GNU version of "find".
  
  
  #   find . -mtime -1 -type f -exec tar rvf "$archive.tar" '{}' \;
  #         portable to other UNIX flavors, but much slower.
  # -------------------------------------------------------------------
  
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>Filenames beginning with
          <span class="QUOTE">"-"</span> may cause problems when coupled with the
          <span class="QUOTE">"-"</span> redirection operator. A script should
          check for this and add an appropriate prefix to such
          filenames, for example <tt class="FILENAME">./-FILENAME</tt>,
          <tt class="FILENAME">$PWD/-FILENAME</tt>, or
          <tt class="FILENAME">$PATHNAME/-FILENAME</tt>.</p><p>If the value of a variable begins with a
            <tt class="REPLACEABLE"><i>-</i></tt>, this may likewise create
      problems.
      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">var="-n"
  echo $var		
  # Has the effect of "echo -n", and outputs nothing.</pre></font></td></tr></tbody></table>
                </p></td></tr></tbody></table></div></dd><dt><span class="TOKEN">-</span></dt><dd><div class="FORMALPARA"><p><b>previous working directory. </b>A <b class="COMMAND">cd -</b> command changes to the
      previous working directory. This uses the
      <a href="#OLDPWD">$OLDPWD</a> <a href="#ENVREF">environmental variable</a>.</p></div><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>Do not confuse the <span class="QUOTE">"-"</span> used in this
      sense with the <span class="QUOTE">"-"</span> redirection
      operator just discussed. The interpretation of the
      <span class="QUOTE">"-"</span> depends on the context in which it
      appears.</p></td></tr></tbody></table></div></dd><dt><span class="TOKEN">-</span></dt><dd><div class="FORMALPARA"><p><b>Minus. </b>Minus sign in an <a href="#AROPS1">arithmetic
            operation</a>.</p></div></dd><dt><span class="TOKEN">=</span></dt><dd><div class="FORMALPARA"><p><b>Equals. </b><a href="#EQREF">Assignment operator</a>
            <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">a=28
  echo $a   # 28</pre></font></td></tr></tbody></table></p></div><p>In a <a href="#EQUALSIGNREF">different context</a>,
          the <span class="QUOTE">"<span class="TOKEN">=</span>"</span> is a <a href="#SCOMPARISON1">string comparison</a>
          operator.</p></dd><dt><span class="TOKEN">+</span></dt><dd><div class="FORMALPARA"><p><b>Plus. </b>Addition  <a href="#AROPS1">arithmetic
            operator</a>.</p></div><p>In a <a href="#PLUSREF">different context</a>,
          the <span class="TOKEN">+</span> is a <a href="#REGEXP">Regular
          Expression</a> operator.</p></dd><dt><span class="TOKEN">+</span></dt><dd><div class="FORMALPARA"><p><b>Option. </b>Option flag for a command or filter.</p></div><p>Certain commands and <a href="#BUILTINREF">builtins</a> use the
          <tt class="OPTION">+</tt> to enable certain options and the
          <tt class="OPTION">-</tt> to disable them. In <a href="#PARAMSUBREF">parameter substitution</a>,
          the <tt class="OPTION">+</tt> prefixes an <a href="#PARAMALTV">	      alternate value</a> that a variable expands to.</p></dd><dt><a name="MODULO00"></a><span class="TOKEN">%</span></dt><dd><div class="FORMALPARA"><p><b><a href="#MODULOREF">modulo</a>. </b>Modulo (remainder of a division) <a href="#AROPS1">arithmetic
            operation</a>.</p></div><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">let "z = 5 % 3"
  echo $z  # 2</pre></font></td></tr></tbody></table></p><p>In a <a href="#PCTPATREF">different context</a>,
          the <span class="TOKEN">%</span> is a <a href="#PSUB2">pattern
          matching</a> operator.</p></dd><dt><a name="TILDEREF"></a><span class="TOKEN">~</span></dt><dd><div class="FORMALPARA"><p><b>home directory [tilde]. </b>This corresponds to the <a href="#HOMEDIRREF">$HOME</a> internal variable.
  
          <tt class="FILENAME">~bozo</tt> is bozo's home directory,
      and <b class="COMMAND">ls ~bozo</b> lists the contents of it.
      <span class="TOKEN">~/</span> is the current user's home directory,
      and <b class="COMMAND">ls ~/</b> lists the contents of it.
  
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo ~bozo</b></tt>
  <tt class="COMPUTEROUTPUT">/home/bozo</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo ~</b></tt>
  <tt class="COMPUTEROUTPUT">/home/bozo</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo ~/</b></tt>
  <tt class="COMPUTEROUTPUT">/home/bozo/</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo ~:</b></tt>
  <tt class="COMPUTEROUTPUT">/home/bozo:</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo ~nonexistent-user</b></tt>
  <tt class="COMPUTEROUTPUT">~nonexistent-user</tt>
          </pre></font></td></tr></tbody></table>
          </p></div></dd><dt><a name="WORKINGDIRREF"></a><span class="TOKEN">~+</span></dt><dd><div class="FORMALPARA"><p><b>current working directory. </b>This corresponds to the <a href="#PWDREF">$PWD</a> internal variable.</p></div></dd><dt><a name="PREVWORKINGDIR"></a><span class="TOKEN">~-</span></dt><dd><div class="FORMALPARA"><p><b>previous working directory. </b>This corresponds to the <a href="#OLDPWD">$OLDPWD</a> internal variable.</p></div></dd><dt><span class="TOKEN">=~</span></dt><dd><div class="FORMALPARA"><p><b><a href="#REGEXMATCHREF">regular
      expression match</a>. </b>This operator was introduced with <a href="#BASH3REF">version 3</a> of Bash.</p></div></dd><dt><a name="BEGLINEREF"></a><span class="TOKEN">^</span></dt><dd><div class="FORMALPARA"><p><b>beginning-of-line. </b>In a <a href="#REGEXREF">regular expression</a>, a
      <span class="QUOTE">"^"</span> addresses the <a href="#CARETREF">beginning of a line</a> of text.</p></div></dd><dt><span class="TOKEN">^</span>, <span class="TOKEN">^^</span></dt><dd><div class="FORMALPARA"><p><b><a href="#CASEMODPARAMSUB">Uppercase
              conversion</a> in <i class="FIRSTTERM">parameter substitution</i>
              (added in <a href="#BASH4REF">version 4</a> of Bash). </b></p></div></dd><dt><a name="CONTROLCHARREF"></a>Control Characters</dt><dd><div class="FORMALPARA"><p><b> change the behavior of the
            terminal or text display. </b>A control character is a <b class="KEYCAP">CONTROL</b>
          + <b class="KEYCAP">key</b> combination (pressed
          simultaneously).
          
          A control character may also
          be written in <i class="FIRSTTERM">octal</i> or
          <i class="FIRSTTERM">hexadecimal</i> notation,
          following an <i class="FIRSTTERM">escape</i>.</p></div><p>Control characters are not normally useful inside a
        script.</p><p></p><ul><li><p><tt class="USERINPUT"><b>Ctl-A</b></tt></p><p>Moves cursor to beginning of line of text
        (on the command-line).</p></li><li><p><tt class="USERINPUT"><b>Ctl-B</b></tt></p><p><tt class="USERINPUT"><b>Backspace</b></tt>
        (nondestructive).</p></li><li><p><a name="CTLCREF"></a></p><p><tt class="USERINPUT"><b>Ctl-C</b></tt></p><p><tt class="USERINPUT"><b>Break</b></tt>.
        Terminate a foreground job.</p></li><li><p><a name="CTLDREF"></a></p><p><tt class="USERINPUT"><b>Ctl-D</b></tt></p><p><i class="FIRSTTERM">Log out</i> from a shell (similar to
        <a href="#EXITCOMMANDREF">exit</a>).</p><p><tt class="USERINPUT"><b>EOF</b></tt> (end-of-file). This also
        terminates input from <tt class="FILENAME">stdin</tt>.</p><p>When typing text on the console or in an
                    <i class="FIRSTTERM">xterm</i> window,
        <tt class="USERINPUT"><b>Ctl-D</b></tt> erases the character under the
        cursor. When there are no characters present,
        <tt class="USERINPUT"><b>Ctl-D</b></tt> logs out of the session, as
        expected. In an <i class="FIRSTTERM">xterm</i> window,
        this has the effect of closing the window.</p></li><li><p><tt class="USERINPUT"><b>Ctl-E</b></tt></p><p>Moves cursor to end of line of text
        (on the command-line).</p></li><li><p><tt class="USERINPUT"><b>Ctl-F</b></tt></p><p>Moves cursor forward one character position
        (on the command-line).</p></li><li><p><a name="CTLGREF"></a></p><p><tt class="USERINPUT"><b>Ctl-G</b></tt></p><p><tt class="USERINPUT"><b>BEL</b></tt>. On some
      old-time teletype terminals, this would actually ring
      a bell. In an <i class="FIRSTTERM">xterm</i> it might
      beep.</p></li><li><p><a name="CTLHREF"></a></p><p><tt class="USERINPUT"><b>Ctl-H</b></tt></p><p><tt class="USERINPUT"><b>Rubout</b></tt> (destructive backspace).
        Erases characters the cursor backs over while
        backspacing.</p><p>		<table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Embedding Ctl-H in a string.
  
  a="^H^H"                  # Two Ctl-H's -- backspaces
                            # ctl-V ctl-H, using vi/vim
  echo "abcdef"             # abcdef
  echo
  echo -n "abcdef$a "       # abcd f
  #  Space at end  ^              ^  Backspaces twice.
  echo
  echo -n "abcdef$a"        # abcdef
  #  No space at end               ^ Doesn't backspace (why?).
                            # Results may not be quite as expected.
  echo; echo
  
  # Constantin Hagemeier suggests trying:
  # a=$'\010\010'
  # a=$'\b\b'
  # a=$'\x08\x08'
  # But, this does not change the results.
  
  ########################################
  
  # Now, try this.
  
  rubout="^H^H^H^H^H"       # 5 x Ctl-H.
  
  echo -n "12345678"
  sleep 2
  echo -n "$rubout"
  sleep 2</pre></font></td></tr></tbody></table>
                  </p></li><li><p><tt class="USERINPUT"><b>Ctl-I</b></tt></p><p><tt class="USERINPUT"><b>Horizontal tab</b></tt>.</p></li><li><p><a name="CTLJREF"></a></p><p><tt class="USERINPUT"><b>Ctl-J</b></tt></p><p><tt class="USERINPUT"><b>Newline</b></tt> (line feed).
        In a script, may also be expressed in octal notation --
        '\012' or in hexadecimal -- '\x0a'.</p></li><li><p><tt class="USERINPUT"><b>Ctl-K</b></tt></p><p><tt class="USERINPUT"><b>Vertical tab</b></tt>.</p><p>When typing text on the console or in an
                    <i class="FIRSTTERM">xterm</i> window,
        <tt class="USERINPUT"><b>Ctl-K</b></tt> erases from the character
        under the cursor to end of line. Within a script,
        <tt class="USERINPUT"><b>Ctl-K</b></tt> may behave differently,
        as in Lee Lee Maschmeyer's example, below.</p></li><li><p><tt class="USERINPUT"><b>Ctl-L</b></tt></p><p><tt class="USERINPUT"><b>Formfeed</b></tt> (clear the terminal
        screen). In a terminal, this has the same effect as the
        <a href="#CLEARREF">clear</a> command. When sent
        to a printer, a <tt class="USERINPUT"><b>Ctl-L</b></tt> causes
        an advance to end of the paper sheet.</p></li><li><p><a name="CTLMREF"></a></p><p><tt class="USERINPUT"><b>Ctl-M</b></tt></p><p><tt class="USERINPUT"><b>Carriage return</b></tt>.</p><p>		<table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Thank you, Lee Maschmeyer, for this example.
  
  read -n 1 -s -p \
  $'Control-M leaves cursor at beginning of this line. Press Enter. \x0d'
             # Of course, '0d' is the hex equivalent of Control-M.
  echo &gt;&amp;2   #  The '-s' makes anything typed silent,
             #+ so it is necessary to go to new line explicitly.
  
  read -n 1 -s -p $'Control-J leaves cursor on next line. \x0a'
             #  '0a' is the hex equivalent of Control-J, linefeed.
  echo &gt;&amp;2
  
  ###
  
  read -n 1 -s -p $'And Control-K\x0bgoes straight down.'
  echo &gt;&amp;2   #  Control-K is vertical tab.
  
  # A better example of the effect of a vertical tab is:
  
  var=$'\x0aThis is the bottom line\x0bThis is the top line\x0a'
  echo "$var"
  #  This works the same way as the above example. However:
  echo "$var" | col
  #  This causes the right end of the line to be higher than the left end.
  #  It also explains why we started and ended with a line feed --
  #+ to avoid a garbled screen.
  
  # As Lee Maschmeyer explains:
  # --------------------------
  #  In the [first vertical tab example] . . . the vertical tab
  #+ makes the printing go straight down without a carriage return.
  #  This is true only on devices, such as the Linux console,
  #+ that can't go "backward."
  #  The real purpose of VT is to go straight UP, not down.
  #  It can be used to print superscripts on a printer.
  #  The col utility can be used to emulate the proper behavior of VT.
  
  exit 0</pre></font></td></tr></tbody></table>
      </p></li><li><p><tt class="USERINPUT"><b>Ctl-N</b></tt></p><p>Erases a line of text recalled from
        <i class="FIRSTTERM">history buffer</i>
          <a name="AEN2107" href="#FTN.AEN2107"><span class="footnote">[23]</span></a> (on the
          command-line).</p></li><li><p><tt class="USERINPUT"><b>Ctl-O</b></tt></p><p>Issues a <i class="FIRSTTERM">newline</i>
        (on the command-line).</p></li><li><p><tt class="USERINPUT"><b>Ctl-P</b></tt></p><p>Recalls last command from <i class="FIRSTTERM">history
        buffer</i> (on the command-line).</p></li><li><p><tt class="USERINPUT"><b>Ctl-Q</b></tt></p><p>Resume (<tt class="USERINPUT"><b>XON</b></tt>).</p><p>This resumes <tt class="FILENAME">stdin</tt> in a terminal.</p></li><li><p><tt class="USERINPUT"><b>Ctl-R</b></tt></p><p>Backwards search for text in <i class="FIRSTTERM">history
        buffer</i>
        (on the command-line).</p></li><li><p><tt class="USERINPUT"><b>Ctl-S</b></tt></p><p>Suspend (<tt class="USERINPUT"><b>XOFF</b></tt>).</p><p>This freezes <tt class="FILENAME">stdin</tt> in a terminal.
        (Use Ctl-Q to restore input.)</p></li><li><p><tt class="USERINPUT"><b>Ctl-T</b></tt></p><p>Reverses the position of the character the cursor
        is on with the previous character (on the
        command-line).</p></li><li><p><tt class="USERINPUT"><b>Ctl-U</b></tt></p><p>Erase a line of input, from the cursor backward to
        beginning of line. In some settings,
        <tt class="USERINPUT"><b>Ctl-U</b></tt> erases the entire
        line of input, <em>regardless of cursor
        position</em>.</p></li><li><p><tt class="USERINPUT"><b>Ctl-V</b></tt></p><p>When inputting text, <tt class="USERINPUT"><b>Ctl-V</b></tt>
        permits inserting control characters. For example, the
        following two are equivalent:
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo -e '\x0a'
  echo &lt;Ctl-V&gt;&lt;Ctl-J&gt;</pre></font></td></tr></tbody></table></p><p><tt class="USERINPUT"><b>Ctl-V</b></tt> is primarily useful from
      within a text editor.</p></li><li><p><tt class="USERINPUT"><b>Ctl-W</b></tt></p><p>When typing text on the console or in an xterm window,
        <tt class="USERINPUT"><b>Ctl-W</b></tt> erases from the character
        under the cursor backwards to the first instance of
        <a href="#WHITESPACEREF">whitespace</a>. In
        some settings, <tt class="USERINPUT"><b>Ctl-W</b></tt> erases
        backwards to first non-alphanumeric character.</p></li><li><p><tt class="USERINPUT"><b>Ctl-X</b></tt></p><p>In certain word processing programs,
        <i class="FIRSTTERM">Cuts</i> highlighted text
        and copies to <i class="FIRSTTERM">clipboard</i>.</p></li><li><p><tt class="USERINPUT"><b>Ctl-Y</b></tt></p><p><i class="FIRSTTERM">Pastes</i> back text previously
        erased (with <tt class="USERINPUT"><b>Ctl-U</b></tt> or
        <tt class="USERINPUT"><b>Ctl-W</b></tt>).</p></li><li><p><tt class="USERINPUT"><b>Ctl-Z</b></tt></p><p><i class="FIRSTTERM">Pauses</i> a foreground job.</p><p><i class="FIRSTTERM">Substitute</i> operation in certain
        word processing applications.</p><p><tt class="USERINPUT"><b>EOF</b></tt> (end-of-file) character
        in the MSDOS filesystem.</p></li></ul></dd><dt><a name="WHITESPACEREF"></a>Whitespace</dt><dd><div class="FORMALPARA"><p><b>functions as a separator between commands and/or
                variables. </b>Whitespace consists of either
      <i class="FIRSTTERM">spaces</i>,
      <i class="FIRSTTERM">tabs</i>, <i class="FIRSTTERM">blank
      lines</i>, or any combination thereof.
  
        <a name="AEN2198" href="#FTN.AEN2198"><span class="footnote">[24]</span></a>
  
      In some contexts, such as <a href="#WSBAD">variable
      assignment</a>, whitespace is not permitted, and
      results in a syntax error.</p></div><p>Blank lines have no effect on the action of a script,
        and are therefore useful for visually separating functional
        sections.</p><p><a href="#IFSREF">$IFS</a>, the special variable
        separating <i class="FIRSTTERM">fields</i> of input to certain
        commands. It defaults to whitespace.</p><table class="SIDEBAR" border="1" cellpadding="5"><tbody><tr><td><div class="SIDEBAR"><a name="AEN2207"></a><p></p><p>	      <a name="FIELDREF"></a><tt class="USERINPUT"><b>Definition:</b></tt>
          A <i class="FIRSTTERM">field</i> is a discrete chunk of data
          expressed as a string of consecutive characters.
          Separating each field from adjacent fields is either
          <i class="FIRSTTERM">whitespace</i> or some other designated
          character (often determined by the <span class="TOKEN">$IFS</span>).
          In some contexts, a field may be called a
          <i class="FIRSTTERM">record</i>.
          </p><p></p></div></td></tr></tbody></table><p><a name="QUOTINGWS"></a></p><p>To preserve <i class="FIRSTTERM">whitespace</i>
      within a string or in a variable, use <a href="#QUOTINGREF">quoting</a>.</p><p>UNIX <a href="#FILTERDEF">filters</a>
        can target and operate on <i class="FIRSTTERM">whitespace</i>
        using the <a href="#POSIXREF">POSIX</a> character class
        <a href="#WSPOSIX">[:space:]</a>.</p></dd></dl></div></div><div class="CHAPTER"><hr><h1><a name="VARIABLES"></a>Chapter 4. Introduction to Variables and Parameters</h1><p><i class="FIRSTTERM">Variables</i> are how programming and
    scripting languages represent data. A variable is nothing
    more than a <i class="FIRSTTERM">label</i>, a name assigned to a
    location or set of locations in computer memory holding an item
    of data.</p><p>Variables appear in arithmetic operations and manipulation of
    quantities, and in string parsing.</p><div class="SECT1"><hr><h1 class="SECT1"><a name="VARSUBN"></a>4.1. Variable Substitution</h1><p>The <i class="FIRSTTERM">name</i> of a variable is a placeholder
    for its <i class="FIRSTTERM">value</i>, the data it holds.
    Referencing (retrieving) its value is called
    <i class="FIRSTTERM">variable substitution</i>.</p><p></p><div class="VARIABLELIST"><dl><dt><span class="TOKEN">$</span></dt><dd><p><a name="VARNAMEVAL"></a></p><p>Let us carefully distinguish between the
      <i class="FIRSTTERM">name</i> of a variable
      and its <i class="FIRSTTERM">value</i>. If
      <tt class="USERINPUT"><b>variable1</b></tt> is the name of a
      variable, then <tt class="USERINPUT"><b>$variable1</b></tt>
      is a reference to its <i class="FIRSTTERM">value</i>,
      the data item it contains.
      
        <a name="AEN2258" href="#FTN.AEN2258"><span class="footnote">[25]</span></a>
  
  
      </p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>variable1=23</b></tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo variable1</b></tt>
  <tt class="COMPUTEROUTPUT">variable1</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $variable1</b></tt>
  <tt class="COMPUTEROUTPUT">23</tt></pre></font></td></tr></tbody></table>	      
          </p><p>The only times a variable appears <span class="QUOTE">"naked"</span>
      -- without the <span class="TOKEN">$</span> prefix	-- is when
      declared or assigned, when <i class="FIRSTTERM">unset</i>,
      when <a href="#EXPORTREF">exported</a>,
      in an arithmetic expression within <a href="#DBLPARENS">double parentheses 
                  (( ... ))</a>, or in the special case of a variable
                  representing a <a href="#SIGNALD">signal</a>
                  (see <a href="#EX76">Example 32-5</a>). Assignment may be with an
                  <span class="TOKEN">=</span> (as in <tt class="PARAMETER"><i>var1=27</i></tt>),
                  in a <a href="#READREF">read</a> statement,
                  and at the head of a loop (<tt class="PARAMETER"><i>for var2 in 1
                  2 3</i></tt>).</p><p><a name="DBLQUO"></a>Enclosing a referenced value in
          <i class="FIRSTTERM">double quotes</i> (<span class="TOKEN">" ... "</span>)
          does not interfere with variable substitution. This is
          called <i class="FIRSTTERM">partial quoting</i>, sometimes
          referred to as <span class="QUOTE">"weak quoting."</span> <a name="SNGLQUO"></a>Using single quotes (<span class="TOKEN">' ... '</span>)
          causes the variable name to be used literally, and no
          substitution will take place. This is <i class="FIRSTTERM">full
          quoting</i>, sometimes referred to as 'strong
          quoting.' See <a href="#QUOTING">Chapter 5</a> for a
          detailed discussion.</p><p>Note that <tt class="USERINPUT"><b>$variable</b></tt> is actually a
          simplified form of
          <tt class="USERINPUT"><b>${variable}</b></tt>. In contexts
          where the <tt class="USERINPUT"><b>$variable</b></tt> syntax
          causes an error, the longer form may work (see <a href="#PARAMETER-SUBSTITUTION">Section 10.2</a>, below).</p><p><a name="VARUNSETTING"></a></p><div class="EXAMPLE"><a name="EX9"></a><p><b>Example 4-1. Variable assignment and substitution</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # ex9.sh
  
  # Variables: assignment and substitution
  
  a=375
  hello=$a
  #   ^ ^
  
  #-------------------------------------------------------------------------
  # No space permitted on either side of = sign when initializing variables.
  # What happens if there is a space?
  
  #  "VARIABLE =value"
  #           ^
  #% Script tries to run "VARIABLE" command with one argument, "=value".
  
  #  "VARIABLE= value"
  #            ^
  #% Script tries to run "value" command with
  #+ the environmental variable "VARIABLE" set to "".
  #-------------------------------------------------------------------------
  
  
  echo hello    # hello
  # Not a variable reference, just the string "hello" ...
  
  echo $hello   # 375
  #    ^          This *is* a variable reference.
  echo ${hello} # 375
  #               Likewise a variable reference, as above.
  
  # Quoting . . .
  echo "$hello"    # 375
  echo "${hello}"  # 375
  
  echo
  
  hello="A B  C   D"
  echo $hello   # A B C D
  echo "$hello" # A B  C   D
  # As we see, echo $hello   and   echo "$hello"   give different results.
  # =======================================
  # Quoting a variable preserves whitespace.
  # =======================================
  
  echo
  
  echo '$hello'  # $hello
  #    ^      ^
  #  Variable referencing disabled (escaped) by single quotes,
  #+ which causes the "$" to be interpreted literally.
  
  # Notice the effect of different types of quoting.
  
  
  hello=    # Setting it to a null value.
  echo "\$hello (null value) = $hello"      # $hello (null value) =
  #  Note that setting a variable to a null value is not the same as
  #+ unsetting it, although the end result is the same (see below).
  
  # --------------------------------------------------------------
  
  #  It is permissible to set multiple variables on the same line,
  #+ if separated by white space.
  #  Caution, this may reduce legibility, and may not be portable.
  
  var1=21  var2=22  var3=$V3
  echo
  echo "var1=$var1   var2=$var2   var3=$var3"
  
  # May cause problems with legacy versions of "sh" . . .
  
  # --------------------------------------------------------------
  
  echo; echo
  
  numbers="one two three"
  #           ^   ^
  other_numbers="1 2 3"
  #               ^ ^
  #  If there is whitespace embedded within a variable,
  #+ then quotes are necessary.
  #  other_numbers=1 2 3                  # Gives an error message.
  echo "numbers = $numbers"
  echo "other_numbers = $other_numbers"   # other_numbers = 1 2 3
  #  Escaping the whitespace also works.
  mixed_bag=2\ ---\ Whatever
  #           ^    ^ Space after escape (\).
  
  echo "$mixed_bag"         # 2 --- Whatever
  
  echo; echo
  
  echo "uninitialized_variable = $uninitialized_variable"
  # Uninitialized variable has null value (no value at all!).
  uninitialized_variable=   #  Declaring, but not initializing it --
                            #+ same as setting it to a null value, as above.
  echo "uninitialized_variable = $uninitialized_variable"
                            # It still has a null value.
  
  uninitialized_variable=23       # Set it.
  unset uninitialized_variable    # Unset it.
  echo "uninitialized_variable = $uninitialized_variable"
                                  # uninitialized_variable =
                                  # It still has a null value.
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p><a name="UNINITVAR1"></a></p><p>An uninitialized variable has a
          <span class="QUOTE">"null"</span> value -- no assigned value at all
          (<em>not</em> zero!).
  
                <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">if [ -z "$unassigned" ]
  then
    echo "\$unassigned is NULL."
  fi     # $unassigned is NULL.</pre></font></td></tr></tbody></table></p><p>Using a variable before
          assigning a value to it may cause problems.
          It is nevertheless possible to perform arithmetic operations
          on an uninitialized variable.
  
            <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo "$uninitialized"                                # (blank line)
  let "uninitialized += 5"                             # Add 5 to it.
  echo "$uninitialized"                                # 5
  
  #  Conclusion:
  #  An uninitialized variable has no value,
  #+ however it evaluates as 0 in an arithmetic operation.</pre></font></td></tr></tbody></table>
  
                See also <a href="#SELFSOURCE">Example 15-23</a>.</p></td></tr></tbody></table></div></dd></dl></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="VARASSIGNMENT"></a>4.2. Variable Assignment</h1><p></p><div class="VARIABLELIST"><dl><dt><a name="EQREF"></a><span class="TOKEN">=</span></dt><dd><p>the assignment operator (<em>no space before
        and after</em>)</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>Do not confuse this with <a href="#EQUALSIGNREF">=</a> and
          <a href="#EQUALREF">-eq</a>, which
          <a href="#IFTHEN">test</a>,
          rather than assign!</p><p>Note that <span class="TOKEN">=</span> can be either
          an <i class="FIRSTTERM">assignment</i> or a
          <i class="FIRSTTERM">test</i> operator, depending on
          context.</p></td></tr></tbody></table></div><p><a name="EX15_0"></a></p><div class="EXAMPLE"><a name="EX15"></a><p><b>Example 4-2. Plain Variable Assignment</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Naked variables
  
  echo
  
  # When is a variable "naked", i.e., lacking the '$' in front?
  # When it is being assigned, rather than referenced.
  
  # Assignment
  a=879
  echo "The value of \"a\" is $a."
  
  # Assignment using 'let'
  let a=16+5
  echo "The value of \"a\" is now $a."
  
  echo
  
  # In a 'for' loop (really, a type of disguised assignment):
  echo -n "Values of \"a\" in the loop are: "
  for a in 7 8 9 11
  do
    echo -n "$a "
  done
  
  echo
  echo
  
  # In a 'read' statement (also a type of assignment):
  echo -n "Enter \"a\" "
  read a
  echo "The value of \"a\" is now $a."
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="EX16_0"></a></p><div class="EXAMPLE"><a name="EX16"></a><p><b>Example 4-3. Variable Assignment, plain and fancy</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  a=23              # Simple case
  echo $a
  b=$a
  echo $b
  
  # Now, getting a little bit fancier (command substitution).
  
  a=`echo Hello!`   # Assigns result of 'echo' command to 'a' ...
  echo $a
  #  Note that including an exclamation mark (!) within a
  #+ command substitution construct will not work from the command-line,
  #+ since this triggers the Bash "history mechanism."
  #  Inside a script, however, the history functions are disabled by default.
  
  a=`ls -l`         # Assigns result of 'ls -l' command to 'a'
  echo $a           # Unquoted, however, it removes tabs and newlines.
  echo
  echo "$a"         # The quoted variable preserves whitespace.
                    # (See the chapter on "Quoting.")
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="COMMANDSUBREF0"></a></p><p>Variable assignment using the <i class="FIRSTTERM">$(...)</i>
          mechanism (a newer method than <a href="#BACKQUOTESREF">backquotes</a>). This is
          likewise a form of <a href="#COMMANDSUBREF">command
          substitution</a>.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># From /etc/rc.d/rc.local
  R=$(cat /etc/redhat-release)
  arch=$(uname -m)</pre></font></td></tr></tbody></table></p></dd></dl></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="UNTYPED"></a>4.3. Bash Variables Are Untyped</h1><p><a name="BVUNTYPED"></a></p><p>Unlike many other programming languages, Bash does not segregate
    its variables by <span class="QUOTE">"type."</span> Essentially, <em>Bash
    variables are character strings</em>, but, depending on
    context, Bash permits arithmetic operations and comparisons on
    variables. The determining factor is whether the value of a
    variable contains only digits.</p><div class="EXAMPLE"><a name="INTORSTRING"></a><p><b>Example 4-4. Integer or string?</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # int-or-string.sh
  
  a=2334                   # Integer.
  let "a += 1"
  echo "a = $a "           # a = 2335
  echo                     # Integer, still.
  
  
  b=${a/23/BB}             # Substitute "BB" for "23".
                           # This transforms $b into a string.
  echo "b = $b"            # b = BB35
  declare -i b             # Declaring it an integer doesn't help.
  echo "b = $b"            # b = BB35
  
  let "b += 1"             # BB35 + 1
  echo "b = $b"            # b = 1
  echo                     # Bash sets the "integer value" of a string to 0.
  
  c=BB34
  echo "c = $c"            # c = BB34
  d=${c/BB/23}             # Substitute "23" for "BB".
                           # This makes $d an integer.
  echo "d = $d"            # d = 2334
  let "d += 1"             # 2334 + 1
  echo "d = $d"            # d = 2335
  echo
  
  
  # What about null variables?
  e=''                     # ... Or e="" ... Or e=
  echo "e = $e"            # e =
  let "e += 1"             # Arithmetic operations allowed on a null variable?
  echo "e = $e"            # e = 1
  echo                     # Null variable transformed into an integer.
  
  # What about undeclared variables?
  echo "f = $f"            # f =
  let "f += 1"             # Arithmetic operations allowed?
  echo "f = $f"            # f = 1
  echo                     # Undeclared variable transformed into an integer.
  #
  # However ...
  let "f /= $undecl_var"   # Divide by zero?
  #   let: f /= : syntax error: operand expected (error token is " ")
  # Syntax error! Variable $undecl_var is not set to zero here!
  #
  # But still ...
  let "f /= 0"
  #   let: f /= 0: division by 0 (error token is "0")
  # Expected behavior.
  
  
  #  Bash (usually) sets the "integer value" of null to zero
  #+ when performing an arithmetic operation.
  #  But, don't try this at home, folks!
  #  It's undocumented and probably non-portable behavior.
  
  
  # Conclusion: Variables in Bash are untyped,
  #+ with all attendant consequences.
  
  exit $?</pre></font></td></tr></tbody></table></div><p>Untyped variables are both a blessing and a curse. They permit
    more flexibility in scripting and make it easier to grind out
    lines of code (and give you enough rope to hang yourself!).
    However, they likewise permit subtle errors to creep in
    and encourage sloppy programming habits.</p><p>To lighten the burden of keeping track of variable
          types in a script, Bash <em>does</em> permit
    <a href="#DECLAREREF">declaring</a> variables.</p></div><div class="SECT1"><hr><h1 class="SECT1"><a name="OTHERTYPESV"></a>4.4. Special Variable Types</h1><p></p><div class="VARIABLELIST"><dl><dt><tt class="REPLACEABLE"><i>Local variables</i></tt></dt><dd><p>Variables <a href="#SCOPEREF">visible</a> only within a <a href="#CODEBLOCKREF">code block</a> or function (see
        also <a href="#LOCALREF">local variables</a> in
        <a href="#FUNCTIONREF">functions</a>)</p></dd><dt><a name="ENVREF"></a><tt class="REPLACEABLE"><i>Environmental variables</i></tt></dt><dd><p>Variables that affect the behavior of the shell and
          user interface</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>In a more general context, each <a href="#PROCESSREF">process</a> has an
      <span class="QUOTE">"environment"</span>, that is, a group of
      variables that the process may reference. In this sense,
      the shell behaves like any other process.</p><p>Every time a shell starts, it creates shell variables that
      correspond to its own environmental variables. Updating
      or adding new environmental variables causes the
      shell to update its environment, and all the shell's
      <i class="FIRSTTERM">child processes</i> (the commands it
      executes) inherit this environment.</p></td></tr></tbody></table></div><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>The space allotted to the environment is limited.
            Creating too many environmental variables or ones that use up
      excessive space may cause problems.</p><p>	          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>eval "`seq 10000 | sed -e 's/.*/export var&amp;=ZZZZZZZZZZZZZZ/'`"</b></tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>du</b></tt>
  <tt class="COMPUTEROUTPUT">bash: /usr/bin/du: Argument list too long</tt>
              </pre></font></td></tr></tbody></table>
          </p><p>Note: this <span class="QUOTE">"error"</span> has been fixed, as of
            kernel version 2.6.23.</p><p>(Thank you, StÃ©phane Chazelas for the clarification,
            and for providing the above example.)</p></td></tr></tbody></table></div><p>If a script sets environmental variables, they need to be
          <span class="QUOTE">"exported,"</span> that is, reported to the
          <i class="FIRSTTERM">environment</i> local to
          the script. This is the function of the <a href="#EXPORTREF">export</a> command.</p><a name="CHILDREF"></a><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>A script can <b class="COMMAND">export</b> variables only
          to child <a href="#PROCESSREF">processes</a>,
          that is, only to commands or processes which that
          particular script initiates. A script invoked from
          the command-line <tt class="REPLACEABLE"><i>cannot</i></tt>
          export variables back to the command-line environment.
          <em><a href="#FORKREF">Child processes</a>
          cannot export variables back to the parent processes that
          spawned them.</em></p><p><a name="CHILDREF2"></a><tt class="USERINPUT"><b>Definition:</b></tt>
          A <i class="FIRSTTERM">child process</i> is a
          subprocess launched by another process, its <a href="#PARENTREF">parent</a>.</p></td></tr></tbody></table></div></dd><dt><a name="POSPARAMREF1"></a><tt class="REPLACEABLE"><i>Positional parameters</i></tt></dt><dd><p>Arguments passed to the script from the command
          line
      <a name="AEN2450" href="#FTN.AEN2450"><span class="footnote">[26]</span></a>
          : <tt class="VARNAME">$0</tt>, <tt class="VARNAME">$1</tt>,
          <tt class="VARNAME">$2</tt>, <tt class="VARNAME">$3</tt> . . .</p><p><a name="SCRNAMEPARAM"></a><tt class="VARNAME">$0</tt> is
           the name of the script itself,
          <tt class="VARNAME">$1</tt> is the first argument,
          <tt class="VARNAME">$2</tt> the second, <tt class="VARNAME">$3</tt>
          the third, and so forth.
  
          <a name="AEN2464" href="#FTN.AEN2464"><span class="footnote">[27]</span></a>
  
          <a name="BRACKETNOTATION"></a>
          After <tt class="VARNAME">$9</tt>, the arguments must be enclosed
          in brackets, for example, <tt class="VARNAME">${10}</tt>,
          <tt class="VARNAME">${11}</tt>, <tt class="VARNAME">${12}</tt>.</p><p>The special variables <a href="#APPREF">$* and $@</a>
          denote <em>all</em> the positional parameters.</p><div class="EXAMPLE"><a name="EX17"></a><p><b>Example 4-5. Positional Parameters</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  # Call this script with at least 10 parameters, for example
  # ./scriptname 1 2 3 4 5 6 7 8 9 10
  MINPARAMS=10
  
  echo
  
  echo "The name of this script is \"$0\"."
  # Adds ./ for current directory
  echo "The name of this script is \"`basename $0`\"."
  # Strips out path name info (see 'basename')
  
  echo
  
  if [ -n "$1" ]              # Tested variable is quoted.
  then
   echo "Parameter #1 is $1"  # Need quotes to escape #
  fi 
  
  if [ -n "$2" ]
  then
   echo "Parameter #2 is $2"
  fi 
  
  if [ -n "$3" ]
  then
   echo "Parameter #3 is $3"
  fi 
  
  # ...
  
  
  if [ -n "${10}" ]  # Parameters &gt; $9 must be enclosed in {brackets}.
  then
   echo "Parameter #10 is ${10}"
  fi 
  
  echo "-----------------------------------"
  echo "All the command-line parameters are: "$*""
  
  if [ $# -lt "$MINPARAMS" ]
  then
    echo
    echo "This script needs at least $MINPARAMS command-line arguments!"
  fi  
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div><p><i class="FIRSTTERM">Bracket notation</i> for positional
          parameters leads to a fairly simple way of referencing
          the <em>last</em> argument passed to a
          script on the command-line. This also requires <a href="#VARREFNEW">indirect referencing</a>.</p><p><a name="LASTARGREF"></a></p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">args=$#           # Number of args passed.
  lastarg=${!args}
  # Note: This is an *indirect reference* to $args ...
  
  
  # Or:       lastarg=${!#}             (Thanks, Chris Monson.)
  # This is an *indirect reference* to the $# variable.
  # Note that lastarg=${!$#} doesn't work.</pre></font></td></tr></tbody></table></p><p>Some scripts can perform different operations,
          depending on which name they are invoked with. For this
          to work, the script needs to check <tt class="VARNAME">$0</tt>,
          the name it was invoked by.
  
          <a name="AEN2501" href="#FTN.AEN2501"><span class="footnote">[28]</span></a>
          
          There must also exist symbolic links to all the alternate
          names of the script. See <a href="#HELLOL">Example 16-2</a>.</p><p><a name="NULLVAR"></a></p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>If a script expects a command-line parameter
          but is invoked without one, this may cause a <i class="FIRSTTERM">null
          variable assignment</i>, generally an undesirable
          result. One way to prevent this is to append an extra
          character to both sides of the assignment statement using
          the expected positional parameter.  </p></td></tr></tbody></table></div><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">variable1_=$1_  # Rather than variable1=$1
  # This will prevent an error, even if positional parameter is absent.
  
  critical_argument01=$variable1_
  
  # The extra character can be stripped off later, like so.
  variable1=${variable1_/_/}
  # Side effects only if $variable1_ begins with an underscore.
  # This uses one of the parameter substitution templates discussed later.
  # (Leaving out the replacement pattern results in a deletion.)
  
  #  A more straightforward way of dealing with this is
  #+ to simply test whether expected positional parameters have been passed.
  if [ -z $1 ]
  then
    exit $E_MISSING_POS_PARAM
  fi
  
  
  #  However, as Fabian Kreutz points out,
  #+ the above method may have unexpected side-effects.
  #  A better method is parameter substitution:
  #         ${1:-$DefaultVal}
  #  See the "Parameter Substition" section
  #+ in the "Variables Revisited" chapter.</pre></font></td></tr></tbody></table><p>---</p><div class="EXAMPLE"><a name="EX18"></a><p><b>Example 4-6. <i class="FIRSTTERM">wh</i>, <i class="FIRSTTERM">                whois</i> domain name lookup</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # ex18.sh
  
  # Does a 'whois domain-name' lookup on any of 3 alternate servers:
  #                    ripe.net, cw.net, radb.net
  
  # Place this script -- renamed 'wh' -- in /usr/local/bin
  
  # Requires symbolic links:
  # ln -s /usr/local/bin/wh /usr/local/bin/wh-ripe
  # ln -s /usr/local/bin/wh /usr/local/bin/wh-apnic
  # ln -s /usr/local/bin/wh /usr/local/bin/wh-tucows
  
  E_NOARGS=75
  
  
  if [ -z "$1" ]
  then
    echo "Usage: `basename $0` [domain-name]"
    exit $E_NOARGS
  fi
  
  # Check script name and call proper server.
  case `basename $0` in    # Or:    case ${0##*/} in
      "wh"       ) whois $1@whois.tucows.com;;
      "wh-ripe"  ) whois $1@whois.ripe.net;;
      "wh-apnic" ) whois $1@whois.apnic.net;;
      "wh-cw"    ) whois $1@whois.cw.net;;
      *          ) echo "Usage: `basename $0` [domain-name]";;
  esac 
  
  exit $?</pre></font></td></tr></tbody></table></div><p>---</p><p><a name="SHIFTREF"></a></p><p>	      
          
          The <b class="COMMAND">shift</b> command reassigns the positional
          parameters, in effect shifting them to the left one notch.</p><p><tt class="VARNAME">$1</tt> &lt;--- <tt class="VARNAME">$2</tt>, <tt class="VARNAME">$2</tt> &lt;--- <tt class="VARNAME">$3</tt>, <tt class="VARNAME">$3</tt> &lt;--- <tt class="VARNAME">$4</tt>, etc.</p><p>The old <tt class="VARNAME">$1</tt> disappears, but
          <em><tt class="VARNAME">$0</tt> (the script name)
          does not change</em>. If you use a large number of
          positional parameters to a script, <b class="COMMAND">shift</b>
          lets you access those past <tt class="LITERAL">10</tt>, although
          <a href="#BRACKETNOTATION">{bracket} notation</a>
          also permits this.</p><div class="EXAMPLE"><a name="EX19"></a><p><b>Example 4-7. Using <i class="FIRSTTERM">shift</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # shft.sh: Using 'shift' to step through all the positional parameters.
  
  #  Name this script something like shft.sh,
  #+ and invoke it with some parameters.
  #+ For example:
  #             sh shft.sh a b c def 83 barndoor
  
  until [ -z "$1" ]  # Until all parameters used up . . .
  do
    echo -n "$1 "
    shift
  done
  
  echo               # Extra linefeed.
  
  # But, what happens to the "used-up" parameters?
  echo "$2"
  #  Nothing echoes!
  #  When $2 shifts into $1 (and there is no $3 to shift into $2)
  #+ then $2 remains empty.
  #  So, it is not a parameter *copy*, but a *move*.
  
  exit
  
  #  See also the echo-params.sh script for a "shiftless"
  #+ alternative method of stepping through the positional params.</pre></font></td></tr></tbody></table></div><p>The <b class="COMMAND">shift</b> command can take a numerical
        parameter indicating how many positions to shift.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # shift-past.sh
  
  shift 3    # Shift 3 positions.
  #  n=3; shift $n
  #  Has the same effect.
  
  echo "$1"
  
  exit 0
  
  # ======================== #
  
  
  $ sh shift-past.sh 1 2 3 4 5
  4
  
  #  However, as Eleni Fragkiadaki, points out,
  #+ attempting a 'shift' past the number of
  #+ positional parameters ($#) returns an exit status of 1,
  #+ and the positional parameters themselves do not change.
  #  This means possibly getting stuck in an endless loop. . . .
  #  For example:
  #      until [ -z "$1" ]
  #      do
  #         echo -n "$1 "
  #         shift 20    #  If less than 20 pos params,
  #      done           #+ then loop never ends!
  #
  # When in doubt, add a sanity check. . . .
  #           shift 20 || break
  #                    ^^^^^^^^</pre></font></td></tr></tbody></table></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">shift</b> command works in a similar
        fashion on parameters passed to a <a href="#FUNCTIONREF">function</a>.  See <a href="#MULTIPLICATION">Example 36-18</a>.</p></td></tr></tbody></table></div></dd></dl></div></div></div><div class="CHAPTER"><hr><h1><a name="QUOTING"></a>Chapter 5. Quoting</h1><p><a name="QUOTINGREF"></a></p><p>Quoting means just that, bracketing a string in quotes. This
    has the effect of protecting <a href="#SCHARLIST1">special
    characters</a> in the string from reinterpretation
    or expansion by the shell or shell script. (A character
    is <span class="QUOTE">"special"</span> if it has an interpretation
    other than its literal meaning. For example, the <a href="#ASTERISKREF">asterisk *</a> represents
    a <i class="FIRSTTERM">wild card</i> character in 
    <a href="#GLOBBINGREF">globbing</a> and <a href="#REGEXREF">Regular Expressions</a>).</p><p>	      <table border="1" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -l [Vv]*</b></tt>
  <tt class="COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo       324 Apr  2 15:05 VIEWDATA.BAT
   -rw-rw-r--    1 bozo  bozo       507 May  4 14:25 vartrace.sh
   -rw-rw-r--    1 bozo  bozo       539 Apr 14 17:11 viewdata.sh</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -l '[Vv]*'</b></tt>
  <tt class="COMPUTEROUTPUT">ls: [Vv]*: No such file or directory</tt></pre></font></td></tr></tbody></table>	      
          </p><p><a name="QUOTINGDEF"></a></p><table class="SIDEBAR" border="1" cellpadding="5"><tbody><tr><td><div class="SIDEBAR"><a name="AEN2596"></a><p></p><p>In everyday speech or writing, when we
        <span class="QUOTE">"quote"</span> a phrase, we set it apart and give it special
        meaning. In a Bash script, when we <i class="FIRSTTERM">quote</i> a
        string, we set it apart and protect its <i class="FIRSTTERM">literal</i>
        meaning.</p><p></p></div></td></tr></tbody></table><p>Certain programs and utilities reinterpret or expand
    special characters in a quoted string. An important use of
    quoting is protecting a command-line parameter from the shell,
    but still letting the calling program expand it.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>grep '[Ff]irst' *.txt</b></tt>
  <tt class="COMPUTEROUTPUT">file1.txt:This is the first line of file1.txt.
   file2.txt:This is the First line of file2.txt.</tt></pre></font></td></tr></tbody></table>
          </p><p>Note that the unquoted <tt class="USERINPUT"><b>grep [Ff]irst *.txt</b></tt>
      works under the Bash shell.
        <a name="AEN2609" href="#FTN.AEN2609"><span class="footnote">[29]</span></a>
      </p><p>Quoting can also suppress <a href="#ECHOREF">echo's</a>
          <span class="QUOTE">"appetite"</span> for newlines.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $(ls -l)</b></tt>
  <tt class="COMPUTEROUTPUT">total 8 -rw-rw-r-- 1 bo bo 13 Aug 21 12:57 t.sh -rw-rw-r-- 1 bo bo 78 Aug 21 12:57 u.sh</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo "$(ls -l)"</b></tt>
  <tt class="COMPUTEROUTPUT">total 8
   -rw-rw-r--  1 bo bo  13 Aug 21 12:57 t.sh
   -rw-rw-r--  1 bo bo  78 Aug 21 12:57 u.sh</tt></pre></font></td></tr></tbody></table>
          </p><div class="SECT1"><hr><h1 class="SECT1"><a name="QUOTINGVAR"></a>5.1. Quoting Variables</h1><p>When referencing a variable, it is generally advisable to
    enclose its name in double quotes.
    This prevents reinterpretation of all special characters within
    the quoted string -- except <span class="TOKEN">$</span>, <span class="TOKEN">`</span>
    (backquote), and <span class="TOKEN">\</span> (escape).
  
        <a name="AEN2630" href="#FTN.AEN2630"><span class="footnote">[30]</span></a>
    
    Keeping <span class="TOKEN">$</span> as a special character within
    double quotes permits referencing a quoted variable
    (<tt class="REPLACEABLE"><i>"$variable"</i></tt>), that is, replacing the
    variable with its value (see <a href="#EX9">Example 4-1</a>, above).</p><p><a name="WSQUO"></a></p><p>Use double quotes to prevent word splitting.
  
          <a name="AEN2688" href="#FTN.AEN2688"><span class="footnote">[31]</span></a>
  
    An argument enclosed in double quotes presents
    itself as a single word, even if it contains <a href="#WHITESPACEREF">whitespace</a> separators.</p><p><a name="VARSPLITTING"></a></p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">List="one two three"
  
  for a in $List     # Splits the variable in parts at whitespace.
  do
    echo "$a"
  done
  # one
  # two
  # three
  
  echo "---"
  
  for a in "$List"   # Preserves whitespace in a single variable.
  do #     ^     ^
    echo "$a"
  done
  # one two three</pre></font></td></tr></tbody></table></p><p>A more elaborate example:</p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">variable1="a variable containing five words"
  COMMAND This is $variable1    # Executes COMMAND with 7 arguments:
  # "This" "is" "a" "variable" "containing" "five" "words"
  
  COMMAND "This is $variable1"  # Executes COMMAND with 1 argument:
  # "This is a variable containing five words"
  
  
  variable2=""    # Empty.
  
  COMMAND $variable2 $variable2 $variable2
                  # Executes COMMAND with no arguments. 
  COMMAND "$variable2" "$variable2" "$variable2"
                  # Executes COMMAND with 3 empty arguments. 
  COMMAND "$variable2 $variable2 $variable2"
                  # Executes COMMAND with 1 argument (2 spaces). 
  
  # Thanks, StÃ©phane Chazelas.</pre></font></td></tr></tbody></table></p><div class="TIP"><p></p><table class="TIP" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>Enclosing the arguments to an <b class="COMMAND">echo</b>
    statement in double quotes is necessary only when word splitting
    or preservation of <a href="#WHITESPACEREF">whitespace</a>
    is an issue.</p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="WEIRDVARS"></a><p><b>Example 5-1. Echoing Weird Variables</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # weirdvars.sh: Echoing weird variables.
  
  echo
  
  var="'(]\\{}\$\""
  echo $var        # '(]\{}$"
  echo "$var"      # '(]\{}$"     Doesn't make a difference.
  
  echo
  
  IFS='\'
  echo $var        # '(] {}$"     \ converted to space. Why?
  echo "$var"      # '(]\{}$"
  
  # Examples above supplied by Stephane Chazelas.
  
  echo
  
  var2="\\\\\""
  echo $var2       #   "
  echo "$var2"     # \\"
  echo
  # But ... var2="\\\\"" is illegal. Why?
  var3='\\\\'
  echo "$var3"     # \\\\
  # Strong quoting works, though.
  
  
  # ************************************************************ #
  # As the first example above shows, nesting quotes is permitted.
  
  echo "$(echo '"')"           # "
  #    ^           ^
  
  
  # At times this comes in useful.
  
  var1="Two bits"
  echo "\$var1 = "$var1""      # $var1 = Two bits
  #    ^                ^
  
  # Or, as Chris Hiestand points out ...
  
  if [[ "$(du "$My_File1")" -gt "$(du "$My_File2")" ]]
  #     ^     ^         ^ ^     ^     ^         ^ ^
  then
    ...
  fi
  # ************************************************************ #</pre></font></td></tr></tbody></table></div><p>Single quotes (<span class="TOKEN">' '</span>) operate similarly to double
    quotes, but do not permit referencing variables, since
    the special meaning of <span class="TOKEN">$</span> is turned off.
    Within single quotes, <em>every</em> special
    character except <span class="TOKEN">'</span> gets interpreted literally.
    Consider single quotes (<span class="QUOTE">"full quoting"</span>) to be a
    stricter method of quoting than double quotes (<span class="QUOTE">"partial
    quoting"</span>).</p><div class="NOTE"><p></p><table class="NOTE" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>Since even the escape character (<span class="TOKEN">\</span>)
    gets a literal interpretation within single quotes, trying to
    enclose a single quote within single quotes will not yield the
    expected result.
    <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo "Why can't I write 's between single quotes"
  
  echo
  
  # The roundabout method.
  echo 'Why can'\''t I write '"'"'s between single quotes'
  #    |-------|  |----------|   |-----------------------|
  # Three single-quoted strings, with escaped and quoted single quotes between.
  
  # This example courtesy of StÃ©phane Chazelas.</pre></font></td></tr></tbody></table>
        </p></td></tr></tbody></table></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="ESCAPINGSECTION"></a>5.2. Escaping</h1><p><a name="ESCP"></a><i class="FIRSTTERM">Escaping</i> is a method
    of quoting single characters. The <span class="TOKEN">escape</span>
    (<span class="TOKEN">\</span>) preceding a character tells the shell to
    interpret that character literally.</p><div class="CAUTION"><p></p><table class="CAUTION" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>With certain commands and utilities, such as <a href="#ECHOREF">echo</a> and <a href="#SEDREF">sed</a>, escaping a character may have the
    opposite effect - it can toggle on a special meaning for that
    character.</p></td></tr></tbody></table></div><p></p><div class="VARIABLELIST"><p><b><a name="SPM"></a>Special meanings of certain
    escaped characters</b></p><dl><dt>used with <b class="COMMAND">echo</b> and
    <b class="COMMAND">sed</b></dt><dd><p></p></dd><dt><span class="TOKEN">\n</span></dt><dd><p>means newline</p></dd><dt><span class="TOKEN">\r</span></dt><dd><p>means return</p></dd><dt><span class="TOKEN">\t</span></dt><dd><p>means tab</p></dd><dt><span class="TOKEN">\v</span></dt><dd><p> means vertical tab</p></dd><dt><span class="TOKEN">\b</span></dt><dd><p>means backspace</p></dd><dt><span class="TOKEN">\a</span></dt><dd><p>means <i class="FIRSTTERM">alert</i> (beep or flash)</p></dd><dt><span class="TOKEN">\0xx</span></dt><dd><p><a name="OCTALREF"></a>translates to the
                octal <a href="#ASCIIDEF">ASCII</a>
                equivalent of <tt class="REPLACEABLE"><i>0nn</i></tt>, where
                <tt class="REPLACEABLE"><i>nn</i></tt> is a string of digits</p><div class="IMPORTANT"><p></p><table class="IMPORTANT" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/important.gif" hspace="5" alt="Important"></td><td align="LEFT" valign="TOP"><p><a name="STRQ"></a></p><p>The <tt class="USERINPUT"><b>$' ... '</b></tt>
               <a href="#QUOTINGREF">quoted</a> string-expansion
                construct is a mechanism that uses escaped octal or hex values
          to assign ASCII characters to variables, e.g.,
          <b class="COMMAND">quote=$'\042'</b>.</p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="ESCAPED"></a><p><b>Example 5-2. Escaped Characters</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # escaped.sh: escaped characters
  
  #############################################################
  ### First, let's show some basic escaped-character usage. ###
  #############################################################
  
  # Escaping a newline.
  # ------------------
  
  echo ""
  
  echo "This will print
  as two lines."
  # This will print
  # as two lines.
  
  echo "This will print \
  as one line."
  # This will print as one line.
  
  echo; echo
  
  echo "============="
  
  
  echo "\v\v\v\v"      # Prints \v\v\v\v literally.
  # Use the -e option with 'echo' to print escaped characters.
  echo "============="
  echo "VERTICAL TABS"
  echo -e "\v\v\v\v"   # Prints 4 vertical tabs.
  echo "=============="
  
  echo "QUOTATION MARK"
  echo -e "\042"       # Prints " (quote, octal ASCII character 42).
  echo "=============="
  
  
  
  # The $'\X' construct makes the -e option unnecessary.
  
  echo; echo "NEWLINE and (maybe) BEEP"
  echo $'\n'           # Newline.
  echo $'\a'           # Alert (beep).
                       # May only flash, not beep, depending on terminal.
  
  # We have seen $'\nnn" string expansion, and now . . .
  
  # =================================================================== #
  # Version 2 of Bash introduced the $'\nnn' string expansion construct.
  # =================================================================== #
  
  echo "Introducing the \$\' ... \' string-expansion construct . . . "
  echo ". . . featuring more quotation marks."
  
  echo $'\t \042 \t'   # Quote (") framed by tabs.
  # Note that  '\nnn' is an octal value.
  
  # It also works with hexadecimal values, in an $'\xhhh' construct.
  echo $'\t \x22 \t'  # Quote (") framed by tabs.
  # Thank you, Greg Keraunen, for pointing this out.
  # Earlier Bash versions allowed '\x022'.
  
  echo
  
  
  # Assigning ASCII characters to a variable.
  # ----------------------------------------
  quote=$'\042'        # " assigned to a variable.
  echo "$quote Quoted string $quote and this lies outside the quotes."
  
  echo
  
  # Concatenating ASCII chars in a variable.
  triple_underline=$'\137\137\137'  # 137 is octal ASCII code for '_'.
  echo "$triple_underline UNDERLINE $triple_underline"
  
  echo
  
  ABC=$'\101\102\103\010'           # 101, 102, 103 are octal A, B, C.
  echo $ABC
  
  echo
  
  escape=$'\033'                    # 033 is octal for escape.
  echo "\"escape\" echoes as $escape"
  #                                   no visible output.
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div><p>A more elaborate example:</p><div class="EXAMPLE"><a name="BASHEK"></a><p><b>Example 5-3. Detecting key-presses</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Author: Sigurd Solaas, 20 Apr 2011
  # Used in ABS Guide with permission.
  # Requires version 4.2+ of Bash.
  
  key="no value yet"
  while true; do
    clear
    echo "Bash Extra Keys Demo. Keys to try:"
    echo
    echo "* Insert, Delete, Home, End, Page_Up and Page_Down"
    echo "* The four arrow keys"
    echo "* Tab, enter, escape, and space key"
    echo "* The letter and number keys, etc."
    echo
    echo "    d = show date/time"
    echo "    q = quit"
    echo "================================"
    echo
  
   # Convert the separate home-key to home-key_num_7:
   if [ "$key" = $'\x1b\x4f\x48' ]; then
    key=$'\x1b\x5b\x31\x7e'
    #   Quoted string-expansion construct. 
   fi
  
   # Convert the separate end-key to end-key_num_1.
   if [ "$key" = $'\x1b\x4f\x46' ]; then
    key=$'\x1b\x5b\x34\x7e'
   fi
  
   case "$key" in
    $'\x1b\x5b\x32\x7e')  # Insert
     echo Insert Key
    ;;
    $'\x1b\x5b\x33\x7e')  # Delete
     echo Delete Key
    ;;
    $'\x1b\x5b\x31\x7e')  # Home_key_num_7
     echo Home Key
    ;;
    $'\x1b\x5b\x34\x7e')  # End_key_num_1
     echo End Key
    ;;
    $'\x1b\x5b\x35\x7e')  # Page_Up
     echo Page_Up
    ;;
    $'\x1b\x5b\x36\x7e')  # Page_Down
     echo Page_Down
    ;;
    $'\x1b\x5b\x41')  # Up_arrow
     echo Up arrow
    ;;
    $'\x1b\x5b\x42')  # Down_arrow
     echo Down arrow
    ;;
    $'\x1b\x5b\x43')  # Right_arrow
     echo Right arrow
    ;;
    $'\x1b\x5b\x44')  # Left_arrow
     echo Left arrow
    ;;
    $'\x09')  # Tab
     echo Tab Key
    ;;
    $'\x0a')  # Enter
     echo Enter Key
    ;;
    $'\x1b')  # Escape
     echo Escape Key
    ;;
    $'\x20')  # Space
     echo Space Key
    ;;
    d)
     date
    ;;
    q)
    echo Time to quit...
    echo
    exit 0
    ;;
    *)
     echo You pressed: \'"$key"\'
    ;;
   esac
  
   echo
   echo "================================"
  
   unset K1 K2 K3
   read -s -N1 -p "Press a key: "
   K1="$REPLY"
   read -s -N2 -t 0.001
   K2="$REPLY"
   read -s -N1 -t 0.001
   K3="$REPLY"
   key="$K1$K2$K3"
  
  done
  
  exit $?</pre></font></td></tr></tbody></table></div><p>See also <a href="#EX77">Example 37-1</a>.</p></dd><dt><span class="TOKEN">\"</span></dt><dd><p> gives the quote its literal meaning</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo "Hello"                     # Hello
  echo "\"Hello\" ... he said."    # "Hello" ... he said.</pre></font></td></tr></tbody></table></p></dd><dt><span class="TOKEN">\$</span></dt><dd><p>gives the dollar sign its literal meaning
          (variable name following <span class="TOKEN">\$</span> will not be
          referenced)</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo "\$variable01"           # $variable01
  echo "The book cost \$7.98."  # The book cost $7.98.</pre></font></td></tr></tbody></table></p></dd><dt><span class="TOKEN">\\</span></dt><dd><p>gives the backslash its literal meaning</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo "\\"  # Results in \
  
  # Whereas . . .
  
  echo "\"   # Invokes secondary prompt from the command-line.
             # In a script, gives an error message.
  
  # However . . .
  
  echo '\'   # Results in \</pre></font></td></tr></tbody></table></p></dd></dl></div><div class="NOTE"><p></p><table class="NOTE" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The behavior of <span class="TOKEN">\</span> depends on whether
    it is escaped, <a href="#SNGLQUO">strong-quoted</a>,
    <a href="#DBLQUO">weak-quoted</a>, or appearing within
    <a href="#COMMANDSUBREF">command substitution</a> or a
    <a href="#HEREDOCREF">here document</a>.
  
    <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">                      #  Simple escaping and quoting
  echo \z               #  z
  echo \\z              # \z
  echo '\z'             # \z
  echo '\\z'            # \\z
  echo "\z"             # \z
  echo "\\z"            # \z
  
                        #  Command substitution
  echo `echo \z`        #  z
  echo `echo \\z`       #  z
  echo `echo \\\z`      # \z
  echo `echo \\\\z`     # \z
  echo `echo \\\\\\z`   # \z
  echo `echo \\\\\\\z`  # \\z
  echo `echo "\z"`      # \z
  echo `echo "\\z"`     # \z
  
                        # Here document
  cat &lt;&lt;EOF              
  \z                      
  EOF                   # \z
  
  cat &lt;&lt;EOF              
  \\z                     
  EOF                   # \z
  
  # These examples supplied by StÃ©phane Chazelas.</pre></font></td></tr></tbody></table>
        </p><p>Elements of a string assigned to a variable may be escaped, but
          the escape character alone may not be assigned to a variable.
    <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">variable=\
  echo "$variable"
  # Will not work - gives an error message:
  # test.sh: : command not found
  # A "naked" escape cannot safely be assigned to a variable.
  #
  #  What actually happens here is that the "\" escapes the newline and
  #+ the effect is        variable=echo "$variable"
  #+                      invalid variable assignment
  
  variable=\
  23skidoo
  echo "$variable"        #  23skidoo
                          #  This works, since the second line
                          #+ is a valid variable assignment.
  
  variable=\ 
  #        \^    escape followed by space
  echo "$variable"        # space
  
  variable=\\
  echo "$variable"        # \
  
  variable=\\\
  echo "$variable"
  # Will not work - gives an error message:
  # test.sh: \: command not found
  #
  #  First escape escapes second one, but the third one is left "naked",
  #+ with same result as first instance, above.
  
  variable=\\\\
  echo "$variable"        # \\
                          # Second and fourth escapes escaped.
                          # This is o.k.</pre></font></td></tr></tbody></table>
        </p></td></tr></tbody></table></div><p>Escaping a space can prevent word splitting in a command's argument list.
          <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">file_list="/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7"
  # List of files as argument(s) to a command.
  
  # Add two files to the list, and list all.
  ls -l /usr/X11R6/bin/xsetroot /sbin/dump $file_list
  
  echo "-------------------------------------------------------------------------"
  
  # What happens if we escape a couple of spaces?
  ls -l /usr/X11R6/bin/xsetroot\ /sbin/dump\ $file_list
  # Error: the first three files concatenated into a single argument to 'ls -l'
  #        because the two escaped spaces prevent argument (word) splitting.</pre></font></td></tr></tbody></table></p><p><a name="ESCNEWLINE"></a></p><p>The <span class="TOKEN">escape</span> also provides a means of writing a
    multi-line command. Normally, each separate line constitutes
    a different command, but an <span class="TOKEN">escape</span> at the end
    of a line <em>escapes the newline character</em>,
    and the command sequence continues on to the next line.</p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">(cd /source/directory &amp;&amp; tar cf - . ) | \
  (cd /dest/directory &amp;&amp; tar xpvf -)
  # Repeating Alan Cox's directory tree copy command,
  # but split into two lines for increased legibility.
  
  # As an alternative:
  tar cf - -C /source/directory . |
  tar xpvf - -C /dest/directory
  # See note below.
  # (Thanks, StÃ©phane Chazelas.)</pre></font></td></tr></tbody></table>
          
    </p><div class="NOTE"><p></p><table class="NOTE" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>If a script line ends with a <span class="TOKEN">|</span>, a pipe
      character, then a <span class="TOKEN">\</span>, an escape, is not strictly
      necessary. It is, however, good programming practice to always
      escape the end of a line of code that continues to the
      following line.</p></td></tr></tbody></table></div><p></p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo "foo
  bar" 
  #foo
  #bar
  
  echo
  
  echo 'foo
  bar'    # No difference yet.
  #foo
  #bar
  
  echo
  
  echo foo\
  bar     # Newline escaped.
  #foobar
  
  echo
  
  echo "foo\
  bar"     # Same here, as \ still interpreted as escape within weak quotes.
  #foobar
  
  echo
  
  echo 'foo\
  bar'     # Escape character \ taken literally because of strong quoting.
  #foo\
  #bar
  
  # Examples suggested by StÃ©phane Chazelas.</pre></font></td></tr></tbody></table></p></div></div><div class="CHAPTER"><hr><h1><a name="EXIT-STATUS"></a>Chapter 6. Exit and Exit Status</h1><table border="0" width="100%" cellspacing="0" cellpadding="0" class="EPIGRAPH"><tbody><tr><td width="45%">&nbsp;</td><td width="45%" align="LEFT" valign="TOP"><i><p><i>... there are dark corners in the Bourne shell, and people use all
        of them.</i></p><p><i>--Chet Ramey</i></p></i></td></tr></tbody></table><p><a name="EXITCOMMANDREF"></a>The 
    <b class="COMMAND">	  
      
      exit
    </b> 
    command terminates a script, just as in a <b class="COMMAND">C</b>
    program. It can also return a value, which is available to the
    script's parent process.</p><p><a name="EXITSTATUSREF"></a>Every command returns an 
    <i class="FIRSTTERM">	  
      exit status
    </i> 
    (sometimes referred to as a 
    <i class="FIRSTTERM">	  
      return status
    </i> or <i class="FIRSTTERM">exit code</i>).
    <a name="EXITSUCCESS"></a>
    A successful command returns a <span class="RETURNVALUE">0</span>, while
    an unsuccessful one returns a <span class="RETURNVALUE">non-zero</span>
    value that usually can be interpreted as an <i class="FIRSTTERM">error
    code</i>. Well-behaved UNIX commands, programs, and
    utilities return a <span class="RETURNVALUE">0</span> exit code upon
    successful completion, though there are some exceptions.</p><p><a name="FUNCTXSTR"></a></p><p>Likewise, <a href="#FUNCTIONREF">functions</a>
    within a script and the script itself return an exit
    status. The last command executed in the function or
    script determines the exit status. Within a script, an
    <tt class="USERINPUT"><b>exit <tt class="REPLACEABLE"><i>nnn</i></tt></b></tt>
    command may be used to deliver an
    <span class="RETURNVALUE"><tt class="REPLACEABLE"><i>nnn</i></tt></span>
    exit status to the shell
    (<span class="RETURNVALUE"><tt class="REPLACEABLE"><i>nnn</i></tt></span>
    must be an integer in the <span class="RETURNVALUE">0</span> -
    <span class="RETURNVALUE">255</span> range).</p><div class="NOTE"><p></p><table class="NOTE" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>When a script ends with an <b class="COMMAND">exit</b> that has
    no parameter, the exit status of the script is the exit status
    of the last command executed in the script (previous to the
    <b class="COMMAND">exit</b>).</p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  COMMAND_1
  
  . . .
  
  COMMAND_LAST
  
  # Will exit with status of last command.
  
  exit</pre></font></td></tr></tbody></table></p><p>The equivalent of a bare <b class="COMMAND">exit</b> is
          <b class="COMMAND">exit $?</b> or even just omitting the
    <b class="COMMAND">exit</b>.</p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  COMMAND_1
  
  . . .
  
  COMMAND_LAST
  
  # Will exit with status of last command.
  
  exit $?</pre></font></td></tr></tbody></table></p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  COMMAND1
  
  . . . 
  
  COMMAND_LAST
  
  # Will exit with status of last command.</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div><p><a name="EXSREF"></a></p><p>	<tt class="VARNAME">	    $?</tt> reads the exit status of the last
        command executed. After a function returns,
        <tt class="VARNAME">$?</tt> gives the exit status of the last
        command executed in the function. This is Bash's way of giving
        functions a <span class="QUOTE">"return value."</span>
        
          <a name="AEN2981" href="#FTN.AEN2981"><span class="footnote">[32]</span></a>
        </p><p><a name="PIPEEX"></a>Following the execution of a <a href="#PIPEREF">pipe</a>, a <tt class="VARNAME">$?</tt>
          gives the exit status of the last command executed.</p><p>After a script terminates, a <tt class="VARNAME">$?</tt> from the
        command-line gives the exit status of the script, that is, the
        last command executed in the script, which is, by convention,
        <tt class="USERINPUT"><b>0</b></tt> on success or an integer in the
        range <span class="RETURNVALUE">1 - 255</span> on error.</p><div class="EXAMPLE"><a name="EX5"></a><p><b>Example 6-1. exit / exit status</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  echo hello
  echo $?    # Exit status 0 returned because command executed successfully.
  
  lskdf      # Unrecognized command.
  echo $?    # Non-zero exit status returned -- command failed to execute.
  
  echo
  
  exit 113   # Will return 113 to shell.
             # To verify this, type "echo $?" after script terminates.
  
  #  By convention, an 'exit 0' indicates success,
  #+ while a non-zero exit value means an error or anomalous condition.
  #  See the "Exit Codes With Special Meanings" appendix.</pre></font></td></tr></tbody></table></div><p><a href="#XSTATVARREF">$?</a> is especially useful
          for testing the result of a command in a script (see <a href="#FILECOMP">Example 16-35</a> and <a href="#LOOKUP">Example 16-20</a>).</p><div class="NOTE"><p></p><table class="NOTE" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <a href="#NOTREF">!</a>, the <i class="FIRSTTERM">logical
    not</i> qualifier, reverses the outcome of a test or
    command, and this affects its <a href="#EXITSTATUSREF">exit
    status</a>.
  
    </p><div class="EXAMPLE"><a name="NEGCOND"></a><p><b>Example 6-2. Negating a condition using <span class="TOKEN">!</span></b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">true    # The "true" builtin.
  echo "exit status of \"true\" = $?"     # 0
  
  ! true
  echo "exit status of \"! true\" = $?"   # 1
  # Note that the "!" needs a space between it and the command.
  #    !true   leads to a "command not found" error
  #
  # The '!' operator prefixing a command invokes the Bash history mechanism.
  
  true
  !true
  # No error this time, but no negation either.
  # It just repeats the previous command (true).
  
  
  # =========================================================== #
  # Preceding a _pipe_ with ! inverts the exit status returned.
  ls | bogus_command     # bash: bogus_command: command not found
  echo $?                # 127
  
  ! ls | bogus_command   # bash: bogus_command: command not found
  echo $?                # 0
  # Note that the ! does not change the execution of the pipe.
  # Only the exit status changes.
  # =========================================================== #
  
  # Thanks, StÃ©phane Chazelas and Kristopher Newsome.</pre></font></td></tr></tbody></table></div>
  
        <p></p></td></tr></tbody></table></div><div class="CAUTION"><p></p><table class="CAUTION" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>Certain exit status codes have <a href="#EXITCODESREF">reserved meanings</a> and should not
    be user-specified in a script.	</p></td></tr></tbody></table></div></div><div class="CHAPTER"><hr><h1><a name="TESTS"></a>Chapter 7. Tests</h1><p><a name="IFTHEN"></a></p><p>Every reasonably complete programming language can test
      for a condition, then act according to the result of the
      test. Bash has the <a href="#TTESTREF">test</a>
      command, various <a href="#DBLBRACKETS">bracket</a>
      and <a href="#DBLPARENSTST">parenthesis</a> operators,
      and the <b class="COMMAND">if/then</b> construct.</p><div class="SECT1"><hr><h1 class="SECT1"><a name="TESTCONSTRUCTS"></a>7.1. Test Constructs</h1><p><a name="TESTCONSTRUCTS1"></a></p><p></p><ul><li><p>An <b class="COMMAND">if/then</b> construct tests whether the
      <a href="#EXITSTATUSREF">exit status</a> of a list
      of commands is <span class="RETURNVALUE">0</span> (since 0 means
      <span class="QUOTE">"success"</span> by UNIX convention), and if so, executes
      one or more commands.</p></li><li><p>There exists a dedicated command called <b class="COMMAND">	[</b> (<a href="#LEFTBRACKET">left bracket</a>
    special character). It is a synonym for <b class="COMMAND">test</b>,
    and a <a href="#BUILTINREF">builtin</a> for efficiency
    reasons. This command considers its arguments as comparison
    expressions or file tests and returns an exit status corresponding
    to the result of the comparison (0 for true, 1 for false).</p></li><li><p>With version 2.02, Bash introduced the <a href="#DBLBRACKETS">[[ ... ]]</a> <i class="FIRSTTERM">extended
      test command</i>, which performs comparisons
      in a manner more familiar to programmers from other
      languages. Note that <b class="COMMAND">[[</b> is a <a href="#KEYWORDREF">keyword</a>, not a command.</p><p>Bash sees <tt class="USERINPUT"><b>[[ $a -lt $b ]]</b></tt> as a
      single element, which returns an exit status.</p></li><li><p><a name="DBLPARENSTST"></a></p><p>The <a href="#DBLPARENS">(( ... ))</a> and <a href="#LETREF">let ...</a> constructs return an
            <a href="#EXITSTATUSREF">exit status</a>,
      <em>according to whether the arithmetic expressions they
      evaluate expand to a non-zero value</em>. These
      <a href="#ARITHEXPREF">arithmetic-expansion</a>
      constructs may therefore be used to perform <a href="#ICOMPARISON1">arithmetic comparisons</a>.</p><p>        <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">(( 0 &amp;&amp; 1 ))                 # Logical AND
  echo $?     # 1     ***
  # And so ...
  let "num = (( 0 &amp;&amp; 1 ))"
  echo $num   # 0
  # But ...
  let "num = (( 0 &amp;&amp; 1 ))"
  echo $?     # 1     ***
  
  
  (( 200 || 11 ))              # Logical OR
  echo $?     # 0     ***
  # ...
  let "num = (( 200 || 11 ))"
  echo $num   # 1
  let "num = (( 200 || 11 ))"
  echo $?     # 0     ***
  
  
  (( 200 | 11 ))               # Bitwise OR
  echo $?                      # 0     ***
  # ...
  let "num = (( 200 | 11 ))"
  echo $num                    # 203
  let "num = (( 200 | 11 ))"
  echo $?                      # 0     ***
  
  # The "let" construct returns the same exit status
  #+ as the double-parentheses arithmetic expansion.</pre></font></td></tr></tbody></table>	    
      </p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p><a name="ARXS"></a>Again, note that the
      <i class="FIRSTTERM">exit status</i> of an arithmetic expression
      is <em>not</em> an error value.
      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">var=-2 &amp;&amp; (( var+=2 ))
  echo $?                   # 1
  
  var=-2 &amp;&amp; (( var+=2 )) &amp;&amp; echo $var
                            # Will not echo $var!</pre></font></td></tr></tbody></table>
            </p></td></tr></tbody></table></div></li><li><p><a name="IFGREPREF"></a></p><p>An <b class="COMMAND">if</b> can test any command, not just
        conditions enclosed within brackets.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">if cmp a b &amp;&gt; /dev/null  # Suppress output.
  then echo "Files a and b are identical."
  else echo "Files a and b differ."
  fi
  
  # The very useful "if-grep" construct:
  # ----------------------------------- 
  if grep -q Bash file
    then echo "File contains at least one occurrence of Bash."
  fi
  
  word=Linux
  letter_sequence=inu
  if echo "$word" | grep -q "$letter_sequence"
  # The "-q" option to grep suppresses output.
  then
    echo "$letter_sequence found in $word"
  else
    echo "$letter_sequence not found in $word"
  fi
  
  
  if COMMAND_WHOSE_EXIT_STATUS_IS_0_UNLESS_ERROR_OCCURRED
    then echo "Command succeeded."
    else echo "Command failed."
  fi</pre></font></td></tr></tbody></table>
            </p></li><li><p><em>These last two examples
      courtesy of StÃ©phane Chazelas.</em></p></li></ul><div class="EXAMPLE"><a name="EX10"></a><p><b>Example 7-1. What is truth?</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  #  Tip:
  #  If you're unsure how a certain condition might evaluate,
  #+ test it in an if-test.
  
  echo
  
  echo "Testing \"0\""
  if [ 0 ]      # zero
  then
    echo "0 is true."
  else          # Or else ...
    echo "0 is false."
  fi            # 0 is true.
  
  echo
  
  echo "Testing \"1\""
  if [ 1 ]      # one
  then
    echo "1 is true."
  else
    echo "1 is false."
  fi            # 1 is true.
  
  echo
  
  echo "Testing \"-1\""
  if [ -1 ]     # minus one
  then
    echo "-1 is true."
  else
    echo "-1 is false."
  fi            # -1 is true.
  
  echo
  
  echo "Testing \"NULL\""
  if [ ]        # NULL (empty condition)
  then
    echo "NULL is true."
  else
    echo "NULL is false."
  fi            # NULL is false.
  
  echo
  
  echo "Testing \"xyz\""
  if [ xyz ]    # string
  then
    echo "Random string is true."
  else
    echo "Random string is false."
  fi            # Random string is true.
  
  echo
  
  echo "Testing \"\$xyz\""
  if [ $xyz ]   # Tests if $xyz is null, but...
                # it's only an uninitialized variable.
  then
    echo "Uninitialized variable is true."
  else
    echo "Uninitialized variable is false."
  fi            # Uninitialized variable is false.
  
  echo
  
  echo "Testing \"-n \$xyz\""
  if [ -n "$xyz" ]            # More pedantically correct.
  then
    echo "Uninitialized variable is true."
  else
    echo "Uninitialized variable is false."
  fi            # Uninitialized variable is false.
  
  echo
  
  
  xyz=          # Initialized, but set to null value.
  
  echo "Testing \"-n \$xyz\""
  if [ -n "$xyz" ]
  then
    echo "Null variable is true."
  else
    echo "Null variable is false."
  fi            # Null variable is false.
  
  
  echo
  
  
  # When is "false" true?
  
  echo "Testing \"false\""
  if [ "false" ]              #  It seems that "false" is just a string ...
  then
    echo "\"false\" is true." #+ and it tests true.
  else
    echo "\"false\" is false."
  fi            # "false" is true.
  
  echo
  
  echo "Testing \"\$false\""  # Again, uninitialized variable.
  if [ "$false" ]
  then
    echo "\"\$false\" is true."
  else
    echo "\"\$false\" is false."
  fi            # "$false" is false.
                # Now, we get the expected result.
  
  #  What would happen if we tested the uninitialized variable "$true"?
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="FORMALPARA"><p><b>Exercise. </b>Explain the behavior of <a href="#EX10">Example 7-1</a>, above.</p></div><p><a name="ELSEREF"></a><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">if [ condition-true ]
  then
     command 1
     command 2
     ...
  else  # Or else ...
        # Adds default code block executing if original condition tests false.
     command 3
     command 4
     ...
  fi</pre></font></td></tr></tbody></table>
        </p><div class="NOTE"><p></p><table class="NOTE" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>When <i class="FIRSTTERM">if</i> and <i class="FIRSTTERM">then</i>
    are on same line in a condition test, a semicolon must
    terminate the <i class="FIRSTTERM">if</i> statement.  Both
    <i class="FIRSTTERM">if</i> and <i class="FIRSTTERM">then</i>
    are <a href="#KEYWORDREF">keywords</a>.  Keywords (or
    commands) begin statements, and before a new statement on the
    same line begins, the old one must terminate.</p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">if [ -x "$filename" ]; then</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div><p></p><div class="VARIABLELIST"><p><b><a name="ELIFREF1"></a>Else if and elif</b></p><dl><dt><span class="TOKEN">elif</span></dt><dd><p><tt class="USERINPUT"><b>elif</b></tt> is a contraction
          for <i class="FIRSTTERM">else if</i>. The effect is to nest an
          inner <span class="TOKEN">if/then</span> construct within an outer
          one.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">if [ condition1 ]
  then
     command1
     command2
     command3
  elif [ condition2 ]
  # Same as else if
  then
     command4
     command5
  else
     default-command
  fi</pre></font></td></tr></tbody></table>
          </p></dd></dl></div><p>      
        
        
        
        
        
    <a name="IFREF2"></a>
    The <tt class="USERINPUT"><b>if test condition-true</b></tt> construct is the
    exact equivalent of <tt class="USERINPUT"><b>if [ condition-true ]</b></tt>.
    As it happens, the left bracket, <b class="COMMAND">[</b> , is a
    <i class="FIRSTTERM">token</i>
  
    <a name="AEN3140" href="#FTN.AEN3140"><span class="footnote">[33]</span></a>
  
    which invokes the <b class="COMMAND">test</b> command.  The closing
    right bracket, <b class="COMMAND">]</b> , in an if/test should not
    therefore be strictly necessary, however newer versions of Bash
    require it.</p><p><a name="TTESTREF"></a></p><div class="NOTE"><p></p><table class="NOTE" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">test</b> command is a Bash <a href="#BUILTINREF">builtin</a> which tests file
      types and compares strings. Therefore, in a Bash script,
      <b class="COMMAND">test</b> does <em>not</em> call
      the external <tt class="FILENAME">/usr/bin/test</tt> binary,
      which is part of the <i class="FIRSTTERM">sh-utils</i>
      package. Likewise, <b class="COMMAND">[</b> does not call
      <tt class="FILENAME">/usr/bin/[</tt>, which is linked to
      <tt class="FILENAME">/usr/bin/test</tt>.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>type test</b></tt>
  <tt class="COMPUTEROUTPUT">test is a shell builtin</tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>type '['</b></tt>
  <tt class="COMPUTEROUTPUT">[ is a shell builtin</tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>type '[['</b></tt>
  <tt class="COMPUTEROUTPUT">[[ is a shell keyword</tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>type ']]'</b></tt>
  <tt class="COMPUTEROUTPUT">]] is a shell keyword</tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>type ']'</b></tt>
  <tt class="COMPUTEROUTPUT">bash: type: ]: not found</tt>
          </pre></font></td></tr></tbody></table>
        </p><p><a name="USRBINTEST"></a></p><p>If, for some reason, you wish to use
      <tt class="FILENAME">/usr/bin/test</tt> in a Bash script,
      then specify it by full pathname.</p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="EX11"></a><p><b>Example 7-2. Equivalence of <i class="FIRSTTERM">test</i>,
      <tt class="FILENAME">/usr/bin/test</tt>, <span class="TOKEN">[ ]</span>,
      and <tt class="FILENAME">/usr/bin/[</tt></b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  echo
  
  if test -z "$1"
  then
    echo "No command-line arguments."
  else
    echo "First command-line argument is $1."
  fi
  
  echo
  
  if /usr/bin/test -z "$1"      # Equivalent to "test" builtin.
  #  ^^^^^^^^^^^^^              # Specifying full pathname.
  then
    echo "No command-line arguments."
  else
    echo "First command-line argument is $1."
  fi
  
  echo
  
  if [ -z "$1" ]                # Functionally identical to above code blocks.
  #   if [ -z "$1"                should work, but...
  #+  Bash responds to a missing close-bracket with an error message.
  then
    echo "No command-line arguments."
  else
    echo "First command-line argument is $1."
  fi
  
  echo
  
  
  if /usr/bin/[ -z "$1" ]       # Again, functionally identical to above.
  # if /usr/bin/[ -z "$1"       # Works, but gives an error message.
  #                             # Note:
  #                               This has been fixed in Bash, version 3.x.
  then
    echo "No command-line arguments."
  else
    echo "First command-line argument is $1."
  fi
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div><table class="SIDEBAR" border="1" cellpadding="5"><tbody><tr><td><div class="SIDEBAR"><a name="AEN3206"></a><p></p><p><a name="DBLBRACKETS"></a>The <span class="TOKEN">[[  ]]</span> construct
    is the more versatile Bash version of <span class="TOKEN">[	]</span>. This
    is the <i class="FIRSTTERM">extended test command</i>, adopted from
    <i class="FIRSTTERM">ksh88</i>.</p><p>*  *  *</p><p>No filename expansion or word splitting takes place
    between <span class="TOKEN">[[</span> and <span class="TOKEN">]]</span>, but there is
    parameter expansion and command substitution.
  
    <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">file=/etc/passwd
  
  if [[ -e $file ]]
  then
    echo "Password file exists."
  fi</pre></font></td></tr></tbody></table>
        </p><p>Using the <b class="COMMAND">[[ ... ]]</b> test construct,
    rather than <b class="COMMAND">[ ... ]</b> can prevent many
    logic errors in scripts. For example, the <span class="TOKEN">&amp;&amp;</span>,
    <span class="TOKEN">||</span>, <span class="TOKEN">&lt;</span>, and <span class="TOKEN">&gt;</span>
    operators work within a <span class="TOKEN">[[  ]]</span> test, despite
    giving an error within a <span class="TOKEN">[  ]</span> construct.</p><p><a name="DBLBRAEV"></a></p><p><i class="FIRSTTERM">Arithmetic evaluation</i> of octal /
          hexadecimal constants takes place automatically within a
    <span class="TOKEN">[[ ... ]]</span> construct.
    <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># [[ Octal and hexadecimal evaluation ]]
  # Thank you, Moritz Gronbach, for pointing this out.
  
  
  decimal=15
  octal=017   # = 15 (decimal)
  hex=0x0f    # = 15 (decimal)
  
  if [ "$decimal" -eq "$octal" ]
  then
    echo "$decimal equals $octal"
  else
    echo "$decimal is not equal to $octal"       # 15 is not equal to 017
  fi      # Doesn't evaluate within [ single brackets ]!
  
  
  if [[ "$decimal" -eq "$octal" ]]
  then
    echo "$decimal equals $octal"                # 15 equals 017
  else
    echo "$decimal is not equal to $octal"
  fi      # Evaluates within [[ double brackets ]]!
  
  if [[ "$decimal" -eq "$hex" ]]
  then
    echo "$decimal equals $hex"                  # 15 equals 0x0f
  else
    echo "$decimal is not equal to $hex"
  fi      # [[ $hexadecimal ]] also evaluates!</pre></font></td></tr></tbody></table>
        </p><p></p></div></td></tr></tbody></table><div class="NOTE"><p></p><table class="NOTE" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>Following an <b class="COMMAND">if</b>, neither the
          <b class="COMMAND">test</b> command nor the test brackets ( [ ] or [[ ]] )
    are strictly necessary.
  
    <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">dir=/home/bozo
  
  if cd "$dir" 2&gt;/dev/null; then   # "2&gt;/dev/null" hides error message.
    echo "Now in $dir."
  else
    echo "Can't change to $dir."
  fi</pre></font></td></tr></tbody></table>
  
          The "if COMMAND" construct returns the exit status of COMMAND.</p><p>Similarly, a condition within test brackets may stand alone
      without an <b class="COMMAND">if</b>, when used in combination
      with a <a href="#LISTCONSREF">list construct</a>.
  
      <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">var1=20
  var2=22
  [ "$var1" -ne "$var2" ] &amp;&amp; echo "$var1 is not equal to $var2"
  
  home=/home/bozo
  [ -d "$home" ] || echo "$home directory does not exist."</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div><p><a name="DBLPRX"></a>The <a href="#DBLPARENS">(( ))
    construct</a> expands and evaluates an arithmetic
    expression. If the expression evaluates as zero, it returns
    an <a href="#EXITSTATUSREF">exit status</a> of
    <span class="RETURNVALUE">1</span>, or <span class="QUOTE">"false"</span>. A non-zero
    expression returns an exit status of <span class="RETURNVALUE">0</span>,
    or <span class="QUOTE">"true"</span>. This is in marked contrast to using
    the <b class="COMMAND">test</b> and <span class="TOKEN">[ ]</span> constructs
    previously discussed.</p><div class="EXAMPLE"><a name="ARITHTESTS"></a><p><b>Example 7-3. Arithmetic Tests using <span class="TOKEN">(( ))</span></b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # arith-tests.sh
  # Arithmetic tests.
  
  # The (( ... )) construct evaluates and tests numerical expressions.
  # Exit status opposite from [ ... ] construct!
  
  (( 0 ))
  echo "Exit status of \"(( 0 ))\" is $?."         # 1
  
  (( 1 ))
  echo "Exit status of \"(( 1 ))\" is $?."         # 0
  
  (( 5 &gt; 4 ))                                      # true
  echo "Exit status of \"(( 5 &gt; 4 ))\" is $?."     # 0
  
  (( 5 &gt; 9 ))                                      # false
  echo "Exit status of \"(( 5 &gt; 9 ))\" is $?."     # 1
  
  (( 5 == 5 ))                                     # true
  echo "Exit status of \"(( 5 == 5 ))\" is $?."    # 0
  # (( 5 = 5 ))  gives an error message.
  
  (( 5 - 5 ))                                      # 0
  echo "Exit status of \"(( 5 - 5 ))\" is $?."     # 1
  
  (( 5 / 4 ))                                      # Division o.k.
  echo "Exit status of \"(( 5 / 4 ))\" is $?."     # 0
  
  (( 1 / 2 ))                                      # Division result &lt; 1.
  echo "Exit status of \"(( 1 / 2 ))\" is $?."     # Rounded off to 0.
                                                   # 1
  
  (( 1 / 0 )) 2&gt;/dev/null                          # Illegal division by 0.
  #           ^^^^^^^^^^^
  echo "Exit status of \"(( 1 / 0 ))\" is $?."     # 1
  
  # What effect does the "2&gt;/dev/null" have?
  # What would happen if it were removed?
  # Try removing it, then rerunning the script.
  
  # ======================================= #
  
  # (( ... )) also useful in an if-then test.
  
  var1=5
  var2=4
  
  if (( var1 &gt; var2 ))
  then #^      ^      Note: Not $var1, $var2. Why?
    echo "$var1 is greater than $var2"
  fi     # 5 is greater than 4
  
  exit 0</pre></font></td></tr></tbody></table></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="FTO"></a>7.2. File test operators</h1><p></p><div class="VARIABLELIST"><p><b><a name="RTIF"></a>Returns true if...</b></p><dl><dt><span class="TOKEN">-e</span></dt><dd><p>file exists</p></dd><dt><span class="TOKEN">-a</span></dt><dd><p>file exists</p><p>This is identical in effect to <span class="TOKEN">-e</span>.
          It has been <span class="QUOTE">"deprecated,"</span>
  
            <a name="AEN3289" href="#FTN.AEN3289"><span class="footnote">[34]</span></a>
          
          and its use is
          discouraged.</p></dd><dt><a name="REGULARFILE"></a><span class="TOKEN">-f</span></dt><dd><p>file is a <tt class="REPLACEABLE"><i>regular</i></tt>
          file (not a directory or <a href="#DEVFILEREF">device
          file</a>)</p></dd><dt><span class="TOKEN">-s</span></dt><dd><p>file is not zero size</p></dd><dt><span class="TOKEN">-d</span></dt><dd><p>file is a directory</p></dd><dt><span class="TOKEN">-b</span></dt><dd><p>file is a <a href="#BLOCKDEVREF">block
        device</a></p><p><a name="BLOCKDEVTEST"></a></p></dd><dt><span class="TOKEN">-c</span></dt><dd><p><a name="CHARDEVTEST"></a>file is a <a href="#CHARDEVREF">character device</a></p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">device0="/dev/sda2"    # /   (root directory)
  if [ -b "$device0" ]
  then
    echo "$device0 is a block device."
  fi
  
  # /dev/sda2 is a block device.
  
  
  
  device1="/dev/ttyS1"   # PCMCIA modem card.
  if [ -c "$device1" ]
  then
    echo "$device1 is a character device."
  fi
  
  # /dev/ttyS1 is a character device.</pre></font></td></tr></tbody></table></p></dd><dt><span class="TOKEN">-p</span></dt><dd><p>file is a <a href="#PIPEREF">pipe</a></p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">function show_input_type()
  {
     [ -p /dev/fd/0 ] &amp;&amp; echo PIPE || echo STDIN
  }
  
  show_input_type "Input"                           # STDIN
  echo "Input" | show_input_type                    # PIPE
  
  # This example courtesy of Carl Anderson.</pre></font></td></tr></tbody></table></p></dd><dt><span class="TOKEN">-h</span></dt><dd><p>file is a <a href="#SYMLINKREF">symbolic
          link</a></p></dd><dt><span class="TOKEN">-L</span></dt><dd><p>file is a symbolic link</p></dd><dt><span class="TOKEN">-S</span></dt><dd><p>file is a <a href="#SOCKETREF">socket</a></p></dd><dt><span class="TOKEN">-t</span></dt><dd><p><a name="TERMTEST"></a>file (<a href="#FDREF">descriptor</a>) is
          associated with a terminal device</p><p>This test option <a href="#II2TEST"> may be used
          to check</a> whether the <tt class="FILENAME">stdin</tt>
          <tt class="USERINPUT"><b>[ -t 0 ]</b></tt> or
          <tt class="FILENAME">stdout</tt> <tt class="USERINPUT"><b>[ -t 1 ]</b></tt>
          in a given script is a terminal.</p></dd><dt><span class="TOKEN">-r</span></dt><dd><p>file has read permission (<em>for the
          user running the test</em>)</p></dd><dt><span class="TOKEN">-w</span></dt><dd><p>file has write permission (for the user running
          the test)</p></dd><dt><span class="TOKEN">-x</span></dt><dd><p>file has execute permission (for the user running
        the test)</p></dd><dt><span class="TOKEN">-g</span></dt><dd><p>set-group-id (sgid) flag set on file or directory</p><p>If a directory has the <tt class="REPLACEABLE"><i>sgid</i></tt>
          flag set, then a file created within that directory belongs
          to the group that owns the directory, not necessarily to
          the group of the user who created the file. This may be
          useful for a directory shared by a workgroup.</p></dd><dt><span class="TOKEN">-u</span></dt><dd><p><a name="SUIDREF"></a></p><p>set-user-id (suid) flag set on file</p><p>A binary owned by <i class="FIRSTTERM">root</i>
          with <tt class="REPLACEABLE"><i>set-user-id</i></tt> flag set
          runs with <i class="FIRSTTERM">root</i> privileges, even
          when an ordinary user invokes it.
          
      <a name="AEN3400" href="#FTN.AEN3400"><span class="footnote">[35]</span></a>
  
          This is useful for executables (such as
          <b class="COMMAND">pppd</b> and <b class="COMMAND">cdrecord</b>)
          that need to access system hardware. Lacking the
          <i class="FIRSTTERM">suid</i> flag, these binaries could not
          be invoked by a <i class="FIRSTTERM">non-root</i> user.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN">	      <tt class="COMPUTEROUTPUT">-rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd</tt>
          </pre></font></td></tr></tbody></table>
          </p><p>A file with the <tt class="REPLACEABLE"><i>suid</i></tt>
      flag set shows an <i class="FIRSTTERM">s</i> in its
      permissions.</p></dd><dt><span class="TOKEN">-k</span></dt><dd><p><tt class="REPLACEABLE"><i>sticky bit</i></tt> set</p><p>Commonly known as the <i class="FIRSTTERM">sticky bit,</i>
          the <i class="FIRSTTERM">save-text-mode</i> flag is a special
          type of file permission. If a file has this flag set,
          that file will be kept in cache memory, for quicker access.
            <a name="AEN3423" href="#FTN.AEN3423"><span class="footnote">[36]</span></a>
          If set on a directory, it restricts write permission.
          Setting the sticky bit adds a <i class="FIRSTTERM">t</i>
          to the permissions on the file or directory listing.
          This restricts altering or deleting specific files 
          in that directory to the owner of those files.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN">	      <tt class="COMPUTEROUTPUT">drwxrwxrwt    7 root         1024 May 19 21:26 tmp/</tt>
          </pre></font></td></tr></tbody></table>
          </p><p>If a user does not own a directory that has the sticky
      bit set, but has write permission in that directory, she
      can only delete those files that she owns in it. This
      keeps users from inadvertently overwriting or deleting
      each other's files in a publicly accessible directory,
      such as <tt class="FILENAME">/tmp</tt>.
      (The <i class="FIRSTTERM">owner</i> of the directory or
      <i class="FIRSTTERM">root</i> can, of course, delete or
      rename files there.)</p></dd><dt><span class="TOKEN">-O</span></dt><dd><p>you are owner of file</p></dd><dt><span class="TOKEN">-G</span></dt><dd><p>group-id of file same as yours</p></dd><dt><span class="TOKEN">-N</span></dt><dd><p>file modified since it was last read</p></dd><dt><span class="TOKEN">f1 -nt f2</span></dt><dd><p>file <tt class="REPLACEABLE"><i>f1</i></tt> is newer than
      <tt class="REPLACEABLE"><i>f2</i></tt></p></dd><dt><span class="TOKEN">f1 -ot f2</span></dt><dd><p>file <tt class="REPLACEABLE"><i>f1</i></tt> is older than
      <tt class="REPLACEABLE"><i>f2</i></tt></p></dd><dt><span class="TOKEN">f1 -ef f2</span></dt><dd><p>files <tt class="REPLACEABLE"><i>f1</i></tt> and
      <tt class="REPLACEABLE"><i>f2</i></tt> are hard links to the same
      file</p></dd><dt><span class="TOKEN">!</span></dt><dd><p><span class="QUOTE">"not"</span> -- reverses the sense of the
        tests above (returns true if condition absent).</p></dd></dl></div><div class="EXAMPLE"><a name="BROKENLINK"></a><p><b>Example 7-4. Testing for broken links</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # broken-link.sh
  # Written by Lee bigelow &lt;ligelowbee@yahoo.com&gt;
  # Used in ABS Guide with permission.
  
  #  A pure shell script to find dead symlinks and output them quoted
  #+ so they can be fed to xargs and dealt with :)
  #+ eg. sh broken-link.sh /somedir /someotherdir|xargs rm
  #
  #  This, however, is a better method:
  #
  #  find "somedir" -type l -print0|\
  #  xargs -r0 file|\
  #  grep "broken symbolic"|
  #  sed -e 's/^\|: *broken symbolic.*$/"/g'
  #
  #+ but that wouldn't be pure Bash, now would it.
  #  Caution: beware the /proc file system and any circular links!
  ################################################################
  
  
  #  If no args are passed to the script set directories-to-search 
  #+ to current directory.  Otherwise set the directories-to-search 
  #+ to the args passed.
  ######################
  
  [ $# -eq 0 ] &amp;&amp; directorys=`pwd` || directorys=$@
  
  
  #  Setup the function linkchk to check the directory it is passed 
  #+ for files that are links and don't exist, then print them quoted.
  #  If one of the elements in the directory is a subdirectory then 
  #+ send that subdirectory to the linkcheck function.
  ##########
  
  linkchk () {
      for element in $1/*; do
        [ -h "$element" -a ! -e "$element" ] &amp;&amp; echo \"$element\"
        [ -d "$element" ] &amp;&amp; linkchk $element
      # Of course, '-h' tests for symbolic link, '-d' for directory.
      done
  }
  
  #  Send each arg that was passed to the script to the linkchk() function
  #+ if it is a valid directoy.  If not, then print the error message
  #+ and usage info.
  ##################
  for directory in $directorys; do
      if [ -d $directory ]
    then linkchk $directory
    else 
        echo "$directory is not a directory"
        echo "Usage: $0 dir1 dir2 ..."
      fi
  done
  
  exit $?</pre></font></td></tr></tbody></table></div><p><a href="#COOKIES">Example 31-1</a>, <a href="#BINGREP">Example 11-8</a>,
      <a href="#FILEINFO">Example 11-3</a>, <a href="#RAMDISK">Example 31-3</a>, and <a href="#MAILFORMAT">Example A-1</a> also illustrate uses of the file test
      operators.</p></div><div class="SECT1"><hr><h1 class="SECT1"><a name="COMPARISON-OPS"></a>7.3. Other Comparison Operators</h1><p>A <i class="FIRSTTERM">binary</i> comparison operator
      compares two variables or quantities. <em>Note
      that integer and string comparison use a different set of
      operators.</em></p><p></p><div class="VARIABLELIST"><p><b><a name="ICOMPARISON1"></a>integer comparison</b></p><dl><dt><a name="EQUALREF"></a><span class="TOKEN">-eq</span></dt><dd><p>is equal to</p><p><tt class="USERINPUT"><b>if [ "$a" -eq "$b" ]</b></tt></p></dd><dt><a name="NEQUALREF"></a><span class="TOKEN">-ne</span></dt><dd><p>is not equal to</p><p><tt class="USERINPUT"><b>if [ "$a" -ne "$b" ]</b></tt></p></dd><dt><a name="GT0REF"></a><span class="TOKEN">-gt</span></dt><dd><p>is greater than</p><p><tt class="USERINPUT"><b>if [ "$a" -gt "$b" ]</b></tt></p></dd><dt><a name="GE0REF"></a><span class="TOKEN">-ge</span></dt><dd><p>is greater than or equal to</p><p><tt class="USERINPUT"><b>if [ "$a" -ge "$b" ]</b></tt></p></dd><dt><a name="LT0REF"></a><span class="TOKEN">-lt</span></dt><dd><p>is less than</p><p><tt class="USERINPUT"><b>if [ "$a" -lt "$b" ]</b></tt></p></dd><dt><a name="LE0REF"></a><span class="TOKEN">-le</span></dt><dd><p>is less than or equal to</p><p><tt class="USERINPUT"><b>if [ "$a" -le "$b" ]</b></tt></p></dd><dt><a name="INTLT"></a><span class="TOKEN">&lt;</span></dt><dd><p>is less than (within <a href="#DBLPARENS">double
          parentheses</a>)</p><p><tt class="USERINPUT"><b>(("$a" &lt; "$b"))</b></tt></p></dd><dt><a name="LTEQ"></a><span class="TOKEN">&lt;=</span></dt><dd><p>is less than or equal to (within double parentheses)</p><p><tt class="USERINPUT"><b>(("$a" &lt;= "$b"))</b></tt></p></dd><dt><a name="INTGT"></a><span class="TOKEN">&gt;</span></dt><dd><p>is greater than (within double parentheses)</p><p><tt class="USERINPUT"><b>(("$a" &gt; "$b"))</b></tt></p></dd><dt><a name="GTEQ"></a><span class="TOKEN">&gt;=</span></dt><dd><p>is greater than or equal to (within double parentheses)</p><p><tt class="USERINPUT"><b>(("$a" &gt;= "$b"))</b></tt></p></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="SCOMPARISON1"></a>string comparison</b></p><dl><dt><span class="TOKEN">=</span></dt><dd><p><a name="EQUALSIGNREF"></a></p><p>is equal to</p><p><tt class="USERINPUT"><b>if [ "$a" = "$b" ]</b></tt></p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>Note the <a href="#WHITESPACEREF">whitespace</a>
                framing the <b class="COMMAND">=</b>.</p><p><tt class="USERINPUT"><b>if [ "$a"="$b" ]</b></tt> is
                <em>not</em> equivalent to the
                above.</p></td></tr></tbody></table></div></dd><dt><a name="SCOMPARISON2"></a><span class="TOKEN">==</span></dt><dd><p>is equal to</p><p><tt class="USERINPUT"><b>if [ "$a" == "$b" ]</b></tt></p><p>This is a synonym for <span class="TOKEN">=</span>.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>	      The <span class="TOKEN">==</span> comparison operator behaves differently
          within a <a href="#DBLBRACKETS">double-brackets</a>
          test than within single brackets.
                <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">[[ $a == z* ]]   # True if $a starts with an "z" (pattern matching).
  [[ $a == "z*" ]] # True if $a is equal to z* (literal matching).
  
  [ $a == z* ]     # File globbing and word splitting take place.
  [ "$a" == "z*" ] # True if $a is equal to z* (literal matching).
  
  # Thanks, StÃ©phane Chazelas</pre></font></td></tr></tbody></table>
                </p></td></tr></tbody></table></div></dd><dt><a name="NOTEQUAL"></a><span class="TOKEN">!=</span></dt><dd><p>is not equal to</p><p><tt class="USERINPUT"><b>if [ "$a" != "$b" ]</b></tt></p><p>This operator uses pattern matching within a <a href="#DBLBRACKETS">[[ ... ]]</a> construct.</p></dd><dt><a name="LTREF"></a><span class="TOKEN">&lt;</span></dt><dd><p>is less than, in <a href="#ASCIIDEF">ASCII</a> alphabetical
          order</p><p><tt class="USERINPUT"><b>if [[ "$a" &lt; "$b" ]]</b></tt></p><p><tt class="USERINPUT"><b>if [ "$a" \&lt; "$b" ]</b></tt></p><p>Note that the <span class="QUOTE">"&lt;"</span> needs to be
          <a href="#ESCP">escaped</a> within a
          <tt class="USERINPUT"><b>[  ]</b></tt> construct.</p></dd><dt><a name="GTREF"></a><span class="TOKEN">&gt;</span></dt><dd><p>is greater than, in ASCII alphabetical order</p><p><tt class="USERINPUT"><b>if [[ "$a" &gt; "$b" ]]</b></tt></p><p><tt class="USERINPUT"><b>if [ "$a" \&gt; "$b" ]</b></tt></p><p>Note that the <span class="QUOTE">"&gt;"</span> needs to be
          escaped within a <tt class="USERINPUT"><b>[  ]</b></tt> construct.</p><p>See <a href="#BUBBLE">Example 27-11</a> for an application of this
          comparison operator.</p></dd><dt><a name="STRINGNULL"></a><span class="TOKEN">-z</span></dt><dd><p>string is <i class="FIRSTTERM">null</i>,
            that is, has zero length</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"> String=''   # Zero-length ("null") string variable.
  
  if [ -z "$String" ]
  then
    echo "\$String is null."
  else
    echo "\$String is NOT null."
  fi     # $String is null.</pre></font></td></tr></tbody></table></p></dd><dt><a name="STRINGNOTNULL"></a><span class="TOKEN">-n</span></dt><dd><p>string is not <i class="FIRSTTERM">null.</i></p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>The <tt class="USERINPUT"><b>-n</b></tt> test
      requires that the string be quoted within the
      test brackets. Using an unquoted string with
      <i class="FIRSTTERM">! -z</i>, or even just the
      unquoted string alone within test brackets (see <a href="#STRTEST">Example 7-6</a>) normally works, however, this is
      an unsafe practice. <em>Always</em> quote
      a tested string.
        <a name="AEN3669" href="#FTN.AEN3669"><span class="footnote">[37]</span></a>
      </p></td></tr></tbody></table></div></dd></dl></div><div class="EXAMPLE"><a name="EX13"></a><p><b>Example 7-5. Arithmetic and string comparisons</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  a=4
  b=5
  
  #  Here "a" and "b" can be treated either as integers or strings.
  #  There is some blurring between the arithmetic and string comparisons,
  #+ since Bash variables are not strongly typed.
  
  #  Bash permits integer operations and comparisons on variables
  #+ whose value consists of all-integer characters.
  #  Caution advised, however.
  
  echo
  
  if [ "$a" -ne "$b" ]
  then
    echo "$a is not equal to $b"
    echo "(arithmetic comparison)"
  fi
  
  echo
  
  if [ "$a" != "$b" ]
  then
    echo "$a is not equal to $b."
    echo "(string comparison)"
    #     "4"  != "5"
    # ASCII 52 != ASCII 53
  fi
  
  # In this particular instance, both "-ne" and "!=" work.
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="STRTEST"></a><p><b>Example 7-6. Testing whether a string is <i class="FIRSTTERM">null</i></b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  #  str-test.sh: Testing null strings and unquoted strings,
  #+ but not strings and sealing wax, not to mention cabbages and kings . . .
  
  # Using   if [ ... ]
  
  # If a string has not been initialized, it has no defined value.
  # This state is called "null" (not the same as zero!).
  
  if [ -n $string1 ]    # string1 has not been declared or initialized.
  then
    echo "String \"string1\" is not null."
  else  
    echo "String \"string1\" is null."
  fi                    # Wrong result.
  # Shows $string1 as not null, although it was not initialized.
  
  echo
  
  # Let's try it again.
  
  if [ -n "$string1" ]  # This time, $string1 is quoted.
  then
    echo "String \"string1\" is not null."
  else  
    echo "String \"string1\" is null."
  fi                    # Quote strings within test brackets!
  
  echo
  
  if [ $string1 ]       # This time, $string1 stands naked.
  then
    echo "String \"string1\" is not null."
  else  
    echo "String \"string1\" is null."
  fi                    # This works fine.
  # The [ ... ] test operator alone detects whether the string is null.
  # However it is good practice to quote it (if [ "$string1" ]).
  #
  # As Stephane Chazelas points out,
  #    if [ $string1 ]    has one argument, "]"
  #    if [ "$string1" ]  has two arguments, the empty "$string1" and "]" 
  
  
  echo
  
  
  string1=initialized
  
  if [ $string1 ]       # Again, $string1 stands unquoted.
  then
    echo "String \"string1\" is not null."
  else  
    echo "String \"string1\" is null."
  fi                    # Again, gives correct result.
  # Still, it is better to quote it ("$string1"), because . . .
  
  
  string1="a = b"
  
  if [ $string1 ]       # Again, $string1 stands unquoted.
  then
    echo "String \"string1\" is not null."
  else  
    echo "String \"string1\" is null."
  fi                    # Not quoting "$string1" now gives wrong result!
  
  exit 0   # Thank you, also, Florian Wisser, for the "heads-up".</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="EX14"></a><p><b>Example 7-7. <i class="FIRSTTERM">zmore</i></b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # zmore
  
  # View gzipped files with 'more' filter.
  
  E_NOARGS=85
  E_NOTFOUND=86
  E_NOTGZIP=87
  
  if [ $# -eq 0 ] # same effect as:  if [ -z "$1" ]
  # $1 can exist, but be empty:  zmore "" arg2 arg3
  then
    echo "Usage: `basename $0` filename" &gt;&amp;2
    # Error message to stderr.
    exit $E_NOARGS
    # Returns 85 as exit status of script (error code).
  fi  
  
  filename=$1
  
  if [ ! -f "$filename" ]   # Quoting $filename allows for possible spaces.
  then
    echo "File $filename not found!" &gt;&amp;2   # Error message to stderr.
    exit $E_NOTFOUND
  fi  
  
  if [ ${filename##*.} != "gz" ]
  # Using bracket in variable substitution.
  then
    echo "File $1 is not a gzipped file!"
    exit $E_NOTGZIP
  fi  
  
  zcat $1 | more
  
  # Uses the 'more' filter.
  # May substitute 'less' if desired.
  
  exit $?   # Script returns exit status of pipe.
  #  Actually "exit $?" is unnecessary, as the script will, in any case,
  #+ return the exit status of the last command executed.</pre></font></td></tr></tbody></table></div><p></p><div class="VARIABLELIST"><p><b><a name="CCOMPARISON1"></a>compound comparison</b></p><dl><dt><a name="COMPOUNDAND"></a><span class="TOKEN">-a</span></dt><dd><p>logical and</p><p><tt class="REPLACEABLE"><i>exp1 -a exp2</i></tt> returns true if
      <em>both</em> exp1 and exp2 are true.</p></dd><dt><a name="COMPOUNDOR"></a><span class="TOKEN">-o</span></dt><dd><p>logical or </p><p><tt class="REPLACEABLE"><i>exp1 -o exp2</i></tt> returns
      true if either exp1 <em>or</em> exp2 is
      true.</p></dd></dl></div><p>         These are similar to the Bash comparison operators
     <b class="COMMAND">&amp;&amp;</b> and <b class="COMMAND">||</b>, used
     within <a href="#DBLBRACKETS">double brackets</a>.
       <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">[[ condition1 &amp;&amp; condition2 ]]</pre></font></td></tr></tbody></table>
         </p><p>	 The <b class="COMMAND">-o</b> and <b class="COMMAND">-a</b> operators
     work with the <a href="#TTESTREF">test</a> command or
     occur within single test brackets.
           <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">if [ "$expr1" -a "$expr2" ]
  then
    echo "Both expr1 and expr2 are true."
  else
    echo "Either expr1 or expr2 is false."
  fi</pre></font></td></tr></tbody></table>
       </p><div class="CAUTION"><p></p><table class="CAUTION" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>But, as <em>rihad</em> points out:
  <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">[ 1 -eq 1 ] &amp;&amp; [ -n "`echo true 1&gt;&amp;2`" ]   # true
  [ 1 -eq 2 ] &amp;&amp; [ -n "`echo true 1&gt;&amp;2`" ]   # (no output)
  # ^^^^^^^ False condition. So far, everything as expected.
  
  # However ...
  [ 1 -eq 2 -a -n "`echo true 1&gt;&amp;2`" ]       # true
  # ^^^^^^^ False condition. So, why "true" output?
  
  # Is it because both condition clauses within brackets evaluate?
  [[ 1 -eq 2 &amp;&amp; -n "`echo true 1&gt;&amp;2`" ]]     # (no output)
  # No, that's not it.
  
  # Apparently &amp;&amp; and || "short-circuit" while -a and -o do not.</pre></font></td></tr></tbody></table>
       </p></td></tr></tbody></table></div><p>Refer to <a href="#ANDOR">Example 8-3</a>, <a href="#TWODIM">Example 27-17</a>,
     and <a href="#WHX">Example A-29</a> to see compound comparison operators
     in action.</p></div><div class="SECT1"><hr><h1 class="SECT1"><a name="NESTEDIFTHEN"></a>7.4. Nested <tt class="REPLACEABLE"><i>if/then</i></tt> Condition Tests</h1><p>Condition tests using the <tt class="REPLACEABLE"><i>if/then</i></tt>
     construct may be nested. The net result is equivalent to using the
     <a href="#LOGOPS1"><i class="FIRSTTERM">&amp;&amp;</i></a> compound
     comparison operator.</p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">a=3
  
  if [ "$a" -gt 0 ]
  then
    if [ "$a" -lt 5 ]
    then
      echo "The value of \"a\" lies somewhere between 0 and 5."
    fi
  fi
  
  # Same result as:
  
  if [ "$a" -gt 0 ] &amp;&amp; [ "$a" -lt 5 ]
  then
    echo "The value of \"a\" lies somewhere between 0 and 5."
  fi</pre></font></td></tr></tbody></table></p><p><a href="#CARDS">Example 37-4</a> and <a href="#BACKLIGHT">Example 17-11</a>
           demonstrate nested <tt class="REPLACEABLE"><i>if/then</i></tt> condition
           tests.</p></div><div class="SECT1"><hr><h1 class="SECT1"><a name="TESTTEST"></a>7.5. Testing Your Knowledge of Tests</h1><p>The systemwide <tt class="FILENAME">xinitrc</tt> file can be used
    to launch the X server. This file contains quite a number
    of <i class="FIRSTTERM">if/then</i> tests. The following
    is excerpted from an <span class="QUOTE">"ancient"</span> version of
    <tt class="FILENAME">xinitrc</tt> (<i class="FIRSTTERM">Red Hat 7.1</i>,
    or thereabouts).</p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">if [ -f $HOME/.Xclients ]; then
    exec $HOME/.Xclients
  elif [ -f /etc/X11/xinit/Xclients ]; then
    exec /etc/X11/xinit/Xclients
  else
       # failsafe settings.  Although we should never get here
       # (we provide fallbacks in Xclients as well) it can't hurt.
       xclock -geometry 100x100-5+5 &amp;
       xterm -geometry 80x50-50+150 &amp;
       if [ -f /usr/bin/netscape -a -f /usr/share/doc/HTML/index.html ]; then
               netscape /usr/share/doc/HTML/index.html &amp;
       fi
  fi</pre></font></td></tr></tbody></table></p><p>Explain the <i class="FIRSTTERM">test</i> constructs in the
         above snippet, then examine an updated version of the
         file, <tt class="FILENAME">/etc/X11/xinit/xinitrc</tt>, and
         analyze the <i class="FIRSTTERM">if/then</i> test constructs
         there. You may need to refer ahead to the discussions of <a href="#GREPREF">grep</a>, <a href="#SEDREF">sed</a>,
         and <a href="#REGEXREF">regular expressions</a>.</p></div></div><div class="CHAPTER"><hr><h1><a name="OPERATIONS"></a>Chapter 8. Operations and Related Topics</h1><div class="SECT1"><h1 class="SECT1"><a name="OPS"></a>8.1. Operators</h1><p></p><div class="VARIABLELIST"><p><b><a name="ASNOP1"></a>assignment</b></p><dl><dt><tt class="REPLACEABLE"><i>variable assignment</i></tt></dt><dd><p>Initializing or changing the value of a variable</p></dd><dt>=</dt><dd><p>All-purpose assignment operator, which works for both
        arithmetic and string assignments.</p><p>	      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">var=27
  category=minerals  # No spaces allowed after the "=".</pre></font></td></tr></tbody></table>
        </p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>Do not confuse the <span class="QUOTE">"="</span> assignment
          operator with the <a href="#EQUALSIGNREF">= test
          operator</a>.</p><p>	      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#   =  as a test operator
  
  if [ "$string1" = "$string2" ]
  then
     command
  fi
  
  #  if [ "X$string1" = "X$string2" ] is safer,
  #+ to prevent an error message should one of the variables be empty.
  #  (The prepended "X" characters cancel out.)</pre></font></td></tr></tbody></table>
        </p></td></tr></tbody></table></div></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="AROPS1"></a>arithmetic operators</b></p><dl><dt><span class="TOKEN">+</span></dt><dd><p>plus</p></dd><dt><span class="TOKEN">-</span></dt><dd><p>minus</p></dd><dt><span class="TOKEN">*</span></dt><dd><p>multiplication</p></dd><dt><span class="TOKEN">/</span></dt><dd><p>division</p></dd><dt><a name="EXPONENTIATIONREF"></a><span class="TOKEN">**</span></dt><dd><p>exponentiation</p><p>	    <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Bash, version 2.02, introduced the "**" exponentiation operator.
  
  let "z=5**3"    # 5 * 5 * 5
  echo "z = $z"   # z = 125</pre></font></td></tr></tbody></table>
            </p></dd><dt><a name="MODULOREF"></a><span class="TOKEN">%</span></dt><dd><p>modulo, or mod (returns the
        <i class="FIRSTTERM">remainder</i> of an integer division
        operation)</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>expr 5 % 3</b></tt>
  <tt class="COMPUTEROUTPUT">2</tt>
          </pre></font></td></tr></tbody></table>
          <em>5/3 = 1, with remainder 2</em>
        </p><p>This operator finds use in, among other things,
        generating numbers within a specific range (see <a href="#EX21">Example 9-11</a> and <a href="#RANDOMTEST">Example 9-15</a>) and
        formatting program output (see <a href="#QFUNCTION">Example 27-16</a> and
        <a href="#COLLATZ">Example A-6</a>). It can even be used to generate
        prime numbers, (see <a href="#PRIMES">Example A-15</a>). Modulo turns
        up surprisingly often in numerical recipes.</p><div class="EXAMPLE"><a name="GCD"></a><p><b>Example 8-1. Greatest common divisor</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # gcd.sh: greatest common divisor
  #         Uses Euclid's algorithm
  
  #  The "greatest common divisor" (gcd) of two integers
  #+ is the largest integer that will divide both, leaving no remainder.
  
  #  Euclid's algorithm uses successive division.
  #    In each pass,
  #+      dividend &lt;---  divisor
  #+      divisor  &lt;---  remainder
  #+   until remainder = 0.
  #    The gcd = dividend, on the final pass.
  #
  #  For an excellent discussion of Euclid's algorithm, see
  #+ Jim Loy's site, http://www.jimloy.com/number/euclids.htm.
  
  
  # ------------------------------------------------------
  # Argument check
  ARGS=2
  E_BADARGS=85
  
  if [ $# -ne "$ARGS" ]
  then
    echo "Usage: `basename $0` first-number second-number"
    exit $E_BADARGS
  fi
  # ------------------------------------------------------
  
  
  gcd ()
  {
  
    dividend=$1             #  Arbitrary assignment.
    divisor=$2              #! It doesn't matter which of the two is larger.
                            #  Why not?
  
    remainder=1             #  If an uninitialized variable is used inside
                            #+ test brackets, an error message results.
  
    until [ "$remainder" -eq 0 ]
    do    #  ^^^^^^^^^^  Must be previously initialized!
      let "remainder = $dividend % $divisor"
      dividend=$divisor     # Now repeat with 2 smallest numbers.
      divisor=$remainder
    done                    # Euclid's algorithm
  
  }                         # Last $dividend is the gcd.
  
  
  gcd $1 $2
  
  echo; echo "GCD of $1 and $2 = $dividend"; echo
  
  
  # Exercises :
  # ---------
  # 1) Check command-line arguments to make sure they are integers,
  #+   and exit the script with an appropriate error message if not.
  # 2) Rewrite the gcd () function to use local variables.
  
  exit 0</pre></font></td></tr></tbody></table></div></dd><dt><a name="ARITHOPSCOMB"></a><span class="TOKEN">+=</span></dt><dd><p><i class="FIRSTTERM">plus-equal</i> (increment variable
              by a constant)
  
              <a name="AEN3907" href="#FTN.AEN3907"><span class="footnote">[38]</span></a>
  
        </p><p><tt class="USERINPUT"><b>let "var += 5"</b></tt> results in
          <tt class="PARAMETER"><i>var</i></tt> being incremented by
          <tt class="LITERAL">5</tt>.</p></dd><dt><span class="TOKEN">-=</span></dt><dd><p><i class="FIRSTTERM">minus-equal</i> (decrement
        variable by a constant)</p></dd><dt><span class="TOKEN">*=</span></dt><dd><p><i class="FIRSTTERM">times-equal</i> (multiply
        variable by a constant)</p><p><tt class="USERINPUT"><b>let "var *= 4"</b></tt> results in <tt class="PARAMETER"><i>var</i></tt>
        being multiplied by <tt class="LITERAL">4</tt>.</p></dd><dt><span class="TOKEN">/=</span></dt><dd><p><i class="FIRSTTERM">slash-equal</i> (divide
        variable by a constant)</p></dd><dt><span class="TOKEN">%=</span></dt><dd><p><i class="FIRSTTERM">mod-equal</i>
        (<i class="FIRSTTERM">remainder</i>
        of dividing variable by a constant)</p><p><em>Arithmetic operators often occur in an
          <a href="#EXPRREF">expr</a> or <a href="#LETREF">let</a> expression.</em></p><div class="EXAMPLE"><a name="ARITHOPS"></a><p><b>Example 8-2. Using Arithmetic Operations</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Counting to 11 in 10 different ways.
  
  n=1; echo -n "$n "
  
  let "n = $n + 1"   # let "n = n + 1"  also works.
  echo -n "$n "
  
  
  : $((n = $n + 1))
  #  ":" necessary because otherwise Bash attempts
  #+ to interpret "$((n = $n + 1))" as a command.
  echo -n "$n "
  
  (( n = n + 1 ))
  #  A simpler alternative to the method above.
  #  Thanks, David Lombard, for pointing this out.
  echo -n "$n "
  
  n=$(($n + 1))
  echo -n "$n "
  
  : $[ n = $n + 1 ]
  #  ":" necessary because otherwise Bash attempts
  #+ to interpret "$[ n = $n + 1 ]" as a command.
  #  Works even if "n" was initialized as a string.
  echo -n "$n "
  
  n=$[ $n + 1 ]
  #  Works even if "n" was initialized as a string.
  #* Avoid this type of construct, since it is obsolete and nonportable.
  #  Thanks, Stephane Chazelas.
  echo -n "$n "
  
  # Now for C-style increment operators.
  # Thanks, Frank Wang, for pointing this out.
  
  let "n++"          # let "++n"  also works.
  echo -n "$n "
  
  (( n++ ))          # (( ++n ))  also works.
  echo -n "$n "
  
  : $(( n++ ))       # : $(( ++n )) also works.
  echo -n "$n "
  
  : $[ n++ ]         # : $[ ++n ] also works
  echo -n "$n "
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div></dd></dl></div><p><a name="INTVARREF"></a></p><div class="NOTE"><p></p><table class="NOTE" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>Integer variables in older versions of Bash were signed
    <i class="FIRSTTERM">long</i> (32-bit) integers, in the range of
    -2147483648 to 2147483647. An operation that took a variable
    outside these limits gave an erroneous result.</p><p>	  <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo $BASH_VERSION   # 1.14
  
  a=2147483646
  echo "a = $a"        # a = 2147483646
  let "a+=1"           # Increment "a".
  echo "a = $a"        # a = 2147483647
  let "a+=1"           # increment "a" again, past the limit.
  echo "a = $a"        # a = -2147483648
                       #      ERROR: out of range,
                       # +    and the leftmost bit, the sign bit,
                       # +    has been set, making the result negative.</pre></font></td></tr></tbody></table>
    </p><p>As of version &gt;= 2.05b, Bash supports 64-bit integers.</p></td></tr></tbody></table></div><div class="CAUTION"><p></p><table class="CAUTION" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p><a name="NOFLOATINGPOINT"></a></p><p>Bash does not understand floating point arithmetic. It
          treats numbers containing a decimal point as strings.</p><p>        <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">a=1.5
  
  let "b = $a + 1.3"  # Error.
  # t2.sh: let: b = 1.5 + 1.3: syntax error in expression
  #                            (error token is ".5 + 1.3")
  
  echo "b = $b"       # b=1</pre></font></td></tr></tbody></table>
        </p><p>Use <a href="#BCREF">bc</a> in scripts that that need floating
    point calculations or math library functions.</p></td></tr></tbody></table></div><div class="FORMALPARA"><p><b>bitwise operators. </b>The bitwise operators seldom make an appearance in shell scripts.
    Their chief use seems to be manipulating and testing values read
    from ports or <a href="#SOCKETREF">sockets</a>. <span class="QUOTE">"Bit
    flipping"</span> is more relevant to compiled languages, such
    as C and C++, which provide direct access to system
    hardware. However, see <em>vladz's</em>
    ingenious use of bitwise operators in his
    <i class="FIRSTTERM">base64.sh</i> (<a href="#BASE64">Example A-54</a>)
    script. </p></div><p></p><div class="VARIABLELIST"><p><b><a name="BITWSOPS1"></a>bitwise operators</b></p><dl><dt><span class="TOKEN">&lt;&lt;</span></dt><dd><p>bitwise left shift (multiplies by <tt class="LITERAL">2</tt>
          for each shift position)</p></dd><dt><span class="TOKEN">&lt;&lt;=</span></dt><dd><p><i class="FIRSTTERM">left-shift-equal</i></p><p><tt class="USERINPUT"><b>let "var &lt;&lt;= 2"</b></tt> results in <tt class="PARAMETER"><i>var</i></tt>
        left-shifted <tt class="LITERAL">2</tt> bits (multiplied by <tt class="LITERAL">4</tt>)</p></dd><dt><span class="TOKEN">&gt;&gt;</span></dt><dd><p>bitwise right shift (divides by <tt class="LITERAL">2</tt>
          for each shift position)</p></dd><dt><span class="TOKEN">&gt;&gt;=</span></dt><dd><p><i class="FIRSTTERM">right-shift-equal</i>
        (inverse of <span class="TOKEN">&lt;&lt;=</span>)</p></dd><dt><span class="TOKEN">&amp;</span></dt><dd><p>bitwise AND</p></dd><dt><span class="TOKEN">&amp;=</span></dt><dd><p>bitwise <i class="FIRSTTERM">AND-equal</i></p></dd><dt><span class="TOKEN">|</span></dt><dd><p>bitwise OR</p></dd><dt><span class="TOKEN">|=</span></dt><dd><p>bitwise <i class="FIRSTTERM">OR-equal</i></p></dd><dt><span class="TOKEN">~</span></dt><dd><p>bitwise NOT</p></dd><dt><span class="TOKEN">^</span></dt><dd><p>bitwise XOR</p></dd><dt><span class="TOKEN">^=</span></dt><dd><p>bitwise <i class="FIRSTTERM">XOR-equal</i></p></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="LOGOPS1"></a>logical (boolean) operators</b></p><dl><dt><span class="TOKEN">!</span></dt><dd><p>NOT</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">if [ ! -f $FILENAME ]
  then
    ...</pre></font></td></tr></tbody></table></p></dd><dt><span class="TOKEN">&amp;&amp;</span></dt><dd><p>AND</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">if [ $condition1 ] &amp;&amp; [ $condition2 ]
  #  Same as:  if [ $condition1 -a $condition2 ]
  #  Returns true if both condition1 and condition2 hold true...
  
  if [[ $condition1 &amp;&amp; $condition2 ]]    # Also works.
  #  Note that &amp;&amp; operator not permitted <em>inside brackets</em>
  #+ of [ ... ] construct.</pre></font></td></tr></tbody></table></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p><span class="TOKEN">&amp;&amp;</span> may also be used, depending on context,
        in an <a href="#LISTCONSREF">and list</a>
        to concatenate commands.</p></td></tr></tbody></table></div></dd><dt><a name="ORREF"></a><span class="TOKEN">||</span></dt><dd><p>OR</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">if [ $condition1 ] || [ $condition2 ]
  # Same as:  if [ $condition1 -o $condition2 ]
  # Returns true if either condition1 or condition2 holds true...
  
  if [[ $condition1 || $condition2 ]]    # Also works.
  #  Note that || operator not permitted <em>inside brackets</em>
  #+ of a [ ... ] construct.</pre></font></td></tr></tbody></table></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>Bash tests the <a href="#EXITSTATUSREF">exit
        status</a> of each statement linked with a logical
        operator.</p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="ANDOR"></a><p><b>Example 8-3. Compound Condition Tests Using &amp;&amp; and ||</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  a=24
  b=47
  
  if [ "$a" -eq 24 ] &amp;&amp; [ "$b" -eq 47 ]
  then
    echo "Test #1 succeeds."
  else
    echo "Test #1 fails."
  fi
  
  # ERROR:   if [ "$a" -eq 24 &amp;&amp; "$b" -eq 47 ]
  #+         attempts to execute  ' [ "$a" -eq 24 '
  #+         and fails to finding matching ']'.
  #
  #  Note:  if [[ $a -eq 24 &amp;&amp; $b -eq 24 ]]  works.
  #  The double-bracket if-test is more flexible
  #+ than the single-bracket version.       
  #    (The "&amp;&amp;" has a different meaning in line 17 than in line 6.)
  #    Thanks, Stephane Chazelas, for pointing this out.
  
  
  if [ "$a" -eq 98 ] || [ "$b" -eq 47 ]
  then
    echo "Test #2 succeeds."
  else
    echo "Test #2 fails."
  fi
  
  
  #  The -a and -o options provide
  #+ an alternative compound condition test.
  #  Thanks to Patrick Callahan for pointing this out.
  
  
  if [ "$a" -eq 24 -a "$b" -eq 47 ]
  then
    echo "Test #3 succeeds."
  else
    echo "Test #3 fails."
  fi
  
  
  if [ "$a" -eq 98 -o "$b" -eq 47 ]
  then
    echo "Test #4 succeeds."
  else
    echo "Test #4 fails."
  fi
  
  
  a=rhino
  b=crocodile
  if [ "$a" = rhino ] &amp;&amp; [ "$b" = crocodile ]
  then
    echo "Test #5 succeeds."
  else
    echo "Test #5 fails."
  fi
  
  exit 0</pre></font></td></tr></tbody></table></div><p>The <span class="TOKEN">&amp;&amp;</span> and <span class="TOKEN">||</span> operators also
          find use in an arithmetic context.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $(( 1 &amp;&amp; 2 )) $((3 &amp;&amp; 0)) $((4 || 0)) $((0 || 0))</b></tt>
  <tt class="COMPUTEROUTPUT">1 0 1 0</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="MISCOP1"></a>miscellaneous operators</b></p><dl><dt><a name="COMMAOP"></a><span class="TOKEN">,</span></dt><dd><p>Comma operator</p><p>The <b class="COMMAND">comma operator</b> chains together
          two or more arithmetic operations. All the operations are
          evaluated (with possible <i class="FIRSTTERM">side
          effects</i>.
            <a name="AEN4242" href="#FTN.AEN4242"><span class="footnote">[39]</span></a>
               </p><p>	     <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">let "t1 = ((5 + 3, 7 - 1, 15 - 4))"
  echo "t1 = $t1"           ^^^^^^  # t1 = 11
  # Here t1 is set to the result of the last operation. Why?
  
  let "t2 = ((a = 9, 15 / 3))"      # Set "a" and calculate "t2".
  echo "t2 = $t2    a = $a"         # t2 = 5    a = 9</pre></font></td></tr></tbody></table>
         </p><p>The comma operator finds use mainly in <a href="#FORLOOPREF1">for loops</a>. See <a href="#FORLOOPC">Example 11-13</a>.</p></dd></dl></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="NUMERICAL-CONSTANTS"></a>8.2. Numerical Constants</h1><p><a name="NUMCONSTANTS"></a>A shell script interprets a number
    as decimal (base 10), unless that number has a
    special prefix or notation. A number preceded by a
    <tt class="REPLACEABLE"><i>0</i></tt> is <tt class="REPLACEABLE"><i>octal</i></tt>
    (base 8). A number preceded by <tt class="REPLACEABLE"><i>0x</i></tt>
    is <tt class="REPLACEABLE"><i>hexadecimal</i></tt> (base 16). A number
    with an embedded <tt class="REPLACEABLE"><i>#</i></tt> evaluates as
    <tt class="REPLACEABLE"><i>BASE#NUMBER</i></tt> (with range and notational
    restrictions).</p><div class="EXAMPLE"><a name="NUMBERS"></a><p><b>Example 8-4. Representation of numerical constants</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # numbers.sh: Representation of numbers in different bases.
  
  # Decimal: the default
  let "dec = 32"
  echo "decimal number = $dec"             # 32
  # Nothing out of the ordinary here.
  
  
  # Octal: numbers preceded by '0' (zero)
  let "oct = 032"
  echo "octal number = $oct"               # 26
  # Expresses result in decimal.
  # --------- ------ -- -------
  
  
  # Hexadecimal: numbers preceded by '0x' or '0X'
  let "hex = 0x32"
  echo "hexadecimal number = $hex"         # 50
  
  echo $((0x9abc))                         # 39612
  #     ^^      ^^   double-parentheses arithmetic expansion/evaluation
  # Expresses result in decimal.
  
  
  
  # Other bases: BASE#NUMBER
  # BASE between 2 and 64.
  # NUMBER must use symbols within the BASE range, see below.
  
  
  let "bin = 2#111100111001101"
  echo "binary number = $bin"              # 31181
  
  let "b32 = 32#77"
  echo "base-32 number = $b32"             # 231
  
  let "b64 = 64#@_"
  echo "base-64 number = $b64"             # 4031
  # This notation only works for a limited range (2 - 64) of ASCII characters.
  # 10 digits + 26 lowercase characters + 26 uppercase characters + @ + _
  
  
  echo
  
  echo $((36#zz)) $((2#10101010)) $((16#AF16)) $((53#1aA))
                                           # 1295 170 44822 3375
  
  
  #  Important note:
  #  --------------
  #  Using a digit out of range of the specified base notation
  #+ gives an error message.
  
  let "bad_oct = 081"
  # (Partial) error message output:
  #  bad_oct = 081: value too great for base (error token is "081")
  #              Octal numbers use only digits in the range 0 - 7.
  
  exit $?   # Exit value = 1 (error)
  
  # Thanks, Rich Bartell and Stephane Chazelas, for clarification.</pre></font></td></tr></tbody></table></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="DBLPARENS"></a>8.3. The Double-Parentheses Construct</h1><p><a name="DBLPARENSREF"></a></p><p>Similar to the <a href="#LETREF">let</a> command,
      the <b class="COMMAND">(( ... ))</b> construct permits
      arithmetic expansion and evaluation. In its simplest
      form, <tt class="USERINPUT"><b>a=$(( 5 + 3 ))</b></tt> would set
      <tt class="USERINPUT"><b>a</b></tt> to <tt class="USERINPUT"><b>5 + 3</b></tt>, or
      <tt class="USERINPUT"><b>8</b></tt>. However, this double-parentheses
      construct is also a mechanism for allowing C-style
      manipulation of variables in Bash, for example,
      <tt class="VARNAME">(( var++ ))</tt>.</p><p><a name="PLUSPLUSREF"></a></p><div class="EXAMPLE"><a name="CVARS"></a><p><b>Example 8-5. C-style manipulation of variables</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # c-vars.sh
  # Manipulating a variable, C-style, using the (( ... )) construct.
  
  
  echo
  
  (( a = 23 ))  #  Setting a value, C-style,
                #+ with spaces on both sides of the "=".
  echo "a (initial value) = $a"   # 23
  
  (( a++ ))     #  Post-increment 'a', C-style.
  echo "a (after a++) = $a"       # 24
  
  (( a-- ))     #  Post-decrement 'a', C-style.
  echo "a (after a--) = $a"       # 23
  
  
  (( ++a ))     #  Pre-increment 'a', C-style.
  echo "a (after ++a) = $a"       # 24
  
  (( --a ))     #  Pre-decrement 'a', C-style.
  echo "a (after --a) = $a"       # 23
  
  echo
  
  ########################################################
  #  Note that, as in C, pre- and post-decrement operators
  #+ have different side-effects.
  
  n=1; let --n &amp;&amp; echo "True" || echo "False"  # False
  n=1; let n-- &amp;&amp; echo "True" || echo "False"  # True
  
  #  Thanks, Jeroen Domburg.
  ########################################################
  
  echo
  
  (( t = a&lt;45?7:11 ))   # C-style trinary operator.
  #       ^  ^ ^
  echo "If a &lt; 45, then t = 7, else t = 11."  # a = 23
  echo "t = $t "                              # t = 7
  
  echo
  
  
  # -----------------
  # Easter Egg alert!
  # -----------------
  #  Chet Ramey seems to have snuck a bunch of undocumented C-style
  #+ constructs into Bash (actually adapted from ksh, pretty much).
  #  In the Bash docs, Ramey calls (( ... )) shell arithmetic,
  #+ but it goes far beyond that.
  #  Sorry, Chet, the secret is out.
  
  # See also "for" and "while" loops using the (( ... )) construct.
  
  # These work only with version 2.04 or later of Bash.
  
  exit</pre></font></td></tr></tbody></table></div><p>See also <a href="#FORLOOPC">Example 11-13</a> and <a href="#NUMBERS">Example 8-4</a>.</p></div><div class="SECT1"><hr><h1 class="SECT1"><a name="OPPRECEDENCE"></a>8.4. Operator Precedence</h1><p><a name="OPPRECEDENCE1"></a></p><p>        In a script, operations execute in order of
          <i class="FIRSTTERM">precedence</i>: the higher precedence operations
    execute <em>before</em> the lower precedence ones.
      <a name="AEN4290" href="#FTN.AEN4290"><span class="footnote">[40]</span></a>
        </p><div class="TABLE"><a name="AEN4294"></a><p><b>Table 8-1. Operator Precedence</b></p><table border="1" class="CALSTABLE"><thead><tr><th align="LEFT" valign="TOP">Operator</th><th align="LEFT" valign="TOP">Meaning</th><th align="LEFT" valign="TOP">Comments</th></tr></thead><tbody><tr><td align="LEFT" valign="TOP"><tt class="OPTION"></tt></td><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP"><b class="COMMAND">HIGHEST PRECEDENCE</b></td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">var++ var--</tt></td><td align="LEFT" valign="TOP">post-increment, post-decrement</td><td align="LEFT" valign="TOP"><a href="#CSTYLE">C-style</a> operators</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">++var --var</tt></td><td align="LEFT" valign="TOP">pre-increment, pre-decrement</td><td align="LEFT" valign="TOP">&nbsp;</td></tr><tr><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">! ~</tt></td><td align="LEFT" valign="TOP"><a href="#NOTREF">negation</a></td><td align="LEFT" valign="TOP">logical / bitwise, inverts sense of following
            operator</td></tr><tr><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">**</tt></td><td align="LEFT" valign="TOP"><a href="#EXPONENTIATIONREF">exponentiation</a></td><td align="LEFT" valign="TOP"><a href="#AROPS1">arithmetic
            operation</a></td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">* / %</tt></td><td align="LEFT" valign="TOP">multiplication, division, modulo</td><td align="LEFT" valign="TOP">arithmetic operation</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">+ -</tt></td><td align="LEFT" valign="TOP">addition, subtraction</td><td align="LEFT" valign="TOP">arithmetic operation</td></tr><tr><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">&lt;&lt; &gt;&gt;</tt></td><td align="LEFT" valign="TOP">left, right shift</td><td align="LEFT" valign="TOP"><a href="#BITWSOPS1">bitwise</a></td></tr><tr><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">-z -n</tt></td><td align="LEFT" valign="TOP"><i class="FIRSTTERM">unary</i> comparison</td><td align="LEFT" valign="TOP">string is/is-not <a href="#STRINGNULL">null</a></td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">-e -f -t -x, etc.</tt></td><td align="LEFT" valign="TOP"><i class="FIRSTTERM">unary</i> comparison</td><td align="LEFT" valign="TOP"><a href="#FTO">file-test</a></td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">&lt; -lt &gt; -gt &lt;= -le &gt;= -ge</tt></td><td align="LEFT" valign="TOP"><i class="FIRSTTERM">compound</i> comparison</td><td align="LEFT" valign="TOP">string and integer</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">-nt -ot -ef</tt></td><td align="LEFT" valign="TOP"><i class="FIRSTTERM">compound</i> comparison</td><td align="LEFT" valign="TOP">file-test</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">== -eq <a href="#NOTEQUAL">!=</a>
           -ne</tt></td><td align="LEFT" valign="TOP">equality / inequality</td><td align="LEFT" valign="TOP">test operators, string and integer</td></tr><tr><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">&amp;</tt></td><td align="LEFT" valign="TOP">AND</td><td align="LEFT" valign="TOP">bitwise</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">^</tt></td><td align="LEFT" valign="TOP">XOR</td><td align="LEFT" valign="TOP"><i class="FIRSTTERM">exclusive</i> OR, bitwise</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">|</tt></td><td align="LEFT" valign="TOP">OR</td><td align="LEFT" valign="TOP">bitwise</td></tr><tr><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">&amp;&amp; -a</tt></td><td align="LEFT" valign="TOP">AND</td><td align="LEFT" valign="TOP"><a href="#LOGOPS1">logical</a>,
            <i class="FIRSTTERM">compound</i>
            comparison</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">|| -o</tt></td><td align="LEFT" valign="TOP">OR</td><td align="LEFT" valign="TOP">logical, <i class="FIRSTTERM">compound</i>
            comparison</td></tr><tr><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">?:</tt></td><td align="LEFT" valign="TOP"><a href="#CSTRINARY">trinary
            operator</a></td><td align="LEFT" valign="TOP">C-style</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">=</tt></td><td align="LEFT" valign="TOP"><a href="#EQREF">assignment</a></td><td align="LEFT" valign="TOP">(do not confuse with equality
            <i class="FIRSTTERM">test</i>)</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">*= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;=</tt></td><td align="LEFT" valign="TOP"><a href="#ARITHOPSCOMB">combination
            assignment</a></td><td align="LEFT" valign="TOP">times-equal, divide-equal, mod-equal, etc.</td></tr><tr><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP">&nbsp;</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">,</tt></td><td align="LEFT" valign="TOP"><a href="#COMMAOP">comma</a></td><td align="LEFT" valign="TOP">links a sequence of operations</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION"></tt></td><td align="LEFT" valign="TOP">&nbsp;</td><td align="LEFT" valign="TOP"><b class="COMMAND">LOWEST PRECEDENCE</b></td></tr></tbody></table></div><p>In practice, all you really need to remember is the
        following:</p><p></p><ul><li><p>The <span class="QUOTE">"My Dear Aunt Sally"</span> mantra (<em>multiply,
      divide, add, subtract</em>) for the familiar <a href="#AROPS1">arithmetic operations</a>.</p></li><li><p>The <i class="FIRSTTERM">compound</i> logical operators,
      <b class="COMMAND">&amp;&amp;</b>, <b class="COMMAND">||</b>, <b class="COMMAND">-a</b>,
      and <b class="COMMAND">-o</b> have low precedence.</p></li><li><p>The order of evaluation of equal-precedence operators is
      usually <i class="FIRSTTERM">left-to-right</i>.</p></li></ul><p>Now, let's utilize our knowledge of operator precedence to
      analyze a couple of lines from the
      <tt class="FILENAME">/etc/init.d/functions file</tt>, as found in
      the <i class="FIRSTTERM">Fedora Core</i> Linux distro.</p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">while [ -n "$remaining" -a "$retry" -gt 0 ]; do
  
  # This looks rather daunting at first glance.
  
  
  # Separate the conditions:
  while [ -n "$remaining" -a "$retry" -gt 0 ]; do
  #       --condition 1-- ^^ --condition 2-
  
  #  If variable "$remaining" is not zero length
  #+      AND (-a)
  #+ variable "$retry" is greater-than zero
  #+ then
  #+ the [ expresion-within-condition-brackets ] returns success (0)
  #+ and the while-loop executes an iteration.
  #  ==============================================================
  #  Evaluate "condition 1" and "condition 2" ***before***
  #+ ANDing them. Why? Because the AND (-a) has a lower precedence
  #+ than the -n and -gt operators,
  #+ and therefore gets evaluated *last*.
  
  #################################################################
  
  if [ -f /etc/sysconfig/i18n -a -z "${NOLOCALE:-}" ] ; then
  
  
  # Again, separate the conditions:
  if [ -f /etc/sysconfig/i18n -a -z "${NOLOCALE:-}" ] ; then
  #    --condition 1--------- ^^ --condition 2-----
  
  #  If file "/etc/sysconfig/i18n" exists
  #+      AND (-a)
  #+ variable $NOLOCALE is zero length
  #+ then
  #+ the [ test-expresion-within-condition-brackets ] returns success (0)
  #+ and the commands following execute.
  #
  #  As before, the AND (-a) gets evaluated *last*
  #+ because it has the lowest precedence of the operators within
  #+ the test brackets.
  #  ==============================================================
  #  Note:
  #  ${NOLOCALE:-} is a parameter expansion that seems redundant.
  #  But, if $NOLOCALE has not been declared, it gets set to *null*,
  #+ in effect declaring it.
  #  This makes a difference in some contexts.</pre></font></td></tr></tbody></table></p><div class="TIP"><p></p><table class="TIP" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>To avoid confusion or error in a complex sequence of test
          operators, break up the sequence into bracketed sections.
        <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">if [ "$v1" -gt "$v2"  -o  "$v1" -lt "$v2"  -a  -e "$filename" ]
  # Unclear what's going on here...
  
  if [[ "$v1" -gt "$v2" ]] || [[ "$v1" -lt "$v2" ]] &amp;&amp; [[ -e "$filename" ]]
  # Much better -- the condition tests are grouped in logical sections.</pre></font></td></tr></tbody></table>
        </p></td></tr></tbody></table></div></div></div></div><div class="PART"><a name="PART3"></a><div class="TITLEPAGE"><h1 class="TITLE">Part 3. Beyond the Basics</h1><div class="TOC"><dl><dt><b>Table of Contents</b></dt><dt>9. <a href="#VARIABLES2">Another Look at Variables</a></dt><dd><dl><dt>9.1. <a href="#INTERNALVARIABLES">Internal Variables</a></dt><dt>9.2. <a href="#DECLAREREF">Typing variables: <b class="COMMAND">declare</b> or
      <b class="COMMAND">typeset</b></a></dt><dt>9.3. <a href="#RANDOMVAR">$RANDOM: generate random integer</a></dt></dl></dd><dt>10. <a href="#MANIPULATINGVARS">Manipulating Variables</a></dt><dd><dl><dt>10.1. <a href="#STRING-MANIPULATION">Manipulating Strings</a></dt><dt>10.2. <a href="#PARAMETER-SUBSTITUTION">Parameter Substitution</a></dt></dl></dd><dt>11. <a href="#LOOPS">Loops and Branches</a></dt><dd><dl><dt>11.1. <a href="#LOOPS1">Loops</a></dt><dt>11.2. <a href="#NESTEDLOOPS">Nested Loops</a></dt><dt>11.3. <a href="#LOOPCONTROL">Loop Control</a></dt><dt>11.4. <a href="#TESTBRANCH">Testing and Branching</a></dt></dl></dd><dt>12. <a href="#COMMANDSUB">Command Substitution</a></dt><dt>13. <a href="#ARITHEXP">Arithmetic Expansion</a></dt><dt>14. <a href="#RECESS-TIME">Recess Time</a></dt></dl></div></div><div class="CHAPTER"><hr><h1><a name="VARIABLES2"></a>Chapter 9. Another Look at Variables</h1><p>Used properly, variables can add power and flexibility
      to scripts. This requires learning their subtleties and
      nuances.</p><div class="SECT1"><hr><h1 class="SECT1"><a name="INTERNALVARIABLES"></a>9.1. Internal Variables</h1><p></p><div class="VARIABLELIST"><dl><dt><tt class="REPLACEABLE"><i><a href="#BUILTINREF">Builtin</a> variables:</i></tt></dt><dd><p>variables affecting bash script behavior</p></dd><dt><a name="BASHVARREF"></a><tt class="VARNAME">$BASH</tt></dt><dd><p>The path to the <i class="FIRSTTERM">Bash</i>
        binary itself
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $BASH</b></tt>
  <tt class="COMPUTEROUTPUT">/bin/bash</tt></pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="BASHENVREF"></a><tt class="VARNAME">$BASH_ENV</tt></dt><dd><p>An <a href="#ENVREF">environmental
      variable</a> pointing to a Bash startup file to be read
      when a script is invoked</p></dd><dt><a name="BASHSUBSHELLREF"></a><tt class="VARNAME">$BASH_SUBSHELL</tt></dt><dd><p>A variable indicating the <a href="#SUBSHELLSREF">subshell</a> level. This is a
          new addition to Bash, <a href="#BASH3REF">version 3</a>.</p><p>See <a href="#SUBSHELL">Example 21-1</a> for usage.</p></dd><dt><a name="BASHPIDREF"></a><tt class="VARNAME">$BASHPID</tt></dt><dd><p><i class="FIRSTTERM">Process ID</i>
              of the current instance of Bash. This is not the same as the
              <a href="#PROCCID">$$</a> variable, but it often
              gives the same result.</p><p>		  <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash4$ </tt><tt class="USERINPUT"><b>echo $$</b></tt>
  <tt class="COMPUTEROUTPUT">11015</tt>
  
  
  <tt class="PROMPT">bash4$ </tt><tt class="USERINPUT"><b>echo $BASHPID</b></tt>
  <tt class="COMPUTEROUTPUT">11015</tt>
  
  
  <tt class="PROMPT">bash4$ </tt><tt class="USERINPUT"><b>ps ax | grep bash4</b></tt>
  <tt class="COMPUTEROUTPUT">11015 pts/2    R      0:00 bash4</tt>
          </pre></font></td></tr></tbody></table>
        </p><p><a name="BASHPIDREF2"></a>But ...</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash4
  
  echo "\$\$ outside of subshell = $$"                              # 9602
  echo "\$BASH_SUBSHELL  outside of subshell = $BASH_SUBSHELL"      # 0
  echo "\$BASHPID outside of subshell = $BASHPID"                   # 9602
  
  echo
  
  ( echo "\$\$ inside of subshell = $$"                             # 9602
    echo "\$BASH_SUBSHELL inside of subshell = $BASH_SUBSHELL"      # 1
    echo "\$BASHPID inside of subshell = $BASHPID" )                # 9603
    # Note that $$ returns PID of parent process.</pre></font></td></tr></tbody></table></p></dd><dt><tt class="VARNAME">$BASH_VERSINFO[n]</tt></dt><dd><p>A 6-element <a href="#ARRAYREF">array</a>
        containing version information about the installed release
        of Bash. This is similar to <tt class="VARNAME">$BASH_VERSION</tt>,
        below, but a bit more detailed.</p><p>	  <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Bash version info:
  
  for n in 0 1 2 3 4 5
  do
    echo "BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}"
  done  
  
  # BASH_VERSINFO[0] = 3                      # Major version no.
  # BASH_VERSINFO[1] = 00                     # Minor version no.
  # BASH_VERSINFO[2] = 14                     # Patch level.
  # BASH_VERSINFO[3] = 1                      # Build version.
  # BASH_VERSINFO[4] = release                # Release status.
  # BASH_VERSINFO[5] = i386-redhat-linux-gnu  # Architecture
                                              # (same as $MACHTYPE).</pre></font></td></tr></tbody></table>
      </p></dd><dt><tt class="VARNAME">$BASH_VERSION</tt></dt><dd><p>The version of Bash installed on the system</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $BASH_VERSION</b></tt>
  <tt class="COMPUTEROUTPUT">3.2.25(1)-release</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">tcsh% </tt><tt class="USERINPUT"><b>echo $BASH_VERSION</b></tt>
  <tt class="COMPUTEROUTPUT">BASH_VERSION: Undefined variable.</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>Checking $BASH_VERSION is a good method of determining which
        shell is running. <a href="#SHELLVARREF">$SHELL</a>
        does not necessarily give the correct answer.</p></dd><dt><a name="CDPATHREF"></a><tt class="VARNAME">$CDPATH</tt></dt><dd><p>A colon-separated list of search paths
        available to the <a href="#CDREF">cd</a>
        command, similar in function to the <a href="#PATHREF">$PATH</a> variable for binaries.
              The <tt class="VARNAME">$CDPATH</tt> variable may be set in the
        local <a href="#BASHRC"><tt class="FILENAME">~/.bashrc</tt></a>
        file.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cd bash-doc</b></tt>
  <tt class="COMPUTEROUTPUT">bash: cd: bash-doc: No such file or directory</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>CDPATH=/usr/share/doc</b></tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cd bash-doc</b></tt>
  <tt class="COMPUTEROUTPUT">/usr/share/doc/bash-doc</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $PWD</b></tt>
  <tt class="COMPUTEROUTPUT">/usr/share/doc/bash-doc</tt>
          </pre></font></td></tr></tbody></table>
             </p></dd><dt><a name="DIRSTACKREF"></a><tt class="VARNAME">$DIRSTACK</tt></dt><dd><p>The top value in the directory stack
  
                <a name="AEN4671" href="#FTN.AEN4671"><span class="footnote">[41]</span></a>
  
        (affected by <a href="#PUSHDREF">pushd</a> and <a href="#POPDREF">popd</a>)</p><p>This builtin
        variable corresponds to the <a href="#DIRSD">dirs</a>
        command, however <b class="COMMAND">dirs</b> shows the entire
        contents of the directory stack.</p></dd><dt><tt class="VARNAME">$EDITOR</tt></dt><dd><p>The default editor invoked by a script, usually
          <b class="COMMAND">vi</b> or <b class="COMMAND">emacs</b>.</p></dd><dt><a name="EUIDREF"></a><tt class="VARNAME">$EUID</tt></dt><dd><p><span class="QUOTE">"effective"</span> user ID number</p><p>Identification number of whatever identity the
          current user has assumed, perhaps by means of <a href="#SUREF">su</a>.</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>The <tt class="VARNAME">$EUID</tt> is not necessarily
          the same as the <a href="#UIDREF">$UID</a>.</p></td></tr></tbody></table></div></dd><dt><tt class="VARNAME">$FUNCNAME</tt></dt><dd><p>Name of the current function</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">xyz23 ()
  {
    echo "$FUNCNAME now executing."  # xyz23 now executing.
  }
  
  xyz23
  
  echo "FUNCNAME = $FUNCNAME"        # FUNCNAME =
                                     # Null value outside a function.</pre></font></td></tr></tbody></table>
              </p><p>See also <a href="#USEGETOPT">Example A-50</a>.</p></dd><dt><tt class="VARNAME">$GLOBIGNORE</tt></dt><dd><p>A list of filename patterns to be excluded from
        matching in <a href="#GLOBBINGREF">globbing</a>.</p></dd><dt><a name="GROUPSREF"></a><tt class="VARNAME">$GROUPS</tt></dt><dd><p>Groups current user belongs to</p><p>This is a listing (array) of the group id numbers for
          current user, as  recorded in
          <a href="#DATAFILESREF1"><tt class="FILENAME">/etc/passwd</tt></a>
          and <tt class="FILENAME">/etc/group</tt>.
        </p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">root# </tt><tt class="USERINPUT"><b>echo $GROUPS</b></tt>
  <tt class="COMPUTEROUTPUT">0</tt>
  
  
  <tt class="PROMPT">root# </tt><tt class="USERINPUT"><b>echo ${GROUPS[1]}</b></tt>
  <tt class="COMPUTEROUTPUT">1</tt>
  
  
  <tt class="PROMPT">root# </tt><tt class="USERINPUT"><b>echo ${GROUPS[5]}</b></tt>
  <tt class="COMPUTEROUTPUT">6</tt>
          </pre></font></td></tr></tbody></table>
          </p></dd><dt><a name="HOMEDIRREF"></a><tt class="VARNAME">$HOME</tt></dt><dd><p>Home directory of the user, usually <tt class="FILENAME">/home/username</tt> (see <a href="#EX6">Example 10-7</a>)</p></dd><dt><a name="HOSTNAMEREF"></a><tt class="VARNAME">$HOSTNAME</tt></dt><dd><p>The <a href="#HNAMEREF">hostname</a> command
        assigns the system host name at bootup in an init script.
        However, the <tt class="FUNCTION">gethostname()</tt> function
        sets the Bash internal variable <tt class="VARNAME">$HOSTNAME</tt>.
        See also <a href="#EX6">Example 10-7</a>.</p></dd><dt><tt class="VARNAME">$HOSTTYPE</tt></dt><dd><p>host type</p><p>Like <a href="#MACHTYPEREF">$MACHTYPE</a>,
          identifies the system hardware.</p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $HOSTTYPE</b></tt>
  <tt class="COMPUTEROUTPUT">i686</tt></pre></font></td></tr></tbody></table></dd><dt><a name="IFSREF"></a><tt class="VARNAME">$IFS</tt></dt><dd><p>internal field separator</p><p>This variable determines how Bash recognizes <a href="#FIELDREF">fields</a>, or word boundaries,
          when it interprets character strings.</p><p><a name="IFSWS"></a></p><p>$IFS defaults to <a href="#WHITESPACEREF">whitespace</a> (space,
          tab, and newline), but may be changed, for example,
          to parse a comma-separated data file. Note that
          <a href="#APPREF">$*</a> uses the first
          character held in <tt class="VARNAME">$IFS</tt>. See <a href="#WEIRDVARS">Example 5-1</a>.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo "$IFS"</b></tt>
  <tt class="COMPUTEROUTPUT"></tt>
  <tt class="COMPUTEROUTPUT">(With $IFS set to default, a blank line displays.)</tt>
          
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo "$IFS" | cat -vte</b></tt>
  <tt class="COMPUTEROUTPUT"> ^I$
   $</tt>
  <tt class="COMPUTEROUTPUT">(Show whitespace: here a single space, ^I [horizontal tab],
    and newline, and display "$" at end-of-line.)</tt>
  
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>bash -c 'set w x y z; IFS=":-;"; echo "$*"'</b></tt>
  <tt class="COMPUTEROUTPUT">w:x:y:z</tt>
  <tt class="COMPUTEROUTPUT">(Read commands from string and assign any arguments to pos params.)</tt>
          </pre></font></td></tr></tbody></table>
      </p><p>Set <tt class="VARNAME">$IFS</tt> to eliminate whitespace
        in <a href="#PATHNAMEREF">pathnames</a>.
  <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">IFS="$(printf '\n\t')"   # Per David Wheeler.</pre></font></td></tr></tbody></table>
      </p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p><tt class="VARNAME">$IFS</tt> does not handle whitespace
        the same as it does other characters.
  
      </p><div class="EXAMPLE"><a name="IFSH"></a><p><b>Example 9-1. $IFS and whitespace</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # ifs.sh
  
  
  var1="a+b+c"
  var2="d-e-f"
  var3="g,h,i"
  
  IFS=+
  # The plus sign will be interpreted as a separator.
  echo $var1     # a b c
  echo $var2     # d-e-f
  echo $var3     # g,h,i
  
  echo
  
  IFS="-"
  # The plus sign reverts to default interpretation.
  # The minus sign will be interpreted as a separator.
  echo $var1     # a+b+c
  echo $var2     # d e f
  echo $var3     # g,h,i
  
  echo
  
  IFS=","
  # The comma will be interpreted as a separator.
  # The minus sign reverts to default interpretation.
  echo $var1     # a+b+c
  echo $var2     # d-e-f
  echo $var3     # g h i
  
  echo
  
  IFS=" "
  # The space character will be interpreted as a separator.
  # The comma reverts to default interpretation.
  echo $var1     # a+b+c
  echo $var2     # d-e-f
  echo $var3     # g,h,i
  
  # ======================================================== #
  
  # However ...
  # $IFS treats whitespace differently than other characters.
  
  output_args_one_per_line()
  {
    for arg
    do
      echo "[$arg]"
    done #  ^    ^   Embed within brackets, for your viewing pleasure.
  }
  
  echo; echo "IFS=\" \""
  echo "-------"
  
  IFS=" "
  var=" a  b c   "
  #    ^ ^^   ^^^
  output_args_one_per_line $var  # output_args_one_per_line `echo " a  b c   "`
  # [a]
  # [b]
  # [c]
  
  
  echo; echo "IFS=:"
  echo "-----"
  
  IFS=:
  var=":a::b:c:::"               # Same pattern as above,
  #    ^ ^^   ^^^                #+ but substituting ":" for " "  ...
  output_args_one_per_line $var
  # []
  # [a]
  # []
  # [b]
  # [c]
  # []
  # []
  
  # Note "empty" brackets.
  # The same thing happens with the "FS" field separator in awk.
  
  
  echo
  
  exit</pre></font></td></tr></tbody></table></div>
  
      <p></p></td></tr></tbody></table></div><p>(Many thanks, StÃ©phane Chazelas, for clarification
      and above examples.)</p><p>See also <a href="#ISSPAMMER">Example 16-41</a>, <a href="#BINGREP">Example 11-8</a>, and <a href="#MAILBOXGREP">Example 19-14</a>
               for instructive examples of using
               <tt class="VARNAME">$IFS</tt>.</p></dd><dt><tt class="VARNAME">$IGNOREEOF</tt></dt><dd><p>Ignore EOF: how many end-of-files (control-D)
        the shell will ignore before logging out.</p></dd><dt><tt class="VARNAME">$LC_COLLATE</tt></dt><dd><p>Often set in the <a href="#SAMPLE-BASHRC"><tt class="FILENAME">.bashrc</tt></a>
        or <tt class="FILENAME">/etc/profile</tt> files, this
        variable controls collation order in filename
        expansion and pattern matching. If mishandled,
        <tt class="VARNAME">LC_COLLATE</tt> can cause unexpected results in
        <a href="#GLOBBINGREF">filename globbing</a>.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>As of version 2.05 of Bash,
        filename globbing no longer distinguishes between lowercase
        and uppercase letters in a character range between
        brackets. For example, <b class="COMMAND">ls [A-M]*</b>
        would match both <tt class="FILENAME">File1.txt</tt>
        and <tt class="FILENAME">file1.txt</tt>. To revert to
        the customary behavior of bracket matching, set
        <tt class="VARNAME">LC_COLLATE</tt> to <tt class="OPTION">C</tt>
        by an <tt class="USERINPUT"><b>export LC_COLLATE=C</b></tt>
        in <tt class="FILENAME">/etc/profile</tt> and/or
        <tt class="FILENAME">~/.bashrc</tt>.</p></td></tr></tbody></table></div></dd><dt><tt class="VARNAME">$LC_CTYPE</tt></dt><dd><p>This internal variable controls character interpretation
        in <a href="#GLOBBINGREF">globbing</a> and pattern
        matching.</p></dd><dt><a name="LINENOREF"></a><tt class="VARNAME">$LINENO</tt></dt><dd><p>This variable is the line number of the shell
        script in which this variable appears. It has significance only
        within the script in which it appears, and is chiefly useful for
        debugging purposes.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># *** BEGIN DEBUG BLOCK ***
  last_cmd_arg=$_  # Save it.
  
  echo "At line number $LINENO, variable \"v1\" = $v1"
  echo "Last command argument processed = $last_cmd_arg"
  # *** END DEBUG BLOCK ***</pre></font></td></tr></tbody></table></p></dd><dt><a name="MACHTYPEREF"></a><tt class="VARNAME">$MACHTYPE</tt></dt><dd><p>machine type</p><p>Identifies the system hardware.</p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $MACHTYPE</b></tt>
  <tt class="COMPUTEROUTPUT">i686</tt></pre></font></td></tr></tbody></table></dd><dt><a name="OLDPWD"></a><tt class="VARNAME">$OLDPWD</tt></dt><dd><p>Old working directory
      (<span class="QUOTE">"OLD-Print-Working-Directory"</span>,
        previous directory you were in).</p></dd><dt><tt class="VARNAME">$OSTYPE</tt></dt><dd><p>operating system type</p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $OSTYPE</b></tt>
  <tt class="COMPUTEROUTPUT">linux</tt></pre></font></td></tr></tbody></table></dd><dt><a name="PATHREF"></a><tt class="VARNAME">$PATH</tt></dt><dd><p>Path to binaries, usually 
          <tt class="FILENAME">/usr/bin/</tt>, 
          <tt class="FILENAME">/usr/X11R6/bin/</tt>, 
          <tt class="FILENAME">/usr/local/bin</tt>, etc.</p><p>When given a command, the shell automatically does
          a hash table search on the directories listed in the
          <i class="FIRSTTERM">path</i> for the executable. The path
          is stored in the <a href="#ENVREF">environmental
          variable</a>, <tt class="VARNAME">$PATH</tt>, a list
          of directories, separated by colons. Normally,
          the system stores the <tt class="VARNAME">$PATH</tt>
          definition in <tt class="FILENAME">/etc/profile</tt>
          and/or <a href="#SAMPLE-BASHRC"><tt class="FILENAME">~/.bashrc</tt></a>
          (see <a href="#FILES">Appendix H</a>).</p><p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><b class="COMMAND">echo $PATH</b>
  <tt class="COMPUTEROUTPUT">/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin</tt></pre></font></td></tr></tbody></table>
                </p><p><tt class="USERINPUT"><b>PATH=${PATH}:/opt/bin</b></tt> appends
          the <tt class="FILENAME">/opt/bin</tt>
          directory to the current path. In a script, it may be
          expedient to temporarily add a directory to the path
          in this way. When the script exits, this restores the
          original <tt class="VARNAME">$PATH</tt> (a child process, such
          as a script, may not change the environment of the parent
          process, the shell).</p><p><a name="CURRENTWDREF"></a></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The current <span class="QUOTE">"working directory"</span>, 
          <tt class="FILENAME">./</tt>, is usually
          omitted from the <tt class="VARNAME">$PATH</tt> as a security
          measure.</p></td></tr></tbody></table></div></dd><dt><a name="PIPESTATUSREF"></a><tt class="VARNAME">$PIPESTATUS</tt></dt><dd><p><a href="#ARRAYREF">Array</a> variable holding
              <a href="#EXITSTATUSREF">exit status</a>(es) of
        last executed <i class="FIRSTTERM">foreground</i> <a href="#PIPEREF">pipe</a>.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $PIPESTATUS</b></tt>
  <tt class="COMPUTEROUTPUT">0</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -al | bogus_command</b></tt>
  <tt class="COMPUTEROUTPUT">bash: bogus_command: command not found</tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo ${PIPESTATUS[1]}</b></tt>
  <tt class="COMPUTEROUTPUT">127</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -al | bogus_command</b></tt>
  <tt class="COMPUTEROUTPUT">bash: bogus_command: command not found</tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $?</b></tt>
  <tt class="COMPUTEROUTPUT">127</tt>
          </pre></font></td></tr></tbody></table>
          </p><p>The members of the <tt class="VARNAME">$PIPESTATUS</tt>
      array hold the exit status of each respective command
      executed in a pipe. <tt class="VARNAME">$PIPESTATUS[0]</tt>
      holds the exit status of the first command in the pipe,
      <tt class="VARNAME">$PIPESTATUS[1]</tt> the exit status of
      the second command, and so on.</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>	      The <tt class="VARNAME">$PIPESTATUS</tt> variable
                may contain an erroneous <span class="ERRORCODE">0</span> value
                in a login shell (in releases prior to 3.0 of Bash).
                </p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">tcsh% </tt><tt class="USERINPUT"><b>bash</b></tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>who | grep nobody | sort</b></tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo ${PIPESTATUS[*]}</b></tt>
  <tt class="COMPUTEROUTPUT">0</tt>
          </pre></font></td></tr></tbody></table>
          </p><p>	      The above lines contained in a script would produce the expected
          <tt class="COMPUTEROUTPUT">0 1 0</tt> output.
                </p><p>	      Thank you, Wayne Pollock for pointing this out and supplying the
          above example.
          </p></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <tt class="VARNAME">$PIPESTATUS</tt> variable gives
            unexpected results in some contexts.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $BASH_VERSION</b></tt>
  <tt class="COMPUTEROUTPUT">3.00.14(1)-release</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>$ ls | bogus_command | wc</b></tt>
  <tt class="COMPUTEROUTPUT">bash: bogus_command: command not found
   0       0       0</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo ${PIPESTATUS[@]}</b></tt>
  <tt class="COMPUTEROUTPUT">141 127 0</tt>
          </pre></font></td></tr></tbody></table>
          </p><p>Chet Ramey attributes the above output to the behavior of
      <a href="#LSREF">ls</a>. If <i class="FIRSTTERM">ls</i>
      writes to a <i class="FIRSTTERM">pipe</i> whose output is not
      read, then <tt class="REPLACEABLE"><i>SIGPIPE</i></tt> kills it,
      and its <a href="#EXITSTATUSREF">exit status</a>
      is <span class="RETURNVALUE">141</span>. Otherwise
      its exit status is <span class="RETURNVALUE">0</span>,
      as expected. This likewise is the case for <a href="#TRREF">tr</a>.</p></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p><tt class="VARNAME">$PIPESTATUS</tt> is a
          <span class="QUOTE">"volatile"</span> variable. It needs to be
          captured immediately after the pipe in question, before
          any other command intervenes.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>$ ls | bogus_command | wc</b></tt>
  <tt class="COMPUTEROUTPUT">bash: bogus_command: command not found
   0       0       0</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo ${PIPESTATUS[@]}</b></tt>
  <tt class="COMPUTEROUTPUT">0 127 0</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo ${PIPESTATUS[@]}</b></tt>
  <tt class="COMPUTEROUTPUT">0</tt>
          </pre></font></td></tr></tbody></table>
          </p></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <a href="#PIPEFAILREF">pipefail option</a>
          may be useful in cases where
          <tt class="VARNAME">$PIPESTATUS</tt> does not give the desired
          information.</p></td></tr></tbody></table></div></dd><dt><a name="PPIDREF"></a><tt class="VARNAME">$PPID</tt></dt><dd><p></p><p>The <tt class="VARNAME">$PPID</tt> of a process is
        the process ID (<tt class="VARNAME">pid</tt>) of its parent process.
  
          <a name="AEN5154" href="#FTN.AEN5154"><span class="footnote">[42]</span></a>
          </p><p>Compare this with the <a href="#PIDOFREF">pidof</a> command.</p></dd><dt><tt class="VARNAME">$PROMPT_COMMAND</tt></dt><dd><p>A variable holding a command to be executed
          just before the primary prompt, <tt class="VARNAME">$PS1</tt>
          is to be displayed.</p></dd><dt><a name="PS1REF"></a><tt class="VARNAME">$PS1</tt></dt><dd><p>This is the main prompt, seen at the command-line.</p></dd><dt><a name="SECPROMPTREF"></a><tt class="VARNAME">$PS2</tt></dt><dd><p>The secondary prompt, seen when additional input is
          expected. It displays as <span class="QUOTE">"&gt;"</span>.</p></dd><dt><tt class="VARNAME">$PS3</tt></dt><dd><p>The tertiary prompt, displayed in a
        <a href="#SELECTREF">select</a> loop (see <a href="#EX31">Example 11-30</a>).</p></dd><dt><tt class="VARNAME">$PS4</tt></dt><dd><p>The quartenary prompt, shown at the beginning of
        each line of output when invoking a script with the
        <span class="TOKEN">-x</span> <em>[verbose trace]</em>
        <a href="#OPTIONSREF">option</a>. It displays as
        <span class="QUOTE">"+"</span>.</p><p>As a debugging aid, it may be useful to embed diagnostic
        information in <tt class="VARNAME">$PS4</tt>.
  <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">P4='$(read time junk &lt; /proc/$$/schedstat; echo "@@@ $time @@@ " )'
  # Per suggestion by Erik Brandsberg.
  set -x
  # Various commands follow ...</pre></font></td></tr></tbody></table></p></dd><dt><a name="PWDREF"></a><tt class="VARNAME">$PWD</tt></dt><dd><p>Working directory (directory you are in at the time)</p><p>This is the analog to the <a href="#PWD2REF">pwd</a>
        builtin command.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  E_WRONG_DIRECTORY=85
  
  clear # Clear the screen.
  
  TargetDirectory=/home/bozo/projects/GreatAmericanNovel
  
  cd $TargetDirectory
  echo "Deleting stale files in $TargetDirectory."
  
  if [ "$PWD" != "$TargetDirectory" ]
  then    # Keep from wiping out wrong directory by accident.
    echo "Wrong directory!"
    echo "In $PWD, rather than $TargetDirectory!"
    echo "Bailing out!"
    exit $E_WRONG_DIRECTORY
  fi  
  
  rm -rf *
  rm .[A-Za-z0-9]*    # Delete dotfiles.
  # rm -f .[^.]* ..?*   to remove filenames beginning with multiple dots.
  # (shopt -s dotglob; rm -f *)   will also work.
  # Thanks, S.C. for pointing this out.
  
  #  A filename (`basename`) may contain all characters in the 0 - 255 range,
  #+ except "/".
  #  Deleting files beginning with weird characters, such as -
  #+ is left as an exercise. (Hint: rm ./-weirdname or rm -- -weirdname)
  result=$?   # Result of delete operations. If successful = 0.
  
  echo
  ls -al              # Any files left?
  echo "Done."
  echo "Old files deleted in $TargetDirectory."
  echo
  
  # Various other operations here, as necessary.
  
  exit $result</pre></font></td></tr></tbody></table></p></dd><dt><a name="REPLYREF"></a><tt class="VARNAME">$REPLY</tt></dt><dd><p>The default value when a variable is not
        supplied to <a href="#READREF">read</a>. Also
        applicable to <a href="#SELECTREF">select</a> menus,
        but only supplies the item number of the variable chosen,
        not the value of the variable itself.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # reply.sh
  
  # REPLY is the default value for a 'read' command.
  
  echo
  echo -n "What is your favorite vegetable? "
  read
  
  echo "Your favorite vegetable is $REPLY."
  #  REPLY holds the value of last "read" if and only if
  #+ no variable supplied.
  
  echo
  echo -n "What is your favorite fruit? "
  read fruit
  echo "Your favorite fruit is $fruit."
  echo "but..."
  echo "Value of \$REPLY is still $REPLY."
  #  $REPLY is still set to its previous value because
  #+ the variable $fruit absorbed the new "read" value.
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></p></dd><dt><tt class="VARNAME">$SECONDS</tt></dt><dd><p>The number of seconds the script has been running.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  TIME_LIMIT=10
  INTERVAL=1
  
  echo
  echo "Hit Control-C to exit before $TIME_LIMIT seconds."
  echo
  
  while [ "$SECONDS" -le "$TIME_LIMIT" ]
  do   #   $SECONDS is an internal shell variable.
    if [ "$SECONDS" -eq 1 ]
    then
      units=second
    else  
      units=seconds
    fi
  
    echo "This script has been running $SECONDS $units."
    #  On a slow or overburdened machine, the script may skip a count
    #+ every once in a while.
    sleep $INTERVAL
  done
  
  echo -e "\a"  # Beep!
  
  exit 0</pre></font></td></tr></tbody></table></p></dd><dt><tt class="VARNAME">$SHELLOPTS</tt></dt><dd><p>The list of enabled shell <a href="#OPTIONSREF">options</a>, a readonly variable.
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $SHELLOPTS</b></tt>
  <tt class="COMPUTEROUTPUT">braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="SHLVLREF"></a><tt class="VARNAME">$SHLVL</tt></dt><dd><p>Shell level, how deeply Bash is nested.
          <a name="AEN5320" href="#FTN.AEN5320"><span class="footnote">[43]</span></a>
        If, at the command-line, $SHLVL is 1, then in a script it
        will increment to 2.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>This variable is <a href="#SUBSHNLEVREF">	      <em>not</em> affected by
          subshells</a>. Use <a href="#BASHSUBSHELLREF">$BASH_SUBSHELL</a> when you
          need an indication of subshell nesting.</p></td></tr></tbody></table></div></dd><dt><a name="TMOUTREF"></a><tt class="VARNAME">$TMOUT</tt></dt><dd><p>If the <tt class="REPLACEABLE"><i>$TMOUT</i></tt>
      environmental variable is set to a non-zero value
      <tt class="VARNAME">time</tt>, then the shell prompt will time out
      after <tt class="VARNAME">$time</tt> seconds. This will cause a
      logout.</p><p>As of version 2.05b of Bash, it is now possible to use
        <tt class="REPLACEABLE"><i>$TMOUT</i></tt> in a script in combination
        with <a href="#READREF">read</a>.</p><p>	  <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Works in scripts for Bash, versions 2.05b and later.
  
  TMOUT=3    # Prompt times out at three seconds.
  
  echo "What is your favorite song?"
  echo "Quickly now, you only have $TMOUT seconds to answer!"
  read song
  
  if [ -z "$song" ]
  then
    song="(no answer)"
    # Default response.
  fi
  
  echo "Your favorite song is $song."</pre></font></td></tr></tbody></table>
      </p><p><a name="TIMINGLOOP"></a></p><p>There are other, more complex, ways of implementing
        timed input in a script. One alternative is to set up
        a timing loop to signal the script when it times out.
        This also requires a signal handling routine to <a href="#TRAPREF1">trap</a> (see <a href="#EX76">Example 32-5</a>)
        the interrupt generated by the timing loop (whew!).</p><div class="EXAMPLE"><a name="TMDIN"></a><p><b>Example 9-2. Timed Input</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # timed-input.sh
  
  # TMOUT=3    Also works, as of newer versions of Bash.
  
  TIMER_INTERRUPT=14
  TIMELIMIT=3  # Three seconds in this instance.
               # May be set to different value.
  
  PrintAnswer()
  {
    if [ "$answer" = TIMEOUT ]
    then
      echo $answer
    else       # Don't want to mix up the two instances. 
      echo "Your favorite veggie is $answer"
      kill $!  #  Kills no-longer-needed TimerOn function
               #+ running in background.
               #  $! is PID of last job running in background.
    fi
  
  }  
  
  
  TimerOn()
  {
    sleep $TIMELIMIT &amp;&amp; kill -s 14 $$ &amp;
    # Waits 3 seconds, then sends sigalarm to script.
  }  
  
  
  Int14Vector()
  {
    answer="TIMEOUT"
    PrintAnswer
    exit $TIMER_INTERRUPT
  }  
  
  trap Int14Vector $TIMER_INTERRUPT
  # Timer interrupt (14) subverted for our purposes.
  
  echo "What is your favorite vegetable "
  TimerOn
  read answer
  PrintAnswer
  
  
  #  Admittedly, this is a kludgy implementation of timed input.
  #  However, the "-t" option to "read" simplifies this task.
  #  See the "t-out.sh" script.
  #  However, what about timing not just single user input,
  #+ but an entire script?
  
  #  If you need something really elegant ...
  #+ consider writing the application in C or C++,
  #+ using appropriate library functions, such as 'alarm' and 'setitimer.'
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="STTYTO"></a></p><p>An alternative is using <a href="#STTYREF">stty</a>.</p><div class="EXAMPLE"><a name="TIMEOUT"></a><p><b>Example 9-3. Once more, timed input</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # timeout.sh
  
  #  Written by Stephane Chazelas,
  #+ and modified by the document author.
  
  INTERVAL=5                # timeout interval
  
  timedout_read() {
    timeout=$1
    varname=$2
    old_tty_settings=`stty -g`
    stty -icanon min 0 time ${timeout}0
    eval read $varname      # or just  read $varname
    stty "$old_tty_settings"
    # See man page for "stty."
  }
  
  echo; echo -n "What's your name? Quick! "
  timedout_read $INTERVAL your_name
  
  #  This may not work on every terminal type.
  #  The maximum timeout depends on the terminal.
  #+ (it is often 25.5 seconds).
  
  echo
  
  if [ ! -z "$your_name" ]  # If name input before timeout ...
  then
    echo "Your name is $your_name."
  else
    echo "Timed out."
  fi
  
  echo
  
  # The behavior of this script differs somewhat from "timed-input.sh."
  # At each keystroke, the counter resets.
  
  exit 0</pre></font></td></tr></tbody></table></div><p>Perhaps the simplest method is using the
        <tt class="OPTION">-t</tt> option to <a href="#READREF">read</a>.</p><div class="EXAMPLE"><a name="TOUT"></a><p><b>Example 9-4. Timed <i class="FIRSTTERM">read</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # t-out.sh [time-out]
  # Inspired by a suggestion from "syngin seven" (thanks).
  
  
  TIMELIMIT=4         # 4 seconds
  
  read -t $TIMELIMIT variable &lt;&amp;1
  #                           ^^^
  #  In this instance, "&lt;&amp;1" is needed for Bash 1.x and 2.x,
  #  but unnecessary for Bash 3+.
  
  echo
  
  if [ -z "$variable" ]  # Is null?
  then
    echo "Timed out, variable still unset."
  else  
    echo "variable = $variable"
  fi  
  
  exit 0</pre></font></td></tr></tbody></table></div></dd><dt><a name="UIDREF"></a><tt class="VARNAME">$UID</tt></dt><dd><p>User ID number</p><p>Current user's user identification number, as
          recorded in <a href="#DATAFILESREF1"><tt class="FILENAME">/etc/passwd</tt></a></p><p>This is the current user's real id, even if she has
          temporarily assumed another identity through <a href="#SUREF">su</a>. <tt class="VARNAME">$UID</tt> is a
          readonly variable, not subject to change from the command
          line or within a script, and is the counterpart to the
          <a href="#IDREF">id</a> builtin.</p><div class="EXAMPLE"><a name="AMIROOT"></a><p><b>Example 9-5. Am I root?</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # am-i-root.sh:   Am I root or not?
  
  ROOT_UID=0   # Root has $UID 0.
  
  if [ "$UID" -eq "$ROOT_UID" ]  # Will the real "root" please stand up?
  then
    echo "You are root."
  else
    echo "You are just an ordinary user (but mom loves you just the same)."
  fi
  
  exit 0
  
  
  # ============================================================= #
  # Code below will not execute, because the script already exited.
  
  # An alternate method of getting to the root of matters:
  
  ROOTUSER_NAME=root
  
  username=`id -nu`              # Or...   username=`whoami`
  if [ "$username" = "$ROOTUSER_NAME" ]
  then
    echo "Rooty, toot, toot. You are root."
  else
    echo "You are just a regular fella."
  fi</pre></font></td></tr></tbody></table></div><p>See also <a href="#EX2">Example 2-3</a>.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The variables <tt class="VARNAME">$ENV</tt>,
      <tt class="VARNAME">$LOGNAME</tt>, <tt class="VARNAME">$MAIL</tt>,
      <tt class="VARNAME">$TERM</tt>, <tt class="VARNAME">$USER</tt>, and
      <tt class="VARNAME">$USERNAME</tt> are <em>not</em>
      Bash <a href="#BUILTINREF">builtins</a>. These are,
      however, often set as <a href="#ENVREF">environmental variables</a> in
      one of the <a href="#FILESREF1">Bash</a> or
      <i class="FIRSTTERM">login</i> startup files. <a name="SHELLVARREF"></a><tt class="VARNAME">$SHELL</tt>,
      the name of the user's login shell, may be set from
      <tt class="FILENAME">/etc/passwd</tt> or in an <span class="QUOTE">"init"</span>
      script, and it is likewise not a Bash builtin.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">tcsh% </tt><tt class="USERINPUT"><b>echo $LOGNAME</b></tt>
  <tt class="COMPUTEROUTPUT">bozo</tt>
  <tt class="PROMPT">tcsh% </tt><tt class="USERINPUT"><b>echo $SHELL</b></tt>
  <tt class="COMPUTEROUTPUT">/bin/tcsh</tt>
  <tt class="PROMPT">tcsh% </tt><tt class="USERINPUT"><b>echo $TERM</b></tt>
  <tt class="COMPUTEROUTPUT">rxvt</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $LOGNAME</b></tt>
  <tt class="COMPUTEROUTPUT">bozo</tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $SHELL</b></tt>
  <tt class="COMPUTEROUTPUT">/bin/tcsh</tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $TERM</b></tt>
  <tt class="COMPUTEROUTPUT">rxvt</tt>
          </pre></font></td></tr></tbody></table>
          </p></td></tr></tbody></table></div></dd></dl></div><p></p><div class="VARIABLELIST"><p><b>Positional Parameters</b></p><dl><dt><a name="POSPARAMREF"></a><tt class="VARNAME">$0</tt>, <tt class="VARNAME">$1</tt>,
      <tt class="VARNAME">$2</tt>, etc.</dt><dd><p>Positional parameters, passed from command
          line to script, passed to a function, or <a href="#SETREF">set</a> to a variable (see <a href="#EX17">Example 4-5</a> and <a href="#EX34">Example 15-16</a>)</p></dd><dt><a name="CLACOUNTREF"></a><tt class="VARNAME">$#</tt></dt><dd><p>Number of command-line arguments
      <a name="AEN5479" href="#FTN.AEN5479"><span class="footnote">[44]</span></a>
        or positional parameters (see <a href="#EX4">Example 36-2</a>)</p></dd><dt><a name="APPREF"></a><tt class="VARNAME">$*</tt></dt><dd><p>All of the positional parameters, seen as a single word</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p><span class="QUOTE">"<tt class="VARNAME">$*</tt>"</span> must be
        quoted.</p></td></tr></tbody></table></div></dd><dt><a name="APPREF2"></a><tt class="VARNAME">$@</tt></dt><dd><p>Same as <span class="TOKEN">$*</span>, but each parameter is a
          quoted string, that is, the parameters are passed on
          intact, without interpretation or expansion. This means,
          among other things, that each parameter in the argument
          list is seen as a separate word.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>Of course, <span class="QUOTE">"<tt class="VARNAME">$@</tt>"</span>
        should be quoted.</p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="ARGLIST"></a><p><b>Example 9-6. <i class="FIRSTTERM">arglist</i>: Listing arguments
          with $* and $@</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # arglist.sh
  # Invoke this script with several arguments, such as "one two three" ...
  
  E_BADARGS=85
  
  if [ ! -n "$1" ]
  then
    echo "Usage: `basename $0` argument1 argument2 etc."
    exit $E_BADARGS
  fi  
  
  echo
  
  index=1          # Initialize count.
  
  echo "Listing args with \"\$*\":"
  for arg in "$*"  # Doesn't work properly if "$*" isn't quoted.
  do
    echo "Arg #$index = $arg"
    let "index+=1"
  done             # $* sees all arguments as single word. 
  echo "Entire arg list seen as single word."
  
  echo
  
  index=1          # Reset count.
                   # What happens if you forget to do this?
  
  echo "Listing args with \"\$@\":"
  for arg in "$@"
  do
    echo "Arg #$index = $arg"
    let "index+=1"
  done             # $@ sees arguments as separate words. 
  echo "Arg list seen as separate words."
  
  echo
  
  index=1          # Reset count.
  
  echo "Listing args with \$* (unquoted):"
  for arg in $*
  do
    echo "Arg #$index = $arg"
    let "index+=1"
  done             # Unquoted $* sees arguments as separate words. 
  echo "Arg list seen as separate words."
  
  exit 0</pre></font></td></tr></tbody></table></div><p>Following a <b class="COMMAND">shift</b>, the
          <tt class="VARNAME">$@</tt> holds the remaining command-line
          parameters, lacking the previous <tt class="VARNAME">$1</tt>,
          which was lost.
            <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Invoke with ./scriptname 1 2 3 4 5
  
  echo "$@"    # 1 2 3 4 5
  shift
  echo "$@"    # 2 3 4 5
  shift
  echo "$@"    # 3 4 5
  
  # Each "shift" loses parameter $1.
  # "$@" then contains the remaining parameters.</pre></font></td></tr></tbody></table>
              </p><p>The <tt class="VARNAME">$@</tt> special parameter finds
          use as a tool for filtering input into shell scripts. The
          <b class="COMMAND">cat "$@"</b> construction accepts input
          to a script either from <tt class="FILENAME">stdin</tt> or
          from files given as parameters to the script. See <a href="#ROT13">Example 16-24</a> and <a href="#CRYPTOQUOTE">Example 16-25</a>.</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>The <tt class="VARNAME">$*</tt> and <tt class="VARNAME">$@</tt>
          parameters sometimes display inconsistent and
          puzzling behavior, depending on the setting of <a href="#IFSREF">$IFS</a>.</p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="INCOMPAT"></a><p><b>Example 9-7. Inconsistent <tt class="VARNAME">$*</tt> and <tt class="VARNAME">$@</tt> behavior</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  #  Erratic behavior of the "$*" and "$@" internal Bash variables,
  #+ depending on whether or not they are quoted.
  #  Demonstrates inconsistent handling of word splitting and linefeeds.
  
  
  set -- "First one" "second" "third:one" "" "Fifth: :one"
  # Setting the script arguments, $1, $2, $3, etc.
  
  echo
  
  echo 'IFS unchanged, using "$*"'
  c=0
  for i in "$*"               # quoted
  do echo "$((c+=1)): [$i]"   # This line remains the same in every instance.
                              # Echo args.
  done
  echo ---
  
  echo 'IFS unchanged, using $*'
  c=0
  for i in $*                 # unquoted
  do echo "$((c+=1)): [$i]"
  done
  echo ---
  
  echo 'IFS unchanged, using "$@"'
  c=0
  for i in "$@"
  do echo "$((c+=1)): [$i]"
  done
  echo ---
  
  echo 'IFS unchanged, using $@'
  c=0
  for i in $@
  do echo "$((c+=1)): [$i]"
  done
  echo ---
  
  IFS=:
  echo 'IFS=":", using "$*"'
  c=0
  for i in "$*"
  do echo "$((c+=1)): [$i]"
  done
  echo ---
  
  echo 'IFS=":", using $*'
  c=0
  for i in $*
  do echo "$((c+=1)): [$i]"
  done
  echo ---
  
  var=$*
  echo 'IFS=":", using "$var" (var=$*)'
  c=0
  for i in "$var"
  do echo "$((c+=1)): [$i]"
  done
  echo ---
  
  echo 'IFS=":", using $var (var=$*)'
  c=0
  for i in $var
  do echo "$((c+=1)): [$i]"
  done
  echo ---
  
  var="$*"
  echo 'IFS=":", using $var (var="$*")'
  c=0
  for i in $var
  do echo "$((c+=1)): [$i]"
  done
  echo ---
  
  echo 'IFS=":", using "$var" (var="$*")'
  c=0
  for i in "$var"
  do echo "$((c+=1)): [$i]"
  done
  echo ---
  
  echo 'IFS=":", using "$@"'
  c=0
  for i in "$@"
  do echo "$((c+=1)): [$i]"
  done
  echo ---
  
  echo 'IFS=":", using $@'
  c=0
  for i in $@
  do echo "$((c+=1)): [$i]"
  done
  echo ---
  
  var=$@
  echo 'IFS=":", using $var (var=$@)'
  c=0
  for i in $var
  do echo "$((c+=1)): [$i]"
  done
  echo ---
  
  echo 'IFS=":", using "$var" (var=$@)'
  c=0
  for i in "$var"
  do echo "$((c+=1)): [$i]"
  done
  echo ---
  
  var="$@"
  echo 'IFS=":", using "$var" (var="$@")'
  c=0
  for i in "$var"
  do echo "$((c+=1)): [$i]"
  done
  echo ---
  
  echo 'IFS=":", using $var (var="$@")'
  c=0
  for i in $var
  do echo "$((c+=1)): [$i]"
  done
  
  echo
  
  # Try this script with ksh or zsh -y.
  
  exit 0
  
  #  This example script written by Stephane Chazelas,
  #+ and slightly modified by the document author.</pre></font></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">$@</b> and <b class="COMMAND">$*</b>
          parameters differ only when between double quotes.</p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="IFSEMPTY"></a><p><b>Example 9-8. <tt class="VARNAME">$*</tt> and <tt class="VARNAME">$@</tt> when
            <tt class="VARNAME">$IFS</tt> is empty</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  #  If $IFS set, but empty,
  #+ then "$*" and "$@" do not echo positional params as expected.
  
  mecho ()       # Echo positional parameters.
  {
  echo "$1,$2,$3";
  }
  
  
  IFS=""         # Set, but empty.
  set a b c      # Positional parameters.
  
  mecho "$*"     # abc,,
  #                   ^^
  mecho $*       # a,b,c
  
  mecho $@       # a,b,c
  mecho "$@"     # a,b,c
  
  #  The behavior of $* and $@ when $IFS is empty depends
  #+ on which Bash or sh version being run.
  #  It is therefore inadvisable to depend on this "feature" in a script.
  
  
  # Thanks, Stephane Chazelas.
  
  exit</pre></font></td></tr></tbody></table></div></dd></dl></div><p></p><div class="VARIABLELIST"><p><b>Other Special Parameters</b></p><dl><dt><a name="FLPREF"></a><tt class="VARNAME">$-</tt></dt><dd><p>Flags passed to script (using <a href="#SETREF">set</a>). See <a href="#EX34">Example 15-16</a>.</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>This was originally a <i class="FIRSTTERM">ksh</i>
          construct adopted into Bash, and unfortunately it does not
          seem to work reliably in Bash scripts. One possible use
          for it is to have a script <a href="#IITEST">self-test
          whether it is interactive</a>.</p></td></tr></tbody></table></div></dd><dt><a name="PIDVARREF"></a><tt class="VARNAME">$!</tt></dt><dd><p><a href="#PROCESSIDDEF">PID</a> (process ID) of last
          job run in background</p><p>	      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">LOG=$0.log
  
  COMMAND1="sleep 100"
  
  echo "Logging PIDs background commands for script: $0" &gt;&gt; "$LOG"
  # So they can be monitored, and killed as necessary.
  echo &gt;&gt; "$LOG"
  
  # Logging commands.
  
  echo -n "PID of \"$COMMAND1\":  " &gt;&gt; "$LOG"
  ${COMMAND1} &amp;
  echo $! &gt;&gt; "$LOG"
  # PID of "sleep 100":  1506
  
  # Thank you, Jacques Lederer, for suggesting this.</pre></font></td></tr></tbody></table>
              </p><p>Using <tt class="VARNAME">$!</tt> for job control:</p><p>	      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">possibly_hanging_job &amp; { sleep ${TIMEOUT}; eval 'kill -9 $!' &amp;&gt; /dev/null; }
  # Forces completion of an ill-behaved program.
  # Useful, for example, in init scripts.
  
  # Thank you, Sylvain Fourmanoit, for this creative use of the "!" variable.</pre></font></td></tr></tbody></table>
  
              </p><p>Or, alternately:</p><p>              <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># This example by Matthew Sage.
  # Used with permission.
  
  TIMEOUT=30   # Timeout value in seconds
  count=0
  
  possibly_hanging_job &amp; {
          while ((count &lt; TIMEOUT )); do
                  eval '[ ! -d "/proc/$!" ] &amp;&amp; ((count = TIMEOUT))'
                  # /proc is where information about running processes is found.
                  # "-d" tests whether it exists (whether directory exists).
                  # So, we're waiting for the job in question to show up.
                  ((count++))
                  sleep 1
          done
          eval '[ -d "/proc/$!" ] &amp;&amp; kill -15 $!'
          # If the hanging job is running, kill it.
  }
  
  #  -------------------------------------------------------------- #
  
  #  However, this may not not work as specified if another process
  #+ begins to run after the "hanging_job" . . .
  #  In such a case, the wrong job may be killed.
  #  Ariel Meragelman suggests the following fix.
  
  TIMEOUT=30
  count=0
  # Timeout value in seconds
  possibly_hanging_job &amp; {
  
  while ((count &lt; TIMEOUT )); do
    eval '[ ! -d "/proc/$lastjob" ] &amp;&amp; ((count = TIMEOUT))'
    lastjob=$!
    ((count++))
    sleep 1
  done
  eval '[ -d "/proc/$lastjob" ] &amp;&amp; kill -15 $lastjob'
  
  }
  
  exit</pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="UNDERSCOREREF"></a><tt class="VARNAME">$_</tt></dt><dd><p>Special variable set to final argument of previous command
            executed.</p><div class="EXAMPLE"><a name="USCREF"></a><p><b>Example 9-9. Underscore variable</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  echo $_              #  /bin/bash
                       #  Just called /bin/bash to run the script.
                       #  Note that this will vary according to
                       #+ how the script is invoked.
  
  du &gt;/dev/null        #  So no output from command.
  echo $_              #  du
  
  ls -al &gt;/dev/null    #  So no output from command.
  echo $_              #  -al  (last argument)
  
  :
  echo $_              #  :</pre></font></td></tr></tbody></table></div></dd><dt><a name="XSTATVARREF"></a><tt class="VARNAME">$?</tt></dt><dd><p><a href="#EXITSTATUSREF">Exit status</a>
        of a command, <a href="#FUNCTIONREF">function</a>,
        or the script itself (see <a href="#MAX">Example 24-7</a>)</p></dd><dt><a name="PROCCID"></a><tt class="VARNAME">$$</tt></dt><dd><p>Process ID (<i class="FIRSTTERM">PID</i>) of
              the script itself.
  
          <a name="AEN5654" href="#FTN.AEN5654"><span class="footnote">[45]</span></a>
  
              The <tt class="VARNAME">$$</tt> variable often
        finds use in scripts to construct <span class="QUOTE">"unique"</span>
        temp file names (see <a href="#ONLINE">Example 32-6</a>, <a href="#DERPM">Example 16-31</a>, and <a href="#SELFDESTRUCT">Example 15-27</a>).
        This is usually simpler than invoking <a href="#MKTEMPREF">mktemp</a>.</p></dd></dl></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="DECLAREREF"></a>9.2. Typing variables: <b class="COMMAND">declare</b> or
      <b class="COMMAND">typeset</b></h1><p><a name="DECLARE1REF"></a></p><p>The <i class="FIRSTTERM">declare</i> or
      <i class="FIRSTTERM">typeset</i> <a href="#BUILTINREF">builtins</a>, which are exact synonyms,
      permit modifying the properties of variables. This is
      a very weak form of the <i class="FIRSTTERM">typing</i>
  
        <a name="AEN5685" href="#FTN.AEN5685"><span class="footnote">[46]</span></a>
  
      available in certain programming languages. The
      <i class="FIRSTTERM">declare</i> command is specific to version
      2 or later of Bash. The <i class="FIRSTTERM">typeset</i> command
      also works in ksh scripts.</p><p></p><div class="VARIABLELIST"><p><b><a name="DECLAREOPSREF1"></a>declare/typeset options</b></p><dl><dt><span class="TOKEN">-r</span>
        <tt class="REPLACEABLE"><i>readonly</i></tt></dt><dd><p>(<tt class="USERINPUT"><b>declare -r var1</b></tt> works the same as
      <tt class="USERINPUT"><b>readonly var1</b></tt>)</p><p>This is the rough equivalent of the <b class="COMMAND">C</b>
      <i class="FIRSTTERM">const</i> type qualifier. An attempt
      to change the value of a <i class="FIRSTTERM">readonly</i>
      variable fails with an error message.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">declare -r var1=1
  echo "var1 = $var1"   # var1 = 1
  
  (( var1++ ))          # x.sh: line 4: var1: readonly variable</pre></font></td></tr></tbody></table>
                </p></dd><dt><span class="TOKEN">-i</span> <tt class="REPLACEABLE"><i>integer</i></tt></dt><dd><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">declare -i number
  # The script will treat subsequent occurrences of "number" as an integer.		
  
  number=3
  echo "Number = $number"     # Number = 3
  
  number=three
  echo "Number = $number"     # Number = 0
  # Tries to evaluate the string "three" as an integer.</pre></font></td></tr></tbody></table></p><p>Certain arithmetic operations are permitted
      for declared integer variables without the need
      for <a href="#EXPRREF">expr</a> or <a href="#LETREF">let</a>.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">n=6/3
  echo "n = $n"       # n = 6/3
  
  declare -i n
  n=6/3
  echo "n = $n"       # n = 2</pre></font></td></tr></tbody></table></p></dd><dt><a name="ARRAYDECLARE"></a><span class="TOKEN">-a</span>
        <tt class="REPLACEABLE"><i>array</i></tt></dt><dd><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">declare -a indices</pre></font></td></tr></tbody></table></p><p>The variable <tt class="PARAMETER"><i>indices</i></tt> will be treated as
      an <a href="#ARRAYREF">array</a>.</p></dd><dt><span class="TOKEN">-f</span> <tt class="REPLACEABLE"><i>function(s)</i></tt></dt><dd><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">declare -f</pre></font></td></tr></tbody></table></p><p>A <tt class="USERINPUT"><b>declare -f</b></tt> line with no
      arguments in a script causes a listing of all the
      <a href="#FUNCTIONREF">functions</a> previously
      defined in that script.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">declare -f function_name</pre></font></td></tr></tbody></table></p><p>A <tt class="USERINPUT"><b>declare -f function_name</b></tt>
      in a script lists just the function named.</p></dd><dt><span class="TOKEN">-x</span> <a href="#EXPORTREF">export</a></dt><dd><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">declare -x var3</pre></font></td></tr></tbody></table></p><p>This declares a variable as available for exporting outside the
      environment of the script itself.</p></dd><dt>-x var=$value</dt><dd><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">declare -x var3=373</pre></font></td></tr></tbody></table></p><p>The <b class="COMMAND">declare</b> command permits
        assigning a value to a variable in the same statement
        as setting its properties.</p></dd></dl></div><div class="EXAMPLE"><a name="EX20"></a><p><b>Example 9-10. Using <i class="FIRSTTERM">declare</i> to type variables</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  func1 ()
  {
    echo This is a function.
  }
  
  declare -f        # Lists the function above.
  
  echo
  
  declare -i var1   # var1 is an integer.
  var1=2367
  echo "var1 declared as $var1"
  var1=var1+1       # Integer declaration eliminates the need for 'let'.
  echo "var1 incremented by 1 is $var1."
  # Attempt to change variable declared as integer.
  echo "Attempting to change var1 to floating point value, 2367.1."
  var1=2367.1       # Results in error message, with no change to variable.
  echo "var1 is still $var1"
  
  echo
  
  declare -r var2=13.36         # 'declare' permits setting a variable property
                                #+ and simultaneously assigning it a value.
  echo "var2 declared as $var2" # Attempt to change readonly variable.
  var2=13.37                    # Generates error message, and exit from script.
  
  echo "var2 is still $var2"    # This line will not execute.
  
  exit 0                        # Script will not exit here.</pre></font></td></tr></tbody></table></div><div class="CAUTION"><p></p><table class="CAUTION" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>Using the <i class="FIRSTTERM">declare</i> builtin
      restricts the <a href="#SCOPEREF">scope</a>
      of a variable.
  
  
      <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">foo ()
  {
  FOO="bar"
  }
  
  bar ()
  {
  foo
  echo $FOO
  }
  
  bar   # Prints bar.</pre></font></td></tr></tbody></table></p><p>However . . .
  
      <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">foo (){
  declare FOO="bar"
  }
  
  bar ()
  {
  foo
  echo $FOO
  }
  
  bar  # Prints nothing.
  
  
  # Thank you, Michael Iatrou, for pointing this out.</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div><div class="SECT2"><hr><h2 class="SECT2"><a name="DECLARE2X"></a>9.2.1. Another use for <i class="FIRSTTERM">declare</i></h2><p>The <i class="FIRSTTERM">declare</i> command can be
         helpful in identifying variables, <a href="#ENVREF">environmental</a> or otherwise.
         This can be especially useful with <a href="#ARRAYREF">arrays</a>.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>declare | grep HOME</b></tt>
  <tt class="COMPUTEROUTPUT">HOME=/home/bozo</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>zzy=68</b></tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>declare | grep zzy</b></tt>
  <tt class="COMPUTEROUTPUT">zzy=68</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>Colors=([0]="purple" [1]="reddish-orange" [2]="light green")</b></tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo ${Colors[@]}</b></tt>
  <tt class="COMPUTEROUTPUT">purple reddish-orange light green</tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>declare | grep Colors</b></tt>
  <tt class="COMPUTEROUTPUT">Colors=([0]="purple" [1]="reddish-orange" [2]="light green")</tt>
         </pre></font></td></tr></tbody></table>
       </p></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="RANDOMVAR"></a>9.3. $RANDOM: generate random integer</h1><table border="0" width="100%" cellspacing="0" cellpadding="0" class="EPIGRAPH"><tbody><tr><td width="45%">&nbsp;</td><td width="45%" align="LEFT" valign="TOP"><i><p><i>Anyone who attempts to generate random numbers by
          deterministic means is, of course, living in a state of
          sin.</i></p><p><i>--John von Neumann</i></p></i></td></tr></tbody></table><p><a name="RANDOMVAR01"></a></p><p><tt class="VARNAME">$RANDOM</tt> is an internal Bash <a href="#FUNCTIONREF">function</a> (not a constant) that
      returns a <i class="FIRSTTERM">pseudorandom</i>
  
        <a name="AEN5817" href="#FTN.AEN5817"><span class="footnote">[47]</span></a>
  
      integer in the range 0 - 32767. It should
      <tt class="REPLACEABLE"><i>not</i></tt> be used to generate an encryption
      key.</p><div class="EXAMPLE"><a name="EX21"></a><p><b>Example 9-11. Generating random numbers</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  # $RANDOM returns a different random integer at each invocation.
  # Nominal range: 0 - 32767 (signed 16-bit integer).
  
  MAXCOUNT=10
  count=1
  
  echo
  echo "$MAXCOUNT random numbers:"
  echo "-----------------"
  while [ "$count" -le $MAXCOUNT ]      # Generate 10 ($MAXCOUNT) random integers.
  do
    number=$RANDOM
    echo $number
    let "count += 1"  # Increment count.
  done
  echo "-----------------"
  
  # If you need a random int within a certain range, use the 'modulo' operator.
  # This returns the remainder of a division operation.
  
  RANGE=500
  
  echo
  
  number=$RANDOM
  let "number %= $RANGE"
  #           ^^
  echo "Random number less than $RANGE  ---  $number"
  
  echo
  
  
  
  #  If you need a random integer greater than a lower bound,
  #+ then set up a test to discard all numbers below that.
  
  FLOOR=200
  
  number=0   #initialize
  while [ "$number" -le $FLOOR ]
  do
    number=$RANDOM
  done
  echo "Random number greater than $FLOOR ---  $number"
  echo
  
     # Let's examine a simple alternative to the above loop, namely
     #       let "number = $RANDOM + $FLOOR"
     # That would eliminate the while-loop and run faster.
     # But, there might be a problem with that. What is it?
  
  
  
  # Combine above two techniques to retrieve random number between two limits.
  number=0   #initialize
  while [ "$number" -le $FLOOR ]
  do
    number=$RANDOM
    let "number %= $RANGE"  # Scales $number down within $RANGE.
  done
  echo "Random number between $FLOOR and $RANGE ---  $number"
  echo
  
  
  
  # Generate binary choice, that is, "true" or "false" value.
  BINARY=2
  T=1
  number=$RANDOM
  
  let "number %= $BINARY"
  #  Note that    let "number &gt;&gt;= 14"    gives a better random distribution
  #+ (right shifts out everything except last binary digit).
  if [ "$number" -eq $T ]
  then
    echo "TRUE"
  else
    echo "FALSE"
  fi  
  
  echo
  
  
  # Generate a toss of the dice.
  SPOTS=6   # Modulo 6 gives range 0 - 5.
            # Incrementing by 1 gives desired range of 1 - 6.
            # Thanks, Paulo Marcel Coelho Aragao, for the simplification.
  die1=0
  die2=0
  # Would it be better to just set SPOTS=7 and not add 1? Why or why not?
  
  # Tosses each die separately, and so gives correct odds.
  
      let "die1 = $RANDOM % $SPOTS +1" # Roll first one.
      let "die2 = $RANDOM % $SPOTS +1" # Roll second one.
      #  Which arithmetic operation, above, has greater precedence --
      #+ modulo (%) or addition (+)?
  
  
  let "throw = $die1 + $die2"
  echo "Throw of the dice = $throw"
  echo
  
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="PICKCARD"></a><p><b>Example 9-12. Picking a random card from a deck</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # pick-card.sh
  
  # This is an example of choosing random elements of an array.
  
  
  # Pick a card, any card.
  
  Suites="Clubs
  Diamonds
  Hearts
  Spades"
  
  Denominations="2
  3
  4
  5
  6
  7
  8
  9
  10
  Jack
  Queen
  King
  Ace"
  
  # Note variables spread over multiple lines.
  
  
  suite=($Suites)                # Read into array variable.
  denomination=($Denominations)
  
  num_suites=${#suite[*]}        # Count how many elements.
  num_denominations=${#denomination[*]}
  
  echo -n "${denomination[$((RANDOM%num_denominations))]} of "
  echo ${suite[$((RANDOM%num_suites))]}
  
  
  # $bozo sh pick-cards.sh
  # Jack of Clubs
  
  
  # Thank you, "jipe," for pointing out this use of $RANDOM.
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="BROWNIANREF"></a></p><div class="EXAMPLE"><a name="BROWNIAN"></a><p><b>Example 9-13. Brownian Motion Simulation</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # brownian.sh
  # Author: Mendel Cooper
  # Reldate: 10/26/07
  # License: GPL3
  
  #  ----------------------------------------------------------------
  #  This script models Brownian motion:
  #+ the random wanderings of tiny particles in a fluid,
  #+ as they are buffeted by random currents and collisions.
  #+ This is colloquially known as the "Drunkard's Walk."
  
  #  It can also be considered as a stripped-down simulation of a
  #+ Galton Board, a slanted board with a pattern of pegs,
  #+ down which rolls a succession of marbles, one at a time.
  #+ At the bottom is a row of slots or catch basins in which
  #+ the marbles come to rest at the end of their journey.
  #  Think of it as a kind of bare-bones Pachinko game.
  #  As you see by running the script,
  #+ most of the marbles cluster around the center slot.
  #+ This is consistent with the expected binomial distribution.
  #  As a Galton Board simulation, the script
  #+ disregards such parameters as
  #+ board tilt-angle, rolling friction of the marbles,
  #+ angles of impact, and elasticity of the pegs.
  #  To what extent does this affect the accuracy of the simulation?
  #  ----------------------------------------------------------------
  
  PASSES=500            #  Number of particle interactions / marbles.
  ROWS=10               #  Number of "collisions" (or horiz. peg rows).
  RANGE=3               #  0 - 2 output range from $RANDOM.
  POS=0                 #  Left/right position.
  RANDOM=$$             #  Seeds the random number generator from PID
                        #+ of script.
  
  declare -a Slots      # Array holding cumulative results of passes.
  NUMSLOTS=21           # Number of slots at bottom of board.
  
  
  Initialize_Slots () { # Zero out all elements of the array.
  for i in $( seq $NUMSLOTS )
  do
    Slots[$i]=0
  done
  
  echo                  # Blank line at beginning of run.
    }
  
  
  Show_Slots () {
  echo; echo
  echo -n " "
  for i in $( seq $NUMSLOTS )   # Pretty-print array elements.
  do
    printf "%3d" ${Slots[$i]}   # Allot three spaces per result.
  done
  
  echo # Row of slots:
  echo " |__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|"
  echo "                                ||"
  echo #  Note that if the count within any particular slot exceeds 99,
       #+ it messes up the display.
       #  Running only(!) 500 passes usually avoids this.
    }
  
  
  Move () {              # Move one unit right / left, or stay put.
    Move=$RANDOM         # How random is $RANDOM? Well, let's see ...
    let "Move %= RANGE"  # Normalize into range of 0 - 2.
    case "$Move" in
      0 ) ;;                   # Do nothing, i.e., stay in place.
      1 ) ((POS--));;          # Left.
      2 ) ((POS++));;          # Right.
      * ) echo -n "Error ";;   # Anomaly! (Should never occur.)
    esac
    }
  
  
  Play () {                    # Single pass (inner loop).
  i=0
  while [ "$i" -lt "$ROWS" ]   # One event per row.
  do
    Move
    ((i++));
  done
  
  SHIFT=11                     # Why 11, and not 10?
  let "POS += $SHIFT"          # Shift "zero position" to center.
  (( Slots[$POS]++ ))          # DEBUG: echo $POS
  
  # echo -n "$POS "
  
    }
  
  
  Run () {                     # Outer loop.
  p=0
  while [ "$p" -lt "$PASSES" ]
  do
    Play
    (( p++ ))
    POS=0                      # Reset to zero. Why?
  done
    }
  
  
  # --------------
  # main ()
  Initialize_Slots
  Run
  Show_Slots
  # --------------
  
  exit $?
  
  #  Exercises:
  #  ---------
  #  1) Show the results in a vertical bar graph, or as an alternative,
  #+    a scattergram.
  #  2) Alter the script to use /dev/urandom instead of $RANDOM.
  #     Will this make the results more random?
  #  3) Provide some sort of "animation" or graphic output
  #     for each marble played.</pre></font></td></tr></tbody></table></div><p>	<em>Jipe</em> points out a set of techniques for
    generating random numbers within a range.
  
    <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#  Generate random number between 6 and 30.
     rnumber=$((RANDOM%25+6))	
  
  #  Generate random number in the same 6 - 30 range,
  #+ but the number must be evenly divisible by 3.
     rnumber=$(((RANDOM%30/3+1)*3))
  
  #  Note that this will not work all the time.
  #  It fails if $RANDOM%30 returns 0.
  
  #  Frank Wang suggests the following alternative:
     rnumber=$(( RANDOM%27/3*3+6 ))</pre></font></td></tr></tbody></table>
    </p><p>	<em>Bill Gradwohl</em> came up with an improved
    formula that works for positive numbers.
    <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">rnumber=$(((RANDOM%(max-min+divisibleBy))/divisibleBy*divisibleBy+min))</pre></font></td></tr></tbody></table>
    </p><p>Here Bill presents a versatile function that returns
      a random number between two specified values.</p><div class="EXAMPLE"><a name="RANDOMBETWEEN"></a><p><b>Example 9-14. Random between values</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # random-between.sh
  # Random number between two specified values. 
  # Script by Bill Gradwohl, with minor modifications by the document author.
  # Corrections in lines 187 and 189 by Anthony Le Clezio.
  # Used with permission.
  
  
  randomBetween() {
     #  Generates a positive or negative random number
     #+ between $min and $max
     #+ and divisible by $divisibleBy.
     #  Gives a "reasonably random" distribution of return values.
     #
     #  Bill Gradwohl - Oct 1, 2003
  
     syntax() {
     # Function embedded within function.
        echo
        echo    "Syntax: randomBetween [min] [max] [multiple]"
        echo
        echo -n "Expects up to 3 passed parameters, "
        echo    "but all are completely optional."
        echo    "min is the minimum value"
        echo    "max is the maximum value"
        echo -n "multiple specifies that the answer must be "
        echo     "a multiple of this value."
        echo    "    i.e. answer must be evenly divisible by this number."
        echo    
        echo    "If any value is missing, defaults area supplied as: 0 32767 1"
        echo -n "Successful completion returns 0, "
        echo     "unsuccessful completion returns"
        echo    "function syntax and 1."
        echo -n "The answer is returned in the global variable "
        echo    "randomBetweenAnswer"
        echo -n "Negative values for any passed parameter are "
        echo    "handled correctly."
     }
  
     local min=${1:-0}
     local max=${2:-32767}
     local divisibleBy=${3:-1}
     # Default values assigned, in case parameters not passed to function.
  
     local x
     local spread
  
     # Let's make sure the divisibleBy value is positive.
     [ ${divisibleBy} -lt 0 ] &amp;&amp; divisibleBy=$((0-divisibleBy))
  
     # Sanity check.
     if [ $# -gt 3 -o ${divisibleBy} -eq 0 -o  ${min} -eq ${max} ]; then 
        syntax
        return 1
     fi
  
     # See if the min and max are reversed.
     if [ ${min} -gt ${max} ]; then
        # Swap them.
        x=${min}
        min=${max}
        max=${x}
     fi
  
     #  If min is itself not evenly divisible by $divisibleBy,
     #+ then fix the min to be within range.
     if [ $((min/divisibleBy*divisibleBy)) -ne ${min} ]; then 
        if [ ${min} -lt 0 ]; then
           min=$((min/divisibleBy*divisibleBy))
        else
           min=$((((min/divisibleBy)+1)*divisibleBy))
        fi
     fi
  
     #  If max is itself not evenly divisible by $divisibleBy,
     #+ then fix the max to be within range.
     if [ $((max/divisibleBy*divisibleBy)) -ne ${max} ]; then 
        if [ ${max} -lt 0 ]; then
           max=$((((max/divisibleBy)-1)*divisibleBy))
        else
           max=$((max/divisibleBy*divisibleBy))
        fi
     fi
  
     #  ---------------------------------------------------------------------
     #  Now, to do the real work.
  
     #  Note that to get a proper distribution for the end points,
     #+ the range of random values has to be allowed to go between
     #+ 0 and abs(max-min)+divisibleBy, not just abs(max-min)+1.
  
     #  The slight increase will produce the proper distribution for the
     #+ end points.
  
     #  Changing the formula to use abs(max-min)+1 will still produce
     #+ correct answers, but the randomness of those answers is faulty in
     #+ that the number of times the end points ($min and $max) are returned
     #+ is considerably lower than when the correct formula is used.
     #  ---------------------------------------------------------------------
  
     spread=$((max-min))
     #  Omair Eshkenazi points out that this test is unnecessary,
     #+ since max and min have already been switched around.
     [ ${spread} -lt 0 ] &amp;&amp; spread=$((0-spread))
     let spread+=divisibleBy
     randomBetweenAnswer=$(((RANDOM%spread)/divisibleBy*divisibleBy+min))   
  
     return 0
  
     #  However, Paulo Marcel Coelho Aragao points out that
     #+ when $max and $min are not divisible by $divisibleBy,
     #+ the formula fails.
     #
     #  He suggests instead the following formula:
     #    rnumber = $(((RANDOM%(max-min+1)+min)/divisibleBy*divisibleBy))
  
  }
  
  # Let's test the function.
  min=-14
  max=20
  divisibleBy=3
  
  
  #  Generate an array of expected answers and check to make sure we get
  #+ at least one of each answer if we loop long enough.
  
  declare -a answer
  minimum=${min}
  maximum=${max}
     if [ $((minimum/divisibleBy*divisibleBy)) -ne ${minimum} ]; then 
        if [ ${minimum} -lt 0 ]; then
           minimum=$((minimum/divisibleBy*divisibleBy))
        else
           minimum=$((((minimum/divisibleBy)+1)*divisibleBy))
        fi
     fi
  
  
     #  If max is itself not evenly divisible by $divisibleBy,
     #+ then fix the max to be within range.
  
     if [ $((maximum/divisibleBy*divisibleBy)) -ne ${maximum} ]; then 
        if [ ${maximum} -lt 0 ]; then
           maximum=$((((maximum/divisibleBy)-1)*divisibleBy))
        else
           maximum=$((maximum/divisibleBy*divisibleBy))
        fi
     fi
  
  
  #  We need to generate only positive array subscripts,
  #+ so we need a displacement that that will guarantee
  #+ positive results.
  
  disp=$((0-minimum))
  for ((i=${minimum}; i&lt;=${maximum}; i+=divisibleBy)); do
     answer[i+disp]=0
  done
  
  
  # Now loop a large number of times to see what we get.
  loopIt=1000   #  The script author suggests 100000,
                #+ but that takes a good long while.
  
  for ((i=0; i&lt;${loopIt}; ++i)); do
  
     #  Note that we are specifying min and max in reversed order here to
     #+ make the function correct for this case.
  
     randomBetween ${max} ${min} ${divisibleBy}
  
     # Report an error if an answer is unexpected.
     [ ${randomBetweenAnswer} -lt ${min} -o ${randomBetweenAnswer} -gt ${max} ] \
     &amp;&amp; echo MIN or MAX error - ${randomBetweenAnswer}!
     [ $((randomBetweenAnswer%${divisibleBy})) -ne 0 ] \
     &amp;&amp; echo DIVISIBLE BY error - ${randomBetweenAnswer}!
  
     # Store the answer away statistically.
     answer[randomBetweenAnswer+disp]=$((answer[randomBetweenAnswer+disp]+1))
  done
  
  
  
  # Let's check the results
  
  for ((i=${minimum}; i&lt;=${maximum}; i+=divisibleBy)); do
     [ ${answer[i+disp]} -eq 0 ] \
     &amp;&amp; echo "We never got an answer of $i." \
     || echo "${i} occurred ${answer[i+disp]} times."
  done
  
  
  exit 0</pre></font></td></tr></tbody></table></div><p>Just how random is <tt class="VARNAME">$RANDOM</tt>? The best
      way to test this is to write a script that tracks
      the distribution of <span class="QUOTE">"random"</span> numbers
      generated by <tt class="VARNAME">$RANDOM</tt>. Let's roll a
      <tt class="VARNAME">$RANDOM</tt> die a few times . . .</p><div class="EXAMPLE"><a name="RANDOMTEST"></a><p><b>Example 9-15. Rolling a single die with RANDOM</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # How random is RANDOM?
  
  RANDOM=$$       # Reseed the random number generator using script process ID.
  
  PIPS=6          # A die has 6 pips.
  MAXTHROWS=600   # Increase this if you have nothing better to do with your time.
  throw=0         # Number of times the dice have been cast.
  
  ones=0          #  Must initialize counts to zero,
  twos=0          #+ since an uninitialized variable is null, NOT zero.
  threes=0
  fours=0
  fives=0
  sixes=0
  
  print_result ()
  {
  echo
  echo "ones =   $ones"
  echo "twos =   $twos"
  echo "threes = $threes"
  echo "fours =  $fours"
  echo "fives =  $fives"
  echo "sixes =  $sixes"
  echo
  }
  
  update_count()
  {
  case "$1" in
    0) ((ones++));;   # Since a die has no "zero", this corresponds to 1.
    1) ((twos++));;   # And this to 2.
    2) ((threes++));; # And so forth.
    3) ((fours++));;
    4) ((fives++));;
    5) ((sixes++));;
  esac
  }
  
  echo
  
  
  while [ "$throw" -lt "$MAXTHROWS" ]
  do
    let "die1 = RANDOM % $PIPS"
    update_count $die1
    let "throw += 1"
  done  
  
  print_result
  
  exit $?
  
  #  The scores should distribute evenly, assuming RANDOM is random.
  #  With $MAXTHROWS at 600, all should cluster around 100,
  #+ plus-or-minus 20 or so.
  #
  #  Keep in mind that RANDOM is a ***pseudorandom*** generator,
  #+ and not a spectacularly good one at that.
  
  #  Randomness is a deep and complex subject.
  #  Sufficiently long "random" sequences may exhibit
  #+ chaotic and other "non-random" behavior.
  
  # Exercise (easy):
  # ---------------
  # Rewrite this script to flip a coin 1000 times.
  # Choices are "HEADS" and "TAILS."</pre></font></td></tr></tbody></table></div><p>As we have seen in the last example, it is best to
      <i class="FIRSTTERM">reseed</i> the <tt class="PARAMETER"><i>RANDOM</i></tt>
      generator each time it is invoked. Using the same seed
      for <tt class="PARAMETER"><i>RANDOM</i></tt> repeats the same series
      of numbers.
        <a name="AEN5857" href="#FTN.AEN5857"><span class="footnote">[48]</span></a>
      (This mirrors the behavior of the
      <tt class="REPLACEABLE"><i>random()</i></tt> function in
      <i class="FIRSTTERM">C</i>.)</p><div class="EXAMPLE"><a name="SEEDINGRANDOM"></a><p><b>Example 9-16. Reseeding RANDOM</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # seeding-random.sh: Seeding the RANDOM variable.
  # v 1.1, reldate 09 Feb 2013
  
  MAXCOUNT=25       # How many numbers to generate.
  SEED=
  
  random_numbers ()
  {
  local count=0
  local number
  
  while [ "$count" -lt "$MAXCOUNT" ]
  do
    number=$RANDOM
    echo -n "$number "
    let "count++"
  done  
  }
  
  echo; echo
  
  SEED=1
  RANDOM=$SEED      # Setting RANDOM seeds the random number generator.
  echo "Random seed = $SEED"
  random_numbers
  
  
  RANDOM=$SEED      # Same seed for RANDOM . . .
  echo; echo "Again, with same random seed ..."
  echo "Random seed = $SEED"
  random_numbers    # . . . reproduces the exact same number series.
                    #
                    # When is it useful to duplicate a "random" series?
  
  echo; echo
  
  SEED=2
  RANDOM=$SEED      # Trying again, but with a different seed . . .
  echo "Random seed = $SEED"
  random_numbers    # . . . gives a different number series.
  
  echo; echo
  
  # RANDOM=$$  seeds RANDOM from process id of script.
  # It is also possible to seed RANDOM from 'time' or 'date' commands.
  
  # Getting fancy...
  SEED=$(head -1 /dev/urandom | od -N 1 | awk '{ print $2 }'| sed s/^0*//)
  #  Pseudo-random output fetched
  #+ from /dev/urandom (system pseudo-random device-file),
  #+ then converted to line of printable (octal) numbers by "od",
  #+ then "awk" retrieves just one number for SEED,
  #+ finally "sed" removes any leading zeros.
  RANDOM=$SEED
  echo "Random seed = $SEED"
  random_numbers
  
  echo; echo
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="URANDOMREF"></a></p><div class="NOTE"><p></p><table class="NOTE" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <tt class="FILENAME">/dev/urandom</tt> pseudo-device file
      provides a method of generating much more <span class="QUOTE">"random"</span>
      pseudorandom numbers than the <tt class="VARNAME">$RANDOM</tt>
      variable.  <tt class="USERINPUT"><b>dd if=/dev/urandom of=targetfile
      bs=1 count=XX</b></tt> creates a file of well-scattered
      pseudorandom numbers.  However, assigning these numbers
      to a variable in a script requires a workaround, such
      as filtering through <a href="#ODREF">od</a>
      (as in above example, <a href="#RND">Example 16-14</a>, and
      <a href="#INSERTIONSORT">Example A-36</a>), or even piping to
      <a href="#MD5SUMREF">md5sum</a> (see <a href="#HORSERACE">Example 36-16</a>).</p><p><a name="AWKRANDOMREF"></a></p><p>There are also other ways to generate pseudorandom
            numbers in a script. <b class="COMMAND">Awk</b> provides a
      convenient means of doing this.</p><div class="EXAMPLE"><a name="RANDOM2"></a><p><b>Example 9-17. Pseudorandom numbers, using <a href="#AWKREF">awk</a></b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  #  random2.sh: Returns a pseudorandom number in the range 0 - 1,
  #+ to 6 decimal places. For example: 0.822725
  #  Uses the awk rand() function.
  
  AWKSCRIPT=' { srand(); print rand() } '
  #           Command(s)/parameters passed to awk
  # Note that srand() reseeds awk's random number generator.
  
  
  echo -n "Random number between 0 and 1 = "
  
  echo | awk "$AWKSCRIPT"
  # What happens if you leave out the 'echo'?
  
  exit 0
  
  
  # Exercises:
  # ---------
  
  # 1) Using a loop construct, print out 10 different random numbers.
  #      (Hint: you must reseed the srand() function with a different seed
  #+     in each pass through the loop. What happens if you omit this?)
  
  # 2) Using an integer multiplier as a scaling factor, generate random numbers 
  #+   in the range of 10 to 100.
  
  # 3) Same as exercise #2, above, but generate random integers this time.</pre></font></td></tr></tbody></table></div><p>The <a href="#DATEREF">date</a> command also lends
      itself to <a href="#DATERANDREF">generating pseudorandom
      integer sequences</a>.</p></td></tr></tbody></table></div></div></div><div class="CHAPTER"><hr><h1><a name="MANIPULATINGVARS"></a>Chapter 10. Manipulating Variables</h1><div class="SECT1"><h1 class="SECT1"><a name="STRING-MANIPULATION"></a>10.1. Manipulating Strings</h1><p><a name="STRINGMANIP"></a></p><p>Bash supports a surprising number of string manipulation
          operations.  Unfortunately, these tools lack
          a unified focus. Some are a subset of <a href="#PARAMSUBREF">parameter substitution</a>, and
          others fall under the functionality of the UNIX <a href="#EXPRREF">expr</a> command. This results in
          inconsistent command syntax and overlap of functionality,
          not to mention confusion.</p><p></p><div class="VARIABLELIST"><p><b>String Length</b></p><dl><dt>${#string}</dt><dd><p></p></dd><dt>expr length $string</dt><dd><p><a name="STRLEN"></a>These are the equivalent of
              <i class="FIRSTTERM">strlen()</i> in
              <i class="FIRSTTERM">C</i>.</p></dd><dt>expr "$string" : '.*'</dt><dd><p>	  <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">stringZ=abcABC123ABCabc
  
  echo ${#stringZ}                 # 15
  echo `expr length $stringZ`      # 15
  echo `expr "$stringZ" : '.*'`    # 15</pre></font></td></tr></tbody></table>
      </p></dd></dl></div><div class="EXAMPLE"><a name="PARAGRAPHSPACE"></a><p><b>Example 10-1. Inserting a blank line between paragraphs in a text file</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # paragraph-space.sh
  # Ver. 2.1, Reldate 29Jul12 [fixup]
  
  # Inserts a blank line between paragraphs of a single-spaced text file.
  # Usage: $0 &lt;FILENAME
  
  MINLEN=60        # Change this value? It's a judgment call.
  #  Assume lines shorter than $MINLEN characters ending in a period
  #+ terminate a paragraph. See exercises below.
  
  while read line  # For as many lines as the input file has ...
  do
    echo "$line"   # Output the line itself.
  
    len=${#line}
    if [[ "$len" -lt "$MINLEN" &amp;&amp; "$line" =~ [*{\.}]$ ]]
  # if [[ "$len" -lt "$MINLEN" &amp;&amp; "$line" =~ \[*\.\] ]]
  # An update to Bash broke the previous version of this script. Ouch!
  # Thank you, Halim Srama, for pointing this out and suggesting a fix.
      then echo    #  Add a blank line immediately
    fi             #+ after a short line terminated by a period.
  done
  
  exit
  
  # Exercises:
  # ---------
  #  1) The script usually inserts a blank line at the end
  #+    of the target file. Fix this.
  #  2) Line 17 only considers periods as sentence terminators.
  #     Modify this to include other common end-of-sentence characters,
  #+    such as ?, !, and ".</pre></font></td></tr></tbody></table></div><p></p><div class="VARIABLELIST"><p><b>Length of Matching Substring at Beginning of String</b></p><dl><dt><a name="EXPRMATCH"></a>expr match "$string"
      '$substring'</dt><dd><p><tt class="REPLACEABLE"><i>$substring</i></tt> is a <a href="#REGEXREF">regular expression</a>.</p></dd><dt>expr "$string" : '$substring'</dt><dd><p><tt class="REPLACEABLE"><i>$substring</i></tt> is a regular
        expression.</p><p>
      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">stringZ=abcABC123ABCabc
  #       |------|
  #       12345678
  
  echo `expr match "$stringZ" 'abc[A-Z]*.2'`   # 8
  echo `expr "$stringZ" : 'abc[A-Z]*.2'`       # 8</pre></font></td></tr></tbody></table>
            </p></dd></dl></div><p></p><div class="VARIABLELIST"><p><b>Index</b></p><dl><dt><a name="SUBSTRINGINDEX2"></a>expr index $string
        $substring</dt><dd><p>Numerical position in $string of first character in 
        $substring that matches.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">stringZ=abcABC123ABCabc
  #       123456 ...
  echo `expr index "$stringZ" C12`             # 6
                                               # C position.
  
  echo `expr index "$stringZ" 1c`              # 3
  # 'c' (in #3 position) matches before '1'.</pre></font></td></tr></tbody></table></p><p>This is the near equivalent of
              <i class="FIRSTTERM">strchr()</i> in
              <i class="FIRSTTERM">C</i>.</p></dd></dl></div><p></p><div class="VARIABLELIST"><p><b>Substring Extraction</b></p><dl><dt><a name="SUBSTREXTR01"></a>${string:position}</dt><dd><p>Extracts substring from <tt class="REPLACEABLE"><i>$string</i></tt> at
        <tt class="REPLACEABLE"><i>$position</i></tt>.</p><p>If the <tt class="VARNAME">$string</tt> parameter is
        <span class="QUOTE">"<span class="TOKEN">*</span>"</span>
        or <span class="QUOTE">"<span class="TOKEN">@</span>"</span>, then this extracts the
        <a href="#POSPARAMREF">positional parameters</a>,
           <a name="AEN5987" href="#FTN.AEN5987"><span class="footnote">[49]</span></a>
        starting at <tt class="VARNAME">$position</tt>.</p></dd><dt><a name="SUBSTREXTR02"></a>${string:position:length}</dt><dd><p>Extracts <tt class="REPLACEABLE"><i>$length</i></tt> characters
        of substring from <tt class="REPLACEABLE"><i>$string</i></tt> at
        <tt class="REPLACEABLE"><i>$position</i></tt>.</p><p>	  <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">stringZ=abcABC123ABCabc
  #       0123456789.....
  #       0-based indexing.
  
  echo ${stringZ:0}                            # abcABC123ABCabc
  echo ${stringZ:1}                            # bcABC123ABCabc
  echo ${stringZ:7}                            # 23ABCabc
  
  echo ${stringZ:7:3}                          # 23A
                                               # Three characters of substring.
  
  
  
  # Is it possible to index from the right end of the string?
      
  echo ${stringZ:-4}                           # abcABC123ABCabc
  # Defaults to full string, as in ${parameter:-default}.
  # However . . .
  
  echo ${stringZ:(-4)}                         # Cabc 
  echo ${stringZ: -4}                          # Cabc
  # Now, it works.
  # Parentheses or added space "escape" the position parameter.
  
  # Thank you, Dan Jacobson, for pointing this out.</pre></font></td></tr></tbody></table>
      </p><p>The <i class="FIRSTTERM">position</i> and
               <i class="FIRSTTERM">length</i> arguments can be
         <span class="QUOTE">"parameterized,"</span> that is, represented as a
         variable, rather than as a numerical constant.</p><p><a name="RANDSTRING0"></a></p><div class="EXAMPLE"><a name="RANDSTRING"></a><p><b>Example 10-2. Generating an 8-character <span class="QUOTE">"random"</span>
            string</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # rand-string.sh
  # Generating an 8-character "random" string.
  
  if [ -n "$1" ]  #  If command-line argument present,
  then            #+ then set start-string to it.
    str0="$1"
  else            #  Else use PID of script as start-string.
    str0="$$"
  fi
  
  POS=2  # Starting from position 2 in the string.
  LEN=8  # Extract eight characters.
  
  str1=$( echo "$str0" | md5sum | md5sum )
  #  Doubly scramble     ^^^^^^   ^^^^^^
  #+ by piping and repiping to md5sum.
  
  randstring="${str1:$POS:$LEN}"
  # Can parameterize ^^^^ ^^^^
  
  echo "$randstring"
  
  exit $?
  
  # bozo$ ./rand-string.sh my-password
  # 1bdd88c4
  
  #  No, this is is not recommended
  #+ as a method of generating hack-proof passwords.</pre></font></td></tr></tbody></table></div><p><a name="SUBSTREXTRP"></a></p><p>If the <tt class="VARNAME">$string</tt> parameter is
        <span class="QUOTE">"<span class="TOKEN">*</span>"</span> or
        <span class="QUOTE">"<span class="TOKEN">@</span>"</span>, then this extracts a maximum
        of <tt class="VARNAME">$length</tt> positional parameters, starting
        at <tt class="VARNAME">$position</tt>.</p><p>	  <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo ${*:2}          # Echoes second and following positional parameters.
  echo ${@:2}          # Same as above.
  
  echo ${*:2:3}        # Echoes three positional parameters, starting at second.</pre></font></td></tr></tbody></table>
      </p></dd><dt>expr substr $string $position $length</dt><dd><p>Extracts <tt class="REPLACEABLE"><i>$length</i></tt> characters
        from <tt class="REPLACEABLE"><i>$string</i></tt> starting at
        <tt class="REPLACEABLE"><i>$position</i></tt>.</p><p>	  <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">stringZ=abcABC123ABCabc
  #       123456789......
  #       1-based indexing.
  
  echo `expr substr $stringZ 1 2`              # ab
  echo `expr substr $stringZ 4 3`              # ABC</pre></font></td></tr></tbody></table>
            </p><p><a name="EXPRPAREN"></a></p></dd><dt>expr match "$string" '\($substring\)'</dt><dd><p>Extracts <tt class="REPLACEABLE"><i>$substring</i></tt>
        at beginning of <tt class="REPLACEABLE"><i>$string</i></tt>,
        where <tt class="REPLACEABLE"><i>$substring</i></tt> is a <a href="#REGEXREF">regular expression</a>.</p></dd><dt>expr "$string" : '\($substring\)'</dt><dd><p>Extracts <tt class="REPLACEABLE"><i>$substring</i></tt>
        at beginning of <tt class="REPLACEABLE"><i>$string</i></tt>,
        where <tt class="REPLACEABLE"><i>$substring</i></tt> is a regular
        expression.</p><p>	    <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">stringZ=abcABC123ABCabc
  #       =======	    
  
  echo `expr match "$stringZ" '\(.[b-c]*[A-Z]..[0-9]\)'`   # abcABC1
  echo `expr "$stringZ" : '\(.[b-c]*[A-Z]..[0-9]\)'`       # abcABC1
  echo `expr "$stringZ" : '\(.......\)'`                   # abcABC1
  # All of the above forms give an identical result.</pre></font></td></tr></tbody></table>
        </p></dd><dt>expr match "$string" '.*\($substring\)'</dt><dd><p>Extracts <tt class="REPLACEABLE"><i>$substring</i></tt>
        at <em>end</em> of
        <tt class="REPLACEABLE"><i>$string</i></tt>, where
        <tt class="REPLACEABLE"><i>$substring</i></tt> is a regular
        expression.</p></dd><dt>expr "$string" : '.*\($substring\)'</dt><dd><p>Extracts <tt class="REPLACEABLE"><i>$substring</i></tt>
        at <em>end</em> of <tt class="REPLACEABLE"><i>$string</i></tt>,
        where <tt class="REPLACEABLE"><i>$substring</i></tt> is a regular
        expression.</p><p>	    <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">stringZ=abcABC123ABCabc
  #                ======
  
  echo `expr match "$stringZ" '.*\([A-C][A-C][A-C][a-c]*\)'`    # ABCabc
  echo `expr "$stringZ" : '.*\(......\)'`                       # ABCabc</pre></font></td></tr></tbody></table>
  
        </p></dd></dl></div><p></p><div class="VARIABLELIST"><p><b>Substring Removal</b></p><dl><dt>${string#substring}</dt><dd><p>Deletes shortest match of
        <tt class="REPLACEABLE"><i>$substring</i></tt> from
        <em>front</em> of
        <tt class="REPLACEABLE"><i>$string</i></tt>.</p></dd><dt>${string##substring}</dt><dd><p>Deletes longest match of
        <tt class="REPLACEABLE"><i>$substring</i></tt> from
        <em>front</em> of
        <tt class="REPLACEABLE"><i>$string</i></tt>.</p><p>  
      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">stringZ=abcABC123ABCabc
  #       |----|          shortest
  #       |----------|    longest
  
  echo ${stringZ#a*C}      # 123ABCabc
  # Strip out shortest match between 'a' and 'C'.
  
  echo ${stringZ##a*C}     # abc
  # Strip out longest match between 'a' and 'C'.
  
  
  
  # You can parameterize the substrings.
  
  X='a*C'
  
  echo ${stringZ#$X}      # 123ABCabc
  echo ${stringZ##$X}     # abc
                          # As above.</pre></font></td></tr></tbody></table>
      </p></dd><dt>${string%substring}</dt><dd><p>Deletes shortest match of
        <tt class="REPLACEABLE"><i>$substring</i></tt> from
        <em>back</em> of
        <tt class="REPLACEABLE"><i>$string</i></tt>.</p><p>For example:
        <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Rename all filenames in $PWD with "TXT" suffix to a "txt" suffix.
  # For example, "file1.TXT" becomes "file1.txt" . . .
  
  SUFF=TXT
  suff=txt
  
  for i in $(ls *.$SUFF)
  do
    mv -f $i ${i%.$SUFF}.$suff
    #  Leave unchanged everything *except* the shortest pattern match
    #+ starting from the right-hand-side of the variable $i . . .
  done ### This could be condensed into a "one-liner" if desired.
  
  # Thank you, Rory Winston.</pre></font></td></tr></tbody></table>
      </p></dd><dt>${string%%substring}</dt><dd><p>Deletes longest match of
        <tt class="REPLACEABLE"><i>$substring</i></tt> from
        <em>back</em> of
        <tt class="REPLACEABLE"><i>$string</i></tt>.</p><p>  
      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">stringZ=abcABC123ABCabc
  #                    ||     shortest
  #        |------------|     longest
  
  echo ${stringZ%b*c}      # abcABC123ABCa
  # Strip out shortest match between 'b' and 'c', from back of $stringZ.
  
  echo ${stringZ%%b*c}     # a
  # Strip out longest match between 'b' and 'c', from back of $stringZ.</pre></font></td></tr></tbody></table>
      </p><p>This operator is useful for generating filenames.</p><div class="EXAMPLE"><a name="CVT"></a><p><b>Example 10-3. Converting graphic file formats, with filename change</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  #  cvt.sh:
  #  Converts all the MacPaint image files in a directory to "pbm" format.
  
  #  Uses the "macptopbm" binary from the "netpbm" package,
  #+ which is maintained by Brian Henderson (bryanh@giraffe-data.com).
  #  Netpbm is a standard part of most Linux distros.
  
  OPERATION=macptopbm
  SUFFIX=pbm          # New filename suffix. 
  
  if [ -n "$1" ]
  then
    directory=$1      # If directory name given as a script argument...
  else
    directory=$PWD    # Otherwise use current working directory.
  fi  
    
  #  Assumes all files in the target directory are MacPaint image files,
  #+ with a ".mac" filename suffix.
  
  for file in $directory/*    # Filename globbing.
  do
    filename=${file%.*c}      #  Strip ".mac" suffix off filename
                              #+ ('.*c' matches everything
            #+ between '.' and 'c', inclusive).
    $OPERATION $file &gt; "$filename.$SUFFIX"
                              # Redirect conversion to new filename.
    rm -f $file               # Delete original files after converting.   
    echo "$filename.$SUFFIX"  # Log what is happening to stdout.
  done
  
  exit 0
  
  # Exercise:
  # --------
  #  As it stands, this script converts *all* the files in the current
  #+ working directory.
  #  Modify it to work *only* on files with a ".mac" suffix.
  
  
  
  # *** And here's another way to do it. *** #
  
  #!/bin/bash
  # Batch convert into different graphic formats.
  # Assumes imagemagick installed (standard in most Linux distros).
  
  INFMT=png   # Can be tif, jpg, gif, etc.
  OUTFMT=pdf  # Can be tif, jpg, gif, pdf, etc.
  
  for pic in *"$INFMT"
  do
    p2=$(ls "$pic" | sed -e s/\.$INFMT//)
    # echo $p2
      convert "$pic" $p2.$OUTFMT
      done
  
  exit $?</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="RA2OGG"></a><p><b>Example 10-4. Converting streaming audio files to
          <i class="FIRSTTERM">ogg</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # ra2ogg.sh: Convert streaming audio files (*.ra) to ogg.
  
  # Uses the "mplayer" media player program:
  #      http://www.mplayerhq.hu/homepage
  # Uses the "ogg" library and "oggenc":
  #      http://www.xiph.org/
  #
  # This script may need appropriate codecs installed, such as sipr.so ...
  # Possibly also the compat-libstdc++ package.
  
  
  OFILEPREF=${1%%ra}      # Strip off the "ra" suffix.
  OFILESUFF=wav           # Suffix for wav file.
  OUTFILE="$OFILEPREF""$OFILESUFF"
  E_NOARGS=85
  
  if [ -z "$1" ]          # Must specify a filename to convert.
  then
    echo "Usage: `basename $0` [filename]"
    exit $E_NOARGS
  fi
  
  
  ##########################################################################
  mplayer "$1" -ao pcm:file=$OUTFILE
  oggenc "$OUTFILE"  # Correct file extension automatically added by oggenc.
  ##########################################################################
  
  rm "$OUTFILE"      # Delete intermediate *.wav file.
                     # If you want to keep it, comment out above line.
  
  exit $?
  
  #  Note:
  #  ----
  #  On a Website, simply clicking on a *.ram streaming audio file
  #+ usually only downloads the URL of the actual *.ra audio file.
  #  You can then use "wget" or something similar
  #+ to download the *.ra file itself.
  
  
  #  Exercises:
  #  ---------
  #  As is, this script converts only *.ra filenames.
  #  Add flexibility by permitting use of *.ram and other filenames.
  #
  #  If you're really ambitious, expand the script
  #+ to do automatic downloads and conversions of streaming audio files.
  #  Given a URL, batch download streaming audio files (using "wget")
  #+ and convert them on the fly.</pre></font></td></tr></tbody></table></div><p><a name="GETOPTSIMPLE1"></a></p><p>A simple emulation of <a href="#GETOPTY">getopt</a>
        using substring-extraction constructs.</p><div class="EXAMPLE"><a name="GETOPTSIMPLE"></a><p><b>Example 10-5. Emulating <i class="FIRSTTERM">getopt</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # getopt-simple.sh
  # Author: Chris Morgan
  # Used in the ABS Guide with permission.
  
  
  getopt_simple()
  {
      echo "getopt_simple()"
      echo "Parameters are '$*'"
      until [ -z "$1" ]
      do
        echo "Processing parameter of: '$1'"
        if [ ${1:0:1} = '/' ]
        then
            tmp=${1:1}               # Strip off leading '/' . . .
            parameter=${tmp%%=*}     # Extract name.
            value=${tmp##*=}         # Extract value.
            echo "Parameter: '$parameter', value: '$value'"
            eval $parameter=$value
        fi
        shift
      done
  }
  
  # Pass all options to getopt_simple().
  getopt_simple $*
  
  echo "test is '$test'"
  echo "test2 is '$test2'"
  
  exit 0  # See also, UseGetOpt.sh, a modified version of this script.
  
  ---
  
  sh getopt_example.sh /test=value1 /test2=value2
  
  Parameters are '/test=value1 /test2=value2'
  Processing parameter of: '/test=value1'
  Parameter: 'test', value: 'value1'
  Processing parameter of: '/test2=value2'
  Parameter: 'test2', value: 'value2'
  test is 'value1'
  test2 is 'value2'
  </pre></font></td></tr></tbody></table></div></dd></dl></div><p></p><div class="VARIABLELIST"><p><b>Substring Replacement</b></p><dl><dt><a name="SUBSTRREPL00"></a>${string/substring/replacement}</dt><dd><p>	    Replace first <i class="FIRSTTERM">match</i> of
        <tt class="REPLACEABLE"><i>$substring</i></tt> with
        <tt class="REPLACEABLE"><i>$replacement</i></tt>.
          <a name="AEN6164" href="#FTN.AEN6164"><span class="footnote">[50]</span></a>
        </p></dd><dt><a name="SUBSTRREPL01"></a>${string//substring/replacement}</dt><dd><p>Replace all matches of
        <tt class="REPLACEABLE"><i>$substring</i></tt> with
        <tt class="REPLACEABLE"><i>$replacement</i></tt>.</p><p>  
      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">stringZ=abcABC123ABCabc
  
  echo ${stringZ/abc/xyz}       # xyzABC123ABCabc
                                # Replaces first match of 'abc' with 'xyz'.
  
  echo ${stringZ//abc/xyz}      # xyzABC123ABCxyz
                                # Replaces all matches of 'abc' with # 'xyz'.
  
  echo  ---------------
  echo "$stringZ"               # abcABC123ABCabc
  echo  ---------------
                                # The string itself is not altered!
  
  # Can the match and replacement strings be parameterized?
  match=abc
  repl=000
  echo ${stringZ/$match/$repl}  # 000ABC123ABCabc
  #              ^      ^         ^^^
  echo ${stringZ//$match/$repl} # 000ABC123ABC000
  # Yes!          ^      ^        ^^^         ^^^
  
  echo
  
  # What happens if no $replacement string is supplied?
  echo ${stringZ/abc}           # ABC123ABCabc
  echo ${stringZ//abc}          # ABC123ABC
  # A simple deletion takes place.</pre></font></td></tr></tbody></table>
      </p></dd><dt><a name="SUBSTRREPL02"></a>${string/#substring/replacement}</dt><dd><p>If <tt class="REPLACEABLE"><i>$substring</i></tt> matches
        <em>front</em> end of
        <tt class="REPLACEABLE"><i>$string</i></tt>, substitute
        <tt class="REPLACEABLE"><i>$replacement</i></tt> for
        <tt class="REPLACEABLE"><i>$substring</i></tt>.</p></dd><dt><a name="SUBSTRREPL03"></a>${string/%substring/replacement}</dt><dd><p>If <tt class="REPLACEABLE"><i>$substring</i></tt> matches
        <em>back</em> end of
        <tt class="REPLACEABLE"><i>$string</i></tt>, substitute
        <tt class="REPLACEABLE"><i>$replacement</i></tt> for
        <tt class="REPLACEABLE"><i>$substring</i></tt>.</p><p>  
            <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">stringZ=abcABC123ABCabc
  
  echo ${stringZ/#abc/XYZ}          # XYZABC123ABCabc
                                    # Replaces front-end match of 'abc' with 'XYZ'.
  
  echo ${stringZ/%abc/XYZ}          # abcABC123ABCXYZ
                                    # Replaces back-end match of 'abc' with 'XYZ'.</pre></font></td></tr></tbody></table>
      </p></dd></dl></div><div class="SECT2"><hr><h2 class="SECT2"><a name="AWKSTRINGMANIP"></a>10.1.1. Manipulating strings using awk</h2><p><a name="AWKSTRINGMANIP2"></a></p><p>A Bash script may invoke the string manipulation facilities of
        <a href="#AWKREF">awk</a> as an alternative to using its
        built-in operations.</p><div class="EXAMPLE"><a name="SUBSTRINGEX"></a><p><b>Example 10-6. Alternate ways of extracting and locating substrings</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # substring-extraction.sh
  
  String=23skidoo1
  #      012345678    Bash
  #      123456789    awk
  # Note different string indexing system:
  # Bash numbers first character of string as 0.
  # Awk  numbers first character of string as 1.
  
  echo ${String:2:4} # position 3 (0-1-2), 4 characters long
                                           # skid
  
  # The awk equivalent of ${string:pos:length} is substr(string,pos,length).
  echo | awk '
  { print substr("'"${String}"'",3,4)      # skid
  }
  '
  #  Piping an empty "echo" to awk gives it dummy input,
  #+ and thus makes it unnecessary to supply a filename.
  
  echo "----"
  
  # And likewise:
  
  echo | awk '
  { print index("'"${String}"'", "skid")      # 3
  }                                           # (skid starts at position 3)
  '   # The awk equivalent of "expr index" ...
  
  exit 0</pre></font></td></tr></tbody></table></div></div><div class="SECT2"><hr><h2 class="SECT2"><a name="STRFDISC"></a>10.1.2. Further Reference</h2><p>For more on string manipulation in scripts, refer to <a href="#PARAMETER-SUBSTITUTION">Section 10.2</a> and the
         <a href="#EXPEXTRSUB">relevant section</a> of the <a href="#EXPRREF">expr</a> command listing.</p><p>Script examples:
        </p><p></p><ol type="1"><li><p><a href="#EX45">Example 16-9</a></p></li><li><p><a href="#LENGTH">Example 10-9</a></p></li><li><p><a href="#PATTMATCHING">Example 10-10</a></p></li><li><p><a href="#RFE">Example 10-11</a></p></li><li><p><a href="#VARMATCH">Example 10-13</a></p></li><li><p><a href="#INSERTIONSORT">Example A-36</a></p></li><li><p><a href="#QKY">Example A-41</a></p></li></ol>
        <p></p></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="PARAMETER-SUBSTITUTION"></a>10.2. Parameter Substitution</h1><p><a name="PARAMSUBREF"></a></p><p></p><div class="VARIABLELIST"><p><b><a name="PSSUB1"></a>Manipulating and/or expanding variables</b></p><dl><dt><tt class="USERINPUT"><b>${parameter}</b></tt></dt><dd><p>Same as <tt class="REPLACEABLE"><i>$parameter</i></tt>, i.e.,
        value of the variable
        <tt class="REPLACEABLE"><i>parameter</i></tt>.
        In certain contexts, only the less ambiguous
        <tt class="REPLACEABLE"><i>${parameter}</i></tt> form
        works.</p><p>May be used for concatenating variables with strings.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">your_id=${USER}-on-${HOSTNAME}
  echo "$your_id"
  #
  echo "Old \$PATH = $PATH"
  PATH=${PATH}:/opt/bin  # Add /opt/bin to $PATH for duration of script.
  echo "New \$PATH = $PATH"</pre></font></td></tr></tbody></table></p></dd><dt><a name="DEFPARAM1"></a><tt class="USERINPUT"><b>${parameter-default}</b></tt>, <tt class="USERINPUT"><b>${parameter:-default}</b></tt></dt><dd><p>If parameter not set, use default.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">var1=1
  var2=2
  # var3 is unset.
  
  echo ${var1-$var2}   # 1
  echo ${var3-$var2}   # 2
  #           ^          Note the $ prefix.
  
  
  
  echo ${username-`whoami`}
  # Echoes the result of `whoami`, if variable $username is still unset.</pre></font></td></tr></tbody></table></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p><a name="UNDDR"></a><tt class="REPLACEABLE"><i>${parameter-default}</i></tt>
        and <tt class="REPLACEABLE"><i>${parameter:-default}</i></tt>
        are almost equivalent. The extra <span class="TOKEN">:</span> makes
        a difference only when <tt class="PARAMETER"><i>parameter</i></tt>
        has been declared, but is null.  </p></td></tr></tbody></table></div><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # param-sub.sh
  
  #  Whether a variable has been declared
  #+ affects triggering of the default option
  #+ even if the variable is null.
  
  username0=
  echo "username0 has been declared, but is set to null."
  echo "username0 = ${username0-`whoami`}"
  # Will not echo.
  
  echo
  
  echo username1 has not been declared.
  echo "username1 = ${username1-`whoami`}"
  # Will echo.
  
  username2=
  echo "username2 has been declared, but is set to null."
  echo "username2 = ${username2:-`whoami`}"
  #                            ^
  # Will echo because of :- rather than just - in condition test.
  # Compare to first instance, above.
  
  
  #
  
  # Once again:
  
  variable=
  # variable has been declared, but is set to null.
  
  echo "${variable-0}"    # (no output)
  echo "${variable:-1}"   # 1
  #               ^
  
  unset variable
  
  echo "${variable-2}"    # 2
  echo "${variable:-3}"   # 3
  
  exit 0</pre></font></td></tr></tbody></table></p><p>The <i class="FIRSTTERM">default parameter</i> construct
        finds use in providing <span class="QUOTE">"missing"</span> command-line
        arguments in scripts.</p><p>		  <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">DEFAULT_FILENAME=generic.data
  filename=${1:-$DEFAULT_FILENAME}
  #  If not otherwise specified, the following command block operates
  #+ on the file "generic.data".
  #  Begin-Command-Block
  #  ...
  #  ...
  #  ...
  #  End-Command-Block
  
  
  
  #  From "hanoi2.bash" example:
  DISKS=${1:-E_NOPARAM}   # Must specify how many disks.
  #  Set $DISKS to $1 command-line-parameter,
  #+ or to $E_NOPARAM if that is unset.</pre></font></td></tr></tbody></table>
      </p><p>See also <a href="#EX58">Example 3-4</a>, <a href="#EX73">Example 31-2</a>, and <a href="#COLLATZ">Example A-6</a>.</p><p>Compare this method with <a href="#ANDDEFAULT">using an <i class="FIRSTTERM">and
        list</i> to supply a default command-line
        argument</a>.</p></dd><dt><tt class="USERINPUT"><b>${parameter=default}</b></tt>, <tt class="USERINPUT"><b>${parameter:=default}</b></tt></dt><dd><p><a name="DEFPARAM"></a></p><p>If parameter not set, set it to
        <i class="FIRSTTERM">default</i>.</p><p>Both forms nearly equivalent. The <span class="TOKEN">:</span>
        makes a difference only when <tt class="VARNAME">$parameter</tt>
        has been declared and is null,
          <a name="AEN6310" href="#FTN.AEN6310"><span class="footnote">[51]</span></a>
        as above.
          </p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo ${var=abc}   # abc
  echo ${var=xyz}   # abc
  # $var had already been set to abc, so it did not change.</pre></font></td></tr></tbody></table></p></dd><dt><a name="PARAMALTV"></a><tt class="USERINPUT"><b>${parameter+alt_value}</b></tt>, <tt class="USERINPUT"><b>${parameter:+alt_value}</b></tt></dt><dd><p>If parameter set, use
          <tt class="USERINPUT"><b>alt_value</b></tt>, else use null
          string.</p><p>Both forms nearly equivalent. The <span class="TOKEN">:</span>
          makes a difference only when
          <tt class="PARAMETER"><i>parameter</i></tt>
          has been declared and is null, see below.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo "###### \${parameter+alt_value} ########"
  echo
  
  a=${param1+xyz}
  echo "a = $a"      # a =
  
  param2=
  a=${param2+xyz}
  echo "a = $a"      # a = xyz
  
  param3=123
  a=${param3+xyz}
  echo "a = $a"      # a = xyz
  
  echo
  echo "###### \${parameter:+alt_value} ########"
  echo
  
  a=${param4:+xyz}
  echo "a = $a"      # a =
  
  param5=
  a=${param5:+xyz}
  echo "a = $a"      # a =
  # Different result from   a=${param5+xyz}
  
  param6=123
  a=${param6:+xyz}
  echo "a = $a"      # a = xyz</pre></font></td></tr></tbody></table></p></dd><dt><a name="QERRMSG"></a><tt class="USERINPUT"><b>${parameter?err_msg}</b></tt>, <tt class="USERINPUT"><b>${parameter:?err_msg}</b></tt></dt><dd><p>If parameter set, use it, else print
                  <i class="FIRSTTERM">err_msg</i> and <em>abort
                  the script</em> with an <a href="#EXITSTATUSREF">exit status</a> of
                  <span class="ERRORCODE">1</span>.</p><p>Both forms nearly equivalent. The <span class="TOKEN">:</span>
        makes a difference only when <tt class="PARAMETER"><i>parameter</i></tt>
        has been declared and is null, as above.</p></dd></dl></div><div class="EXAMPLE"><a name="EX6"></a><p><b>Example 10-7. Using parameter substitution and error messages</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  #  Check some of the system's environmental variables.
  #  This is good preventative maintenance.
  #  If, for example, $USER, the name of the person at the console, is not set,
  #+ the machine will not recognize you.
  
  : ${HOSTNAME?} ${USER?} ${HOME?} ${MAIL?}
    echo
    echo "Name of the machine is $HOSTNAME."
    echo "You are $USER."
    echo "Your home directory is $HOME."
    echo "Your mail INBOX is located in $MAIL."
    echo
    echo "If you are reading this message,"
    echo "critical environmental variables have been set."
    echo
    echo
  
  # ------------------------------------------------------
  
  #  The ${variablename?} construction can also check
  #+ for variables set within the script.
  
  ThisVariable=Value-of-ThisVariable
  #  Note, by the way, that string variables may be set
  #+ to characters disallowed in their names.
  : ${ThisVariable?}
  echo "Value of ThisVariable is $ThisVariable".
  
  echo; echo
  
  
  : ${ZZXy23AB?"ZZXy23AB has not been set."}
  #  Since ZZXy23AB has not been set,
  #+ then the script terminates with an error message.
  
  # You can specify the error message.
  # : ${variablename?"ERROR MESSAGE"}
  
  
  # Same result with:   dummy_variable=${ZZXy23AB?}
  #                     dummy_variable=${ZZXy23AB?"ZXy23AB has not been set."}
  #
  #                     echo ${ZZXy23AB?} &gt;/dev/null
  
  #  Compare these methods of checking whether a variable has been set
  #+ with "set -u" . . .
  
  
  
  echo "You will not see this message, because script already terminated."
  
  HERE=0
  exit $HERE   # Will NOT exit here.
  
  # In fact, this script will return an exit status (echo $?) of 1.</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="USAGEMESSAGE"></a><p><b>Example 10-8. Parameter substitution and <span class="QUOTE">"usage"</span> messages</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # usage-message.sh
  
  : ${1?"Usage: $0 ARGUMENT"}
  #  Script exits here if command-line parameter absent,
  #+ with following error message.
  #    usage-message.sh: 1: Usage: usage-message.sh ARGUMENT
  
  echo "These two lines echo only if command-line parameter given."
  echo "command-line parameter = \"$1\""
  
  exit 0  # Will exit here only if command-line parameter present.
  
  # Check the exit status, both with and without command-line parameter.
  # If command-line parameter present, then "$?" is 0.
  # If not, then "$?" is 1.</pre></font></td></tr></tbody></table></div><div class="FORMALPARA"><p><b>Parameter substitution and/or expansion. </b><a name="PSUB2"></a>The following expressions are
      the complement to the <b class="COMMAND">match</b>
      <tt class="REPLACEABLE"><i>in</i></tt> <b class="COMMAND">expr</b>
      string operations (see <a href="#EX45">Example 16-9</a>).
      These particular ones are used mostly in parsing file
      path names.</p></div><p></p><div class="VARIABLELIST"><p><b><a name="PSOREX1"></a>Variable length / Substring removal</b></p><dl><dt><tt class="USERINPUT"><b>${#var}</b></tt></dt><dd><p><tt class="USERINPUT"><b>String length</b></tt> (number
          of characters in <tt class="VARNAME">$var</tt>). For
          an <a href="#ARRAYREF">array</a>,
          <b class="COMMAND">${#array}</b> is the length of the
          first element in the array.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>		    Exceptions:
  
        </p><p></p><ul><li><p><a name="NUMPOSPARAM"></a></p><p>		      <b class="COMMAND">${#*}</b> and
            <b class="COMMAND">${#@}</b> give the <em>number
            of positional parameters</em>.
          </p></li><li><p>		      For an array, <b class="COMMAND">${#array[*]}</b> and
            <b class="COMMAND">${#array[@]}</b> give the number
            of elements in the array.
          </p></li></ul>
        <p></p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="LENGTH"></a><p><b>Example 10-9. Length of a variable</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # length.sh
  
  E_NO_ARGS=65
  
  if [ $# -eq 0 ]  # Must have command-line args to demo script.
  then
    echo "Please invoke this script with one or more command-line arguments."
    exit $E_NO_ARGS
  fi  
  
  var01=abcdEFGH28ij
  echo "var01 = ${var01}"
  echo "Length of var01 = ${#var01}"
  # Now, let's try embedding a space.
  var02="abcd EFGH28ij"
  echo "var02 = ${var02}"
  echo "Length of var02 = ${#var02}"
  
  echo "Number of command-line arguments passed to script = ${#@}"
  echo "Number of command-line arguments passed to script = ${#*}"
  
  exit 0</pre></font></td></tr></tbody></table></div></dd><dt><a name="PSOREX2"></a><tt class="USERINPUT"><b>${var#Pattern}</b></tt>, <tt class="USERINPUT"><b>${var##Pattern}</b></tt></dt><dd><p><a name="PSOREXSH"></a></p><p><b class="COMMAND">${var#Pattern} </b>
        Remove from <tt class="VARNAME">$var</tt>
        the <em>shortest</em> part of
        <tt class="VARNAME">$Pattern</tt> that matches
        the <tt class="REPLACEABLE"><i>front end</i></tt> of
        <tt class="VARNAME">$var</tt>.
      </p><p><a name="PSOREXLO"></a></p><p><b class="COMMAND">${var##Pattern} </b>
        Remove from <tt class="VARNAME">$var</tt>
        the <em>longest</em> part of
        <tt class="VARNAME">$Pattern</tt> that matches
        the <tt class="REPLACEABLE"><i>front end</i></tt> of
        <tt class="VARNAME">$var</tt>.
      </p><p>A usage illustration from <a href="#DAYSBETWEEN">Example A-7</a>:
      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Function from "days-between.sh" example.
  # Strips leading zero(s) from argument passed.
  
  strip_leading_zero () #  Strip possible leading zero(s)
  {                     #+ from argument passed.
    return=${1#0}       #  The "1" refers to "$1" -- passed arg.
  }                     #  The "0" is what to remove from "$1" -- strips zeros.</pre></font></td></tr></tbody></table>
      </p><p>Manfred Schwarb's more elaborate variation of the
        above:</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">strip_leading_zero2 () # Strip possible leading zero(s), since otherwise
  {                      # Bash will interpret such numbers as octal values.
    shopt -s extglob     # Turn on extended globbing.
    local val=${1##+(0)} # Use local variable, longest matching series of 0's.
    shopt -u extglob     # Turn off extended globbing.
    _strip_leading_zero2=${val:-0}
                         # If input was 0, return 0 instead of "".
  }</pre></font></td></tr></tbody></table>
      </p><p>Another usage illustration:</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo `basename $PWD`        # Basename of current working directory.
  echo "${PWD##*/}"           # Basename of current working directory.
  echo
  echo `basename $0`          # Name of script.
  echo $0                     # Name of script.
  echo "${0##*/}"             # Name of script.
  echo
  filename=test.data
  echo "${filename##*.}"      # data
                              # Extension of filename.</pre></font></td></tr></tbody></table>
      </p></dd><dt><a name="PCTPATREF"></a><tt class="USERINPUT"><b>${var%Pattern}</b></tt>, <tt class="USERINPUT"><b>${var%%Pattern}</b></tt></dt><dd><p><a name="PCTREP1"></a></p><p><b class="COMMAND">${var%Pattern}</b>
        Remove from <tt class="VARNAME">$var</tt>
        the <em>shortest</em> part of
        <tt class="VARNAME">$Pattern</tt> that matches
        the <tt class="REPLACEABLE"><i>back end</i></tt> of
        <tt class="VARNAME">$var</tt>.  </p><p><a name="PCTREP2"></a></p><p><b class="COMMAND">${var%%Pattern}</b>
        Remove from <tt class="VARNAME">$var</tt>
        the <em>longest</em> part of
        <tt class="VARNAME">$Pattern</tt> that matches
        the <tt class="REPLACEABLE"><i>back end</i></tt> of
        <tt class="VARNAME">$var</tt>.  </p></dd></dl></div><p><a href="#BASH2REF">Version 2</a> of Bash added
          additional options.</p><div class="EXAMPLE"><a name="PATTMATCHING"></a><p><b>Example 10-10. Pattern matching in parameter substitution</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # patt-matching.sh
  
  # Pattern matching  using the # ## % %% parameter substitution operators.
  
  var1=abcd12345abc6789
  pattern1=a*c  # * (wild card) matches everything between a - c.
  
  echo
  echo "var1 = $var1"           # abcd12345abc6789
  echo "var1 = ${var1}"         # abcd12345abc6789
                                # (alternate form)
  echo "Number of characters in ${var1} = ${#var1}"
  echo
  
  echo "pattern1 = $pattern1"   # a*c  (everything between 'a' and 'c')
  echo "--------------"
  echo '${var1#$pattern1}  =' "${var1#$pattern1}"    #         d12345abc6789
  # Shortest possible match, strips out first 3 characters  abcd12345abc6789
  #                                     ^^^^^               |-|
  echo '${var1##$pattern1} =' "${var1##$pattern1}"   #                  6789      
  # Longest possible match, strips out first 12 characters  abcd12345abc6789
  #                                    ^^^^^                |----------|
  
  echo; echo; echo
  
  pattern2=b*9            # everything between 'b' and '9'
  echo "var1 = $var1"     # Still  abcd12345abc6789
  echo
  echo "pattern2 = $pattern2"
  echo "--------------"
  echo '${var1%pattern2}  =' "${var1%$pattern2}"     #     abcd12345a
  # Shortest possible match, strips out last 6 characters  abcd12345abc6789
  #                                     ^^^^                         |----|
  echo '${var1%%pattern2} =' "${var1%%$pattern2}"    #     a
  # Longest possible match, strips out last 12 characters  abcd12345abc6789
  #                                    ^^^^                 |-------------|
  
  # Remember, # and ## work from the left end (beginning) of string,
  #           % and %% work from the right end.
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="RFE"></a><p><b>Example 10-11. Renaming file extensions<span class="TOKEN">:</span></b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # rfe.sh: Renaming file extensions.
  #
  #         rfe old_extension new_extension
  #
  # Example:
  # To rename all *.gif files in working directory to *.jpg,
  #          rfe gif jpg
  
  
  E_BADARGS=65
  
  case $# in
    0|1)             # The vertical bar means "or" in this context.
    echo "Usage: `basename $0` old_file_suffix new_file_suffix"
    exit $E_BADARGS  # If 0 or 1 arg, then bail out.
    ;;
  esac
  
  
  for filename in *.$1
  # Traverse list of files ending with 1st argument.
  do
    mv $filename ${filename%$1}$2
    #  Strip off part of filename matching 1st argument,
    #+ then append 2nd argument.
  done
  
  exit 0</pre></font></td></tr></tbody></table></div><p></p><div class="VARIABLELIST"><p><b><a name="EXPREPL1"></a>Variable expansion / Substring
          replacement</b></p><dl><dt></dt><dd><p>These constructs have been adopted from
        <i class="FIRSTTERM">ksh</i>.</p></dd><dt><tt class="USERINPUT"><b>${var:pos}</b></tt></dt><dd><p>Variable <tt class="REPLACEABLE"><i>var</i></tt> expanded,
          starting from offset <tt class="REPLACEABLE"><i>pos</i></tt>.
        </p></dd><dt><tt class="USERINPUT"><b>${var:pos:len}</b></tt></dt><dd><p>Expansion to a max of <tt class="REPLACEABLE"><i>len</i></tt>
          characters of variable <tt class="REPLACEABLE"><i>var</i></tt>, from offset
          <tt class="REPLACEABLE"><i>pos</i></tt>. See <a href="#PW">Example A-13</a>
          for an example of the creative use of this operator.
        </p></dd><dt><tt class="USERINPUT"><b>${var/Pattern/Replacement}</b></tt></dt><dd><p>First match of <tt class="REPLACEABLE"><i>Pattern</i></tt>,
          within <tt class="REPLACEABLE"><i>var</i></tt> replaced with
          <tt class="REPLACEABLE"><i>Replacement</i></tt>.</p><p>If <tt class="REPLACEABLE"><i>Replacement</i></tt> is
          omitted, then the first match of
          <tt class="REPLACEABLE"><i>Pattern</i></tt> is replaced by
          <em>nothing</em>, that is, deleted.</p></dd><dt><tt class="USERINPUT"><b>${var//Pattern/Replacement}</b></tt></dt><dd><div class="FORMALPARA"><p><b>Global replacement. </b><a name="PSGLOB"></a>
          All matches of <tt class="REPLACEABLE"><i>Pattern</i></tt>,
          within <tt class="REPLACEABLE"><i>var</i></tt> replaced with
          <tt class="REPLACEABLE"><i>Replacement</i></tt>.</p></div><p>As above, if <tt class="REPLACEABLE"><i>Replacement</i></tt>
          is omitted, then all occurrences of
          <tt class="REPLACEABLE"><i>Pattern</i></tt> are replaced by
          <em>nothing</em>, that is, deleted.</p><div class="EXAMPLE"><a name="EX7"></a><p><b>Example 10-12. Using pattern matching to parse arbitrary strings</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  var1=abcd-1234-defg
  echo "var1 = $var1"
  
  t=${var1#*-*}
  echo "var1 (with everything, up to and including first - stripped out) = $t"
  #  t=${var1#*-}  works just the same,
  #+ since # matches the shortest string,
  #+ and * matches everything preceding, including an empty string.
  # (Thanks, Stephane Chazelas, for pointing this out.)
  
  t=${var1##*-*}
  echo "If var1 contains a \"-\", returns empty string...   var1 = $t"
  
  
  t=${var1%*-*}
  echo "var1 (with everything from the last - on stripped out) = $t"
  
  echo
  
  # -------------------------------------------
  path_name=/home/bozo/ideas/thoughts.for.today
  # -------------------------------------------
  echo "path_name = $path_name"
  t=${path_name##/*/}
  echo "path_name, stripped of prefixes = $t"
  # Same effect as   t=`basename $path_name` in this particular case.
  #  t=${path_name%/}; t=${t##*/}   is a more general solution,
  #+ but still fails sometimes.
  #  If $path_name ends with a newline, then `basename $path_name` will not work,
  #+ but the above expression will.
  # (Thanks, S.C.)
  
  t=${path_name%/*.*}
  # Same effect as   t=`dirname $path_name`
  echo "path_name, stripped of suffixes = $t"
  # These will fail in some cases, such as "../", "/foo////", # "foo/", "/".
  #  Removing suffixes, especially when the basename has no suffix,
  #+ but the dirname does, also complicates matters.
  # (Thanks, S.C.)
  
  echo
  
  t=${path_name:11}
  echo "$path_name, with first 11 chars stripped off = $t"
  t=${path_name:11:5}
  echo "$path_name, with first 11 chars stripped off, length 5 = $t"
  
  echo
  
  t=${path_name/bozo/clown}
  echo "$path_name with \"bozo\" replaced  by \"clown\" = $t"
  t=${path_name/today/}
  echo "$path_name with \"today\" deleted = $t"
  t=${path_name//o/O}
  echo "$path_name with all o's capitalized = $t"
  t=${path_name//o/}
  echo "$path_name with all o's deleted = $t"
  
  exit 0</pre></font></td></tr></tbody></table></div></dd><dt><tt class="USERINPUT"><b>${var/#Pattern/Replacement}</b></tt></dt><dd><p>If <i class="FIRSTTERM">prefix</i> of
        <tt class="REPLACEABLE"><i>var</i></tt> matches
        <tt class="REPLACEABLE"><i>Pattern</i></tt>, then substitute
        <tt class="REPLACEABLE"><i>Replacement</i></tt> for
        <tt class="REPLACEABLE"><i>Pattern</i></tt>.</p></dd><dt><tt class="USERINPUT"><b>${var/%Pattern/Replacement}</b></tt></dt><dd><p>If <i class="FIRSTTERM">suffix</i> of
        <tt class="REPLACEABLE"><i>var</i></tt> matches
        <tt class="REPLACEABLE"><i>Pattern</i></tt>, then substitute
        <tt class="REPLACEABLE"><i>Replacement</i></tt> for
        <tt class="REPLACEABLE"><i>Pattern</i></tt>.</p><div class="EXAMPLE"><a name="VARMATCH"></a><p><b>Example 10-13. Matching patterns at prefix or suffix of string</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # var-match.sh:
  # Demo of pattern replacement at prefix / suffix of string.
  
  v0=abc1234zip1234abc    # Original variable.
  echo "v0 = $v0"         # abc1234zip1234abc
  echo
  
  # Match at prefix (beginning) of string.
  v1=${v0/#abc/ABCDEF}    # abc1234zip1234abc
                          # |-|
  echo "v1 = $v1"         # ABCDEF1234zip1234abc
                          # |----|
  
  # Match at suffix (end) of string.
  v2=${v0/%abc/ABCDEF}    # abc1234zip123abc
                          #              |-|
  echo "v2 = $v2"         # abc1234zip1234ABCDEF
                          #               |----|
  
  echo
  
  #  ----------------------------------------------------
  #  Must match at beginning / end of string,
  #+ otherwise no replacement results.
  #  ----------------------------------------------------
  v3=${v0/#123/000}       # Matches, but not at beginning.
  echo "v3 = $v3"         # abc1234zip1234abc
                          # NO REPLACEMENT.
  v4=${v0/%123/000}       # Matches, but not at end.
  echo "v4 = $v4"         # abc1234zip1234abc
                          # NO REPLACEMENT.
  
  exit 0			</pre></font></td></tr></tbody></table></div></dd><dt><a name="VARPREFIXM"></a><tt class="USERINPUT"><b>${!varprefix*}</b></tt>, <tt class="USERINPUT"><b>${!varprefix@}</b></tt></dt><dd><p>Matches <em>names</em> of all
        previously declared variables beginning
          with <tt class="PARAMETER"><i>varprefix</i></tt>.
            <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># This is a variation on indirect reference, but with a * or @.
  # Bash, version 2.04, adds this feature.
  
  xyz23=whatever
  xyz24=
  
  a=${!xyz*}         #  Expands to *names* of declared variables
  # ^ ^   ^           + beginning with "xyz".
  echo "a = $a"      #  a = xyz23 xyz24
  a=${!xyz@}         #  Same as above.
  echo "a = $a"      #  a = xyz23 xyz24
  
  echo "---"
  
  abc23=something_else
  b=${!abc*}
  echo "b = $b"      #  b = abc23
  c=${!b}            #  Now, the more familiar type of indirect reference.
  echo $c            #  something_else</pre></font></td></tr></tbody></table>
                    </p></dd></dl></div></div></div><div class="CHAPTER"><hr><h1><a name="LOOPS"></a>Chapter 11. Loops and Branches</h1><table border="0" width="100%" cellspacing="0" cellpadding="0" class="EPIGRAPH"><tbody><tr><td width="45%">&nbsp;</td><td width="45%" align="LEFT" valign="TOP"><i><p><i>What needs this iteration, woman?</i></p><p><i>--Shakespeare, <tt class="REPLACEABLE"><i>Othello</i></tt></i></p></i></td></tr></tbody></table><p><a name="LOOPREF00"></a></p><p>Operations on code blocks are the key to structured and organized
          shell scripts. Looping and branching constructs provide the tools for
    accomplishing this.</p><div class="SECT1"><hr><h1 class="SECT1"><a name="LOOPS1"></a>11.1. Loops</h1><p>A <i class="FIRSTTERM">loop</i> is a block of code that
    <i class="FIRSTTERM">iterates</i>
  
      <a name="AEN6560" href="#FTN.AEN6560"><span class="footnote">[52]</span></a>
  
    a list of commands
    as long as the <i class="FIRSTTERM">loop control condition</i>
    is true.</p><p></p><div class="VARIABLELIST"><p><b><a name="FORLOOPREF1"></a>for loops</b></p><dl><dt><b class="COMMAND">for <tt class="PARAMETER"><i>arg</i></tt> in
        <tt class="REPLACEABLE"><i>[list]</i></tt></b></dt><dd><p>This is the basic looping construct. It differs significantly
          from its <i class="FIRSTTERM">C</i> counterpart.</p><p><a name="DOINREF"></a></p><p></p><p><b class="COMMAND">for</b>   <tt class="REPLACEABLE"><i>arg</i></tt>   in  [<tt class="REPLACEABLE"><i>list</i></tt>]<br>  do <br>  <tt class="REPLACEABLE"><i>&nbsp;command(s)</i></tt>... <br>  done </p><p></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>During each pass through the loop,
          <tt class="REPLACEABLE"><i>arg</i></tt> takes on the
          value of each successive variable in the
          <tt class="REPLACEABLE"><i>list</i></tt>.</p></td></tr></tbody></table></div><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">for arg in "$var1" "$var2" "$var3" ... "$varN"  
  # In pass 1 of the loop, arg = $var1	    
  # In pass 2 of the loop, arg = $var2	    
  # In pass 3 of the loop, arg = $var3	    
  # ...
  # In pass N of the loop, arg = $varN
  
  # Arguments in [list] quoted to prevent possible word splitting.</pre></font></td></tr></tbody></table></p><p>The argument <tt class="REPLACEABLE"><i>list</i></tt> may
        contain <a href="#ASTERISKREF">wild cards</a>.</p><p><a name="NEEDSEMICOLON"></a></p><p>If <i class="FIRSTTERM">do</i> is on same line as
          <i class="FIRSTTERM">for</i>, there needs to be a semicolon
          after list.</p><p></p><p><b class="COMMAND">for</b>   <tt class="REPLACEABLE"><i>arg</i></tt>   in  [<tt class="REPLACEABLE"><i>list</i></tt>]  ;   do <br></p><p></p><div class="EXAMPLE"><a name="EX22"></a><p><b>Example 11-1. Simple <i class="FIRSTTERM">for</i> loops</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Listing the planets.
  
  for planet in Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto
  do
    echo $planet  # Each planet on a separate line.
  done
  
  echo; echo
  
  for planet in "Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
      # All planets on same line.
      # Entire 'list' enclosed in quotes creates a single variable.
      # Why? Whitespace incorporated into the variable.
  do
    echo $planet
  done
  
  echo; echo "Whoops! Pluto is no longer a planet!"
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="MULTPARAML"></a></p><p>Each <tt class="USERINPUT"><b>[list]</b></tt> element
          may contain multiple parameters. This is useful when
          processing parameters in groups. In such cases,
          use the <a href="#SETREF">set</a> command
          (see <a href="#EX34">Example 15-16</a>) to force parsing of each
          <tt class="USERINPUT"><b>[list]</b></tt> element and assignment of
          each component to the positional parameters.</p><div class="EXAMPLE"><a name="EX22A"></a><p><b>Example 11-2. <i class="FIRSTTERM">for</i> loop with two parameters in each
          [list] element</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Planets revisited.
  
  # Associate the name of each planet with its distance from the sun.
  
  for planet in "Mercury 36" "Venus 67" "Earth 93"  "Mars 142" "Jupiter 483"
  do
    set -- $planet  #  Parses variable "planet"
                    #+ and sets positional parameters.
    #  The "--" prevents nasty surprises if $planet is null or
    #+ begins with a dash.
  
    #  May need to save original positional parameters,
    #+ since they get overwritten.
    #  One way of doing this is to use an array,
    #         original_params=("$@")
  
    echo "$1		$2,000,000 miles from the sun"
    #-------two  tabs---concatenate zeroes onto parameter $2
  done
  
  # (Thanks, S.C., for additional clarification.)
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="PARAMLI"></a></p><p>A variable may supply the <tt class="USERINPUT"><b>[list]</b></tt> in a
          <i class="FIRSTTERM">for loop</i>.</p><div class="EXAMPLE"><a name="FILEINFO"></a><p><b>Example 11-3. <em>Fileinfo:</em> operating on a file list
            contained in a variable</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # fileinfo.sh
  
  FILES="/usr/sbin/accept
  /usr/sbin/pwck
  /usr/sbin/chroot
  /usr/bin/fakefile
  /sbin/badblocks
  /sbin/ypbind"     # List of files you are curious about.
                    # Threw in a dummy file, /usr/bin/fakefile.
  
  echo
  
  for file in $FILES
  do
  
    if [ ! -e "$file" ]       # Check if file exists.
    then
      echo "$file does not exist."; echo
      continue                # On to next.
     fi
  
    ls -l $file | awk '{ print $8 "         file size: " $5 }'  # Print 2 fields.
    whatis `basename $file`   # File info.
    # Note that the whatis database needs to have been set up for this to work.
    # To do this, as root run /usr/bin/makewhatis.
    echo
  done  
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="PARAMLI2"></a></p><p>The <tt class="USERINPUT"><b>[list]</b></tt> in a
          <i class="FIRSTTERM">for loop</i> may be parameterized.</p><div class="EXAMPLE"><a name="FILEINFO01"></a><p><b>Example 11-4. Operating on a parameterized file list</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  filename="*txt"
  
  for file in $filename
  do
   echo "Contents of $file"
   echo "---"
   cat "$file"
   echo
  done</pre></font></td></tr></tbody></table></div><p><a name="LIGLOB"></a></p><p>If the <tt class="USERINPUT"><b>[list]</b></tt> in a
          <i class="FIRSTTERM">for loop</i> contains wild cards
          (<span class="TOKEN">*</span> and <span class="TOKEN">?</span>) used in filename
          expansion, then <a href="#GLOBBINGREF">globbing</a>
          takes place.</p><div class="EXAMPLE"><a name="LISTGLOB"></a><p><b>Example 11-5. Operating on files with a <i class="FIRSTTERM">for</i> loop</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # list-glob.sh: Generating [list] in a for-loop, using "globbing" ...
  # Globbing = filename expansion.
  
  echo
  
  for file in *
  #           ^  Bash performs filename expansion
  #+             on expressions that globbing recognizes.
  do
    ls -l "$file"  # Lists all files in $PWD (current directory).
    #  Recall that the wild card character "*" matches every filename,
    #+ however, in "globbing," it doesn't match dot-files.
  
    #  If the pattern matches no file, it is expanded to itself.
    #  To prevent this, set the nullglob option
    #+   (shopt -s nullglob).
    #  Thanks, S.C.
  done
  
  echo; echo
  
  for file in [jx]*
  do
    rm -f $file    # Removes only files beginning with "j" or "x" in $PWD.
    echo "Removed file \"$file\"".
  done
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="OMITLIST"></a></p><p>Omitting the <tt class="USERINPUT"><b>in [list]</b></tt> part of a
          <i class="FIRSTTERM">for loop</i> causes the loop to operate
          on <span class="TOKEN">$@</span> -- the <a href="#POSPARAMREF">	      positional parameters</a>. A particularly clever
          illustration of this is <a href="#PRIMES">Example A-15</a>. See also <a href="#REVPOSPARAMS">Example 15-17</a>.</p><div class="EXAMPLE"><a name="EX23"></a><p><b>Example 11-6. Missing <tt class="USERINPUT"><b>in [list]</b></tt> in a
      <i class="FIRSTTERM">for</i> loop</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  #  Invoke this script both with and without arguments,
  #+ and see what happens.
  
  for a
  do
   echo -n "$a "
  done
  
  #  The 'in list' missing, therefore the loop operates on '$@'
  #+ (command-line argument list, including whitespace).
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="LOOPCS"></a></p><p>It is possible to use <a href="#COMMANDSUBREF">command substitution</a>
          to generate the <tt class="USERINPUT"><b>[list]</b></tt> in a
          <i class="FIRSTTERM">for loop</i>. See also <a href="#EX53">Example 16-54</a>,
          <a href="#SYMLINKS">Example 11-11</a> and <a href="#BASE">Example 16-48</a>.</p><div class="EXAMPLE"><a name="FORLOOPCMD"></a><p><b>Example 11-7. Generating the <tt class="USERINPUT"><b>[list]</b></tt> in
          a <i class="FIRSTTERM">for</i> loop with command substitution</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  #  for-loopcmd.sh: for-loop with [list]
  #+ generated by command substitution.
  
  NUMBERS="9 7 3 8 37.53"
  
  for number in `echo $NUMBERS`  # for number in 9 7 3 8 37.53
  do
    echo -n "$number "
  done
  
  echo 
  exit 0</pre></font></td></tr></tbody></table></div><p>Here is a somewhat more complex example of using command
          substitution to create the <tt class="USERINPUT"><b>[list]</b></tt>.</p><div class="EXAMPLE"><a name="BINGREP"></a><p><b>Example 11-8. A <i class="FIRSTTERM">grep</i> replacement
            for binary files</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # bin-grep.sh: Locates matching strings in a binary file.
  
  # A "grep" replacement for binary files.
  # Similar effect to "grep -a"
  
  E_BADARGS=65
  E_NOFILE=66
  
  if [ $# -ne 2 ]
  then
    echo "Usage: `basename $0` search_string filename"
    exit $E_BADARGS
  fi
  
  if [ ! -f "$2" ]
  then
    echo "File \"$2\" does not exist."
    exit $E_NOFILE
  fi  
  
  
  IFS=$'\012'       # Per suggestion of Anton Filippov.
                    # was:  IFS="\n"
  for word in $( strings "$2" | grep "$1" )
  # The "strings" command lists strings in binary files.
  # Output then piped to "grep", which tests for desired string.
  do
    echo $word
  done
  
  # As S.C. points out, lines 23 - 30 could be replaced with the simpler
  #    strings "$2" | grep "$1" | tr -s "$IFS" '[\n*]'
  
  
  #  Try something like  "./bin-grep.sh mem /bin/ls"
  #+ to exercise this script.
  
  exit 0</pre></font></td></tr></tbody></table></div><p>More of the same.</p><div class="EXAMPLE"><a name="USERLIST"></a><p><b>Example 11-9. Listing all users on the system</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # userlist.sh
  
  PASSWORD_FILE=/etc/passwd
  n=1           # User number
  
  for name in $(awk 'BEGIN{FS=":"}{print $1}' &lt; "$PASSWORD_FILE" )
  # Field separator = :    ^^^^^^
  # Print first field              ^^^^^^^^
  # Get input from password file  /etc/passwd  ^^^^^^^^^^^^^^^^^
  do
    echo "USER #$n = $name"
    let "n += 1"
  done  
  
  
  # USER #1 = root
  # USER #2 = bin
  # USER #3 = daemon
  # ...
  # USER #33 = bozo
  
  exit $?
  
  #  Discussion:
  #  ----------
  #  How is it that an ordinary user, or a script run by same,
  #+ can read /etc/passwd? (Hint: Check the /etc/passwd file permissions.)
  #  Is this a security hole? Why or why not?</pre></font></td></tr></tbody></table></div><p>Yet another example of the <tt class="USERINPUT"><b>[list]</b></tt>
          resulting from command substitution.</p><div class="EXAMPLE"><a name="FINDSTRING"></a><p><b>Example 11-10. Checking all the binaries in a directory for
          authorship</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # findstring.sh:
  # Find a particular string in the binaries in a specified directory.
  
  directory=/usr/bin/
  fstring="Free Software Foundation"  # See which files come from the FSF.
  
  for file in $( find $directory -type f -name '*' | sort )
  do
    strings -f $file | grep "$fstring" | sed -e "s%$directory%%"
    #  In the "sed" expression,
    #+ it is necessary to substitute for the normal "/" delimiter
    #+ because "/" happens to be one of the characters filtered out.
    #  Failure to do so gives an error message. (Try it.)
  done  
  
  exit $?
  
  #  Exercise (easy):
  #  ---------------
  #  Convert this script to take command-line parameters
  #+ for $directory and $fstring.</pre></font></td></tr></tbody></table></div><p>A final example of <tt class="USERINPUT"><b>[list]</b></tt>
           / command substitution, but this time
           the <span class="QUOTE">"command"</span> is a <a href="#FUNCTIONREF">function</a>.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">generate_list ()
  {
    echo "one two three"
  }
  
  for word in $(generate_list)  # Let "word" grab output of function.
  do
    echo "$word"
  done
  
  # one
  # two
  # three</pre></font></td></tr></tbody></table></p><p><a name="LOOPREDIR"></a></p><p>The output of a <i class="FIRSTTERM">for loop</i> may
          be piped to a command or commands.</p><div class="EXAMPLE"><a name="SYMLINKS"></a><p><b>Example 11-11. Listing the <i class="FIRSTTERM">symbolic
            links</i> in a directory</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # symlinks.sh: Lists symbolic links in a directory.
  
  
  directory=${1-`pwd`}
  #  Defaults to current working directory,
  #+ if not otherwise specified.
  #  Equivalent to code block below.
  # ----------------------------------------------------------
  # ARGS=1                 # Expect one command-line argument.
  #
  # if [ $# -ne "$ARGS" ]  # If not 1 arg...
  # then
  #   directory=`pwd`      # current working directory
  # else
  #   directory=$1
  # fi
  # ----------------------------------------------------------
  
  echo "symbolic links in directory \"$directory\""
  
  for file in "$( find $directory -type l )"   # -type l = symbolic links
  do
    echo "$file"
  done | sort                                  # Otherwise file list is unsorted.
  #  Strictly speaking, a loop isn't really necessary here,
  #+ since the output of the "find" command is expanded into a single word.
  #  However, it's easy to understand and illustrative this way.
  
  #  As Dominik 'Aeneas' Schnitzer points out,
  #+ failing to quote  $( find $directory -type l )
  #+ will choke on filenames with embedded whitespace.
  #  containing whitespace. 
  
  exit 0
  
  
  # --------------------------------------------------------
  # Jean Helou proposes the following alternative:
  
  echo "symbolic links in directory \"$directory\""
  # Backup of the current IFS. One can never be too cautious.
  OLDIFS=$IFS
  IFS=:
  
  for file in $(find $directory -type l -printf "%p$IFS")
  do     #                              ^^^^^^^^^^^^^^^^
         echo "$file"
         done|sort
  
  # And, James "Mike" Conley suggests modifying Helou's code thusly:
  
  OLDIFS=$IFS
  IFS='' # Null IFS means no word breaks
  for file in $( find $directory -type l )
  do
    echo $file
    done | sort
  
  #  This works in the "pathological" case of a directory name having
  #+ an embedded colon.
  #  "This also fixes the pathological case of the directory name having
  #+  a colon (or space in earlier example) as well."
  </pre></font></td></tr></tbody></table></div><p>The <tt class="FILENAME">stdout</tt> of a loop may be <a href="#IOREDIRREF">redirected</a> to a file, as this slight
          modification to the previous example shows.</p><div class="EXAMPLE"><a name="SYMLINKS2"></a><p><b>Example 11-12. Symbolic links in a directory, saved to a file</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # symlinks.sh: Lists symbolic links in a directory.
  
  OUTFILE=symlinks.list                         # save-file
  
  directory=${1-`pwd`}
  #  Defaults to current working directory,
  #+ if not otherwise specified.
  
  
  echo "symbolic links in directory \"$directory\"" &gt; "$OUTFILE"
  echo "---------------------------" &gt;&gt; "$OUTFILE"
  
  for file in "$( find $directory -type l )"    # -type l = symbolic links
  do
    echo "$file"
  done | sort &gt;&gt; "$OUTFILE"                     # stdout of loop
  #           ^^^^^^^^^^^^^                       redirected to save file.
  
  # echo "Output file = $OUTFILE"
  
  exit $?</pre></font></td></tr></tbody></table></div><p><a name="LOOPCSTYLE"></a></p><p>There is an alternative syntax to a <i class="FIRSTTERM">for
          loop</i> that will look very familiar to C
          programmers. This requires <a href="#DBLPARENSREF">double parentheses</a>.</p><div class="EXAMPLE"><a name="FORLOOPC"></a><p><b>Example 11-13. A C-style <i class="FIRSTTERM">for</i> loop</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Multiple ways to count up to 10.
  
  echo
  
  # Standard syntax.
  for a in 1 2 3 4 5 6 7 8 9 10
  do
    echo -n "$a "
  done  
  
  echo; echo
  
  # +==========================================+
  
  # Using "seq" ...
  for a in `seq 10`
  do
    echo -n "$a "
  done  
  
  echo; echo
  
  # +==========================================+
  
  # Using brace expansion ...
  # Bash, version 3+.
  for a in {1..10}
  do
    echo -n "$a "
  done  
  
  echo; echo
  
  # +==========================================+
  
  # Now, let's do the same, using C-like syntax.
  
  LIMIT=10
  
  for ((a=1; a &lt;= LIMIT ; a++))  # Double parentheses, and naked "LIMIT"
  do
    echo -n "$a "
  done                           # A construct borrowed from ksh93.
  
  echo; echo
  
  # +=========================================================================+
  
  # Let's use the C "comma operator" to increment two variables simultaneously.
  
  for ((a=1, b=1; a &lt;= LIMIT ; a++, b++))
  do  # The comma concatenates operations.
    echo -n "$a-$b "
  done
  
  echo; echo
  
  exit 0</pre></font></td></tr></tbody></table></div><p>See also <a href="#QFUNCTION">Example 27-16</a>, <a href="#TWODIM">Example 27-17</a>, and <a href="#COLLATZ">Example A-6</a>.</p><p>---</p><p>Now, a <i class="FIRSTTERM">for loop</i> used in a
          <span class="QUOTE">"real-life"</span> context.</p><div class="EXAMPLE"><a name="EX24"></a><p><b>Example 11-14. Using <i class="FIRSTTERM">efax</i> in batch mode</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Faxing (must have 'efax' package installed).
  
  EXPECTED_ARGS=2
  E_BADARGS=85
  MODEM_PORT="/dev/ttyS2"   # May be different on your machine.
  #                ^^^^^      PCMCIA modem card default port.
  
  if [ $# -ne $EXPECTED_ARGS ]
  # Check for proper number of command-line args.
  then
     echo "Usage: `basename $0` phone# text-file"
     exit $E_BADARGS
  fi
  
  
  if [ ! -f "$2" ]
  then
    echo "File $2 is not a text file."
    #     File is not a regular file, or does not exist.
    exit $E_BADARGS
  fi
    
  
  fax make $2              #  Create fax-formatted files from text files.
  
  for file in $(ls $2.0*)  #  Concatenate the converted files.
                           #  Uses wild card (filename "globbing")
         #+ in variable list.
  do
    fil="$fil $file"
  done  
  
  efax -d "$MODEM_PORT"  -t "T$1" $fil   # Finally, do the work.
  # Trying adding  -o1  if above line fails.
  
  
  #  As S.C. points out, the for-loop can be eliminated with
  #     efax -d /dev/ttyS2 -o1 -t "T$1" $2.0*
  #+ but it's not quite as instructive [grin].
  
  exit $?   # Also, efax sends diagnostic messages to stdout.</pre></font></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p><a name="NODODONE"></a>The
              <a href="#KEYWORDREF">keywords</a>
              <b class="COMMAND">do</b> and <b class="COMMAND">done</b> delineate
              the <i class="FIRSTTERM">for-loop</i> command block. However,
              these may, in certain contexts, be omitted by framing the
              command block within <a href="#CODEBLOCKREF">curly
              brackets</a>
  
        <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">for((n=1; n&lt;=10; n++)) 
  # No do!
  {
    echo -n "* $n *"
  }
  # No done!
  
  
  # Outputs:
  # * 1 ** 2 ** 3 ** 4 ** 5 ** 6 ** 7 ** 8 ** 9 ** 10 *
  # And, echo $? returns 0, so Bash does not register an error.
  
  
  echo
  
  
  #  But, note that in a classic for-loop:    for n in [list] ...
  #+ a terminal semicolon is required.
  
  for n in 1 2 3
  {  echo -n "$n "; }
  #               ^
  
  
  # Thank you, YongYe, for pointing this out.</pre></font></td></tr></tbody></table>
               </p></td></tr></tbody></table></div></dd><dt><a name="WHILELOOPREF"></a><b class="COMMAND">while</b></dt><dd><p>This construct tests for a condition at the top of a
          loop, and keeps looping as long as that condition
          is true (returns a <span class="RETURNVALUE">0</span> <a href="#EXITSTATUSREF">exit status</a>).  In contrast
          to a <a href="#FORLOOPREF1">for loop</a>, a
          <i class="FIRSTTERM">while loop</i> finds use in situations
          where the number of loop repetitions is not known
          beforehand.</p><p></p><p><b class="COMMAND">while</b>  [<tt class="REPLACEABLE"><i> condition </i></tt>]<br>  do <br>  <tt class="REPLACEABLE"><i>&nbsp;command(s)</i></tt>... <br>  done </p><p></p><p>The bracket construct in a <i class="FIRSTTERM">while
          loop</i> is nothing more than our old friend,
          the <a href="#TESTCONSTRUCTS1">test brackets</a>
          used in an <i class="FIRSTTERM">if/then</i> test. In fact,
          a <i class="FIRSTTERM">while loop</i> can legally use the
          more versatile <a href="#DBLBRACKETS">double-brackets
          construct</a> (while [[ condition ]]).</p><p><a name="WHILENEEDSEMI"></a></p><p><a href="#NEEDSEMICOLON">As is the case with
          <i class="FIRSTTERM">for loops</i></a>, placing the
          <i class="FIRSTTERM">do</i> on the same line as the condition
          test requires a semicolon.</p><p></p><p><b class="COMMAND">while</b>  [<tt class="REPLACEABLE"><i> condition </i></tt>]  ;   do </p><p></p><p>Note that the <i class="FIRSTTERM">test brackets</i>
          <a href="#WHILENOBRACKETS">are <em>not</em>
          mandatory</a> in a <i class="FIRSTTERM">while</i> loop.
          See, for example,  the <a href="#GETOPTSX">getopts
          construct</a>.</p><div class="EXAMPLE"><a name="EX25"></a><p><b>Example 11-15. Simple <i class="FIRSTTERM">while</i> loop</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  var0=0
  LIMIT=10
  
  while [ "$var0" -lt "$LIMIT" ]
  #      ^                    ^
  # Spaces, because these are "test-brackets" . . .
  do
    echo -n "$var0 "        # -n suppresses newline.
    #             ^           Space, to separate printed out numbers.
  
    var0=`expr $var0 + 1`   # var0=$(($var0+1))  also works.
                            # var0=$((var0 + 1)) also works.
                            # let "var0 += 1"    also works.
  done                      # Various other methods also work.
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="EX26"></a><p><b>Example 11-16. Another <i class="FIRSTTERM">while</i> loop</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  echo
                                 # Equivalent to:
  while [ "$var1" != "end" ]     # while test "$var1" != "end"
  do
    echo "Input variable #1 (end to exit) "
    read var1                    # Not 'read $var1' (why?).
    echo "variable #1 = $var1"   # Need quotes because of "#" . . .
    # If input is 'end', echoes it here.
    # Does not test for termination condition until top of loop.
    echo
  done  
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="WHMULTCOND"></a></p><p>A <i class="FIRSTTERM">while loop</i> may have multiple
          conditions. Only the final condition determines when the loop
          terminates. This necessitates a slightly different loop syntax,
          however.</p><div class="EXAMPLE"><a name="EX26A"></a><p><b>Example 11-17. <i class="FIRSTTERM">while</i> loop with multiple conditions</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  var1=unset
  previous=$var1
  
  while echo "previous-variable = $previous"
        echo
        previous=$var1
        [ "$var1" != end ] # Keeps track of what $var1 was previously.
        # Four conditions on *while*, but only the final one controls loop.
        # The *last* exit status is the one that counts.
  do
  echo "Input variable #1 (end to exit) "
    read var1
    echo "variable #1 = $var1"
  done  
  
  # Try to figure out how this all works.
  # It's a wee bit tricky.
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="WLOOPCSTYLE"></a></p><p>As with a <i class="FIRSTTERM">for loop</i>, a
          <i class="FIRSTTERM">while loop</i> may employ C-style syntax
          by using the double-parentheses construct (see also <a href="#CVARS">Example 8-5</a>).</p><div class="EXAMPLE"><a name="WHLOOPC"></a><p><b>Example 11-18. C-style syntax in a <i class="FIRSTTERM">while</i> loop</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # wh-loopc.sh: Count to 10 in a "while" loop.
  
  LIMIT=10                 # 10 iterations.
  a=1
  
  while [ "$a" -le $LIMIT ]
  do
    echo -n "$a "
    let "a+=1"
  done                     # No surprises, so far.
  
  echo; echo
  
  # +=================================================================+
  
  # Now, we'll repeat with C-like syntax.
  
  ((a = 1))      # a=1
  # Double parentheses permit space when setting a variable, as in C.
  
  while (( a &lt;= LIMIT ))   #  Double parentheses,
  do                       #+ and no "$" preceding variables.
    echo -n "$a "
    ((a += 1))             # let "a+=1"
    # Yes, indeed.
    # Double parentheses permit incrementing a variable with C-like syntax.
  done
  
  echo
  
  # C and Java programmers can feel right at home in Bash.
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="WHILEFUNC"></a></p><p>	      Inside its test brackets, a <i class="FIRSTTERM">while loop</i>
          can call a <a href="#FUNCTIONREF">function</a>.
  
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">t=0
  
  condition ()
  {
    ((t++))
  
    if [ $t -lt 5 ]
    then
      return 0  # true
    else
      return 1  # false
    fi
  }
  
  while condition
  #     ^^^^^^^^^
  #     Function call -- four loop iterations.
  do
    echo "Still going: t = $t"
  done
  
  # Still going: t = 1
  # Still going: t = 2
  # Still going: t = 3
  # Still going: t = 4</pre></font></td></tr></tbody></table>
        
        
        
        </p><table class="SIDEBAR" border="1" cellpadding="5"><tbody><tr><td><div class="SIDEBAR"><a name="AEN6856"></a><p></p><p><a name="WHILENOBRACKETS"></a></p><p>Similar to the <a href="#IFGREPREF">if-test</a>
          construct, a <i class="FIRSTTERM">while</i> loop can omit the test
          brackets.
            <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">while condition
  do
     command(s) ...
  done</pre></font></td></tr></tbody></table></p><p></p></div></td></tr></tbody></table><p><a name="WHILEREADREF2"></a></p><p>By coupling the power of the <a href="#READREF">read</a> command with a
          <i class="FIRSTTERM">while loop</i>, we get the handy <a href="#WHILEREADREF">while read</a> construct, useful
          for reading and parsing files.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">cat $filename |   # Supply input from a file.
  while read line   # As long as there is another line to read ...
  do
    ...
  done
  
  # =========== Snippet from "sd.sh" example script ========== #
  
    while read value   # Read one data point at a time.
    do
      rt=$(echo "scale=$SC; $rt + $value" | bc)
      (( ct++ ))
    done
  
    am=$(echo "scale=$SC; $rt / $ct" | bc)
  
    echo $am; return $ct   # This function "returns" TWO values!
    #  Caution: This little trick will not work if $ct &gt; 255!
    #  To handle a larger number of data points,
    #+ simply comment out the "return $ct" above.
  } &lt;"$datafile"   # Feed in data file.</pre></font></td></tr></tbody></table></p><p><a name="WHREDIR"></a></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>A <i class="FIRSTTERM">while loop</i> may have its
          <tt class="FILENAME">stdin</tt> <a href="#REDIRREF">redirected to a file</a> by a
          <span class="TOKEN">&lt;</span> at its end.</p><p>A <i class="FIRSTTERM">while loop</i> may have its
          <tt class="FILENAME">stdin</tt> <a href="#READPIPEREF">	      supplied by a pipe</a>.</p></td></tr></tbody></table></div></dd><dt><a name="UNTILLOOPREF"></a><b class="COMMAND">until</b></dt><dd><p>This construct tests for a condition at the top of a loop, and keeps
          looping as long as that condition is
          <em>false</em> (opposite of <i class="FIRSTTERM">while
          loop</i>).</p><p></p><p><b class="COMMAND">until</b>  [<tt class="REPLACEABLE"><i> condition-is-true </i></tt>]<br>  do <br>  <tt class="REPLACEABLE"><i>&nbsp;command(s)</i></tt>... <br>  done </p><p></p><p>Note that an <i class="FIRSTTERM">until loop</i> tests for the
          terminating condition at the <em>top</em>
          of the loop, differing from a similar construct in some
          programming languages.</p><p>As is the case with <i class="FIRSTTERM">for loops</i>,
          placing the <i class="FIRSTTERM">do</i> on the same line as
          the condition test requires a semicolon.</p><p></p><p><b class="COMMAND">until</b>  [<tt class="REPLACEABLE"><i> condition-is-true </i></tt>]  ;   do </p><p></p><div class="EXAMPLE"><a name="EX27"></a><p><b>Example 11-19. <i class="FIRSTTERM">until</i> loop</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  END_CONDITION=end
  
  until [ "$var1" = "$END_CONDITION" ]
  # Tests condition here, at top of loop.
  do
    echo "Input variable #1 "
    echo "($END_CONDITION to exit)"
    read var1
    echo "variable #1 = $var1"
    echo
  done  
  
  #                     ---                        #
  
  #  As with "for" and "while" loops,
  #+ an "until" loop permits C-like test constructs.
  
  LIMIT=10
  var=0
  
  until (( var &gt; LIMIT ))
  do  # ^^ ^     ^     ^^   No brackets, no $ prefixing variables.
    echo -n "$var "
    (( var++ ))
  done    # 0 1 2 3 4 5 6 7 8 9 10 
  
  
  exit 0</pre></font></td></tr></tbody></table></div></dd></dl></div><p><a name="CHOOSELOOP"></a></p><p>How to choose between a <i class="FIRSTTERM">for</i> loop or a
      <i class="FIRSTTERM">while</i> loop or
      <i class="FIRSTTERM">until</i> loop? In <b class="COMMAND">C</b>,
      you would typically use a <i class="FIRSTTERM">for</i> loop
      when the number of loop iterations is known beforehand. With
      <i class="FIRSTTERM">Bash</i>, however, the situation is
      fuzzier. The Bash <i class="FIRSTTERM">for</i> loop is more
      loosely structured and more flexible than its equivalent in
      other languages. Therefore, feel free to use whatever type
      of loop gets the job done in the simplest way.</p></div><div class="SECT1"><hr><h1 class="SECT1"><a name="NESTEDLOOPS"></a>11.2. Nested Loops</h1><p>A <i class="FIRSTTERM">nested loop</i> is a loop within a
      loop, an inner loop within the body of an outer one. How
      this works is that the first pass of the outer loop triggers
      the inner loop, which executes to completion. Then the
      second pass of the outer loop triggers the inner loop
      again. This repeats until the outer loop finishes. Of course,
      a <i class="FIRSTTERM">break</i> within either the inner or outer
      loop would interrupt this process.</p><div class="EXAMPLE"><a name="NESTEDLOOP"></a><p><b>Example 11-20. Nested Loop</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # nested-loop.sh: Nested "for" loops.
  
  outer=1             # Set outer loop counter.
  
  # Beginning of outer loop.
  for a in 1 2 3 4 5
  do
    echo "Pass $outer in outer loop."
    echo "---------------------"
    inner=1           # Reset inner loop counter.
  
    # ===============================================
    # Beginning of inner loop.
    for b in 1 2 3 4 5
    do
      echo "Pass $inner in inner loop."
      let "inner+=1"  # Increment inner loop counter.
    done
    # End of inner loop.
    # ===============================================
  
    let "outer+=1"    # Increment outer loop counter. 
    echo              # Space between output blocks in pass of outer loop.
  done               
  # End of outer loop.
  
  exit 0</pre></font></td></tr></tbody></table></div><p>See <a href="#BUBBLE">Example 27-11</a> for an illustration of nested
      <a href="#WHILELOOPREF">while loops</a>, and <a href="#EX68">Example 27-13</a> to see a while loop nested inside an <a href="#UNTILLOOPREF">until loop</a>.</p></div><div class="SECT1"><hr><h1 class="SECT1"><a name="LOOPCONTROL"></a>11.3. Loop Control</h1><table border="0" width="100%" cellspacing="0" cellpadding="0" class="EPIGRAPH"><tbody><tr><td width="45%">&nbsp;</td><td width="45%" align="LEFT" valign="TOP"><i><p><i>Tournez cent tours, tournez mille tours,</i></p><p><i>Tournez souvent et tournez toujours . . .</i></p><p><i>--Verlaine, <span class="QUOTE">"Chevaux de bois"</span></i></p></i></td></tr></tbody></table><p></p><div class="VARIABLELIST"><p><b><a name="BRKCONT1"></a>Commands affecting loop behavior</b></p><dl><dt><b class="COMMAND">break</b>, <b class="COMMAND">continue</b></dt><dd><p>The <b class="COMMAND">break</b> and <b class="COMMAND">continue</b>
          loop control commands
      <a name="AEN6981" href="#FTN.AEN6981"><span class="footnote">[53]</span></a>
          correspond exactly to their counterparts in other
          programming languages. The <b class="COMMAND">break</b>
          command terminates the loop (<em>breaks</em>
          out of it), while <b class="COMMAND">continue</b> causes a jump
          to the next <a href="#ITERATIONREF">iteration</a>
          of the loop, skipping all the remaining commands in that
          particular loop cycle.</p><div class="EXAMPLE"><a name="EX28"></a><p><b>Example 11-21. Effects of <i class="FIRSTTERM">break</i> and
      <b class="COMMAND">continue</b> in a loop</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  LIMIT=19  # Upper limit
  
  echo
  echo "Printing Numbers 1 through 20 (but not 3 and 11)."
  
  a=0
  
  while [ $a -le "$LIMIT" ]
  do
   a=$(($a+1))
  
   if [ "$a" -eq 3 ] || [ "$a" -eq 11 ]  # Excludes 3 and 11.
   then
     continue      # Skip rest of this particular loop iteration.
   fi
  
   echo -n "$a "   # This will not execute for 3 and 11.
  done 
  
  # Exercise:
  # Why does the loop print up to 20?
  
  echo; echo
  
  echo Printing Numbers 1 through 20, but something happens after 2.
  
  ##################################################################
  
  # Same loop, but substituting 'break' for 'continue'.
  
  a=0
  
  while [ "$a" -le "$LIMIT" ]
  do
   a=$(($a+1))
  
   if [ "$a" -gt 2 ]
   then
     break  # Skip entire rest of loop.
   fi
  
   echo -n "$a "
  done
  
  echo; echo; echo
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="BREAKPARAM"></a></p><p>The <b class="COMMAND">break</b> command may optionally take a
          parameter. A plain <b class="COMMAND">break</b> terminates
          only the innermost loop in which it is embedded,
          but a <b class="COMMAND">break N</b> breaks out of
          <tt class="PARAMETER"><i>N</i></tt> levels of loop.</p><div class="EXAMPLE"><a name="BREAKLEVELS"></a><p><b>Example 11-22. Breaking out of multiple loop levels</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # break-levels.sh: Breaking out of loops.
  
  # "break N" breaks out of N level loops.
  
  for outerloop in 1 2 3 4 5
  do
    echo -n "Group $outerloop:   "
  
    # --------------------------------------------------------
    for innerloop in 1 2 3 4 5
    do
      echo -n "$innerloop "
  
      if [ "$innerloop" -eq 3 ]
      then
        break  # Try   break 2   to see what happens.
               # ("Breaks" out of both inner and outer loops.)
      fi
    done
    # --------------------------------------------------------
  
    echo
  done  
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div><p>The <b class="COMMAND">continue</b> command, similar to
          <b class="COMMAND">break</b>, optionally takes a parameter. A
          plain <b class="COMMAND">continue</b> cuts short the
          current iteration within its loop and begins the next.
          A <b class="COMMAND">continue N</b> terminates all remaining
          iterations at its loop level and continues with the
          next iteration at the loop, <tt class="OPTION">N</tt> levels
          above.</p><div class="EXAMPLE"><a name="CONTINUELEVELS"></a><p><b>Example 11-23. Continuing at a higher loop level</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # The "continue N" command, continuing at the Nth level loop.
  
  for outer in I II III IV V           # outer loop
  do
    echo; echo -n "Group $outer: "
  
    # --------------------------------------------------------------------
    for inner in 1 2 3 4 5 6 7 8 9 10  # inner loop
    do
  
      if [[ "$inner" -eq 7 &amp;&amp; "$outer" = "III" ]]
      then
        continue 2  # Continue at loop on 2nd level, that is "outer loop".
                    # Replace above line with a simple "continue"
                    # to see normal loop behavior.
      fi  
  
      echo -n "$inner "  # 7 8 9 10 will not echo on "Group III."
    done  
    # --------------------------------------------------------------------
  
  done
  
  echo; echo
  
  # Exercise:
  # Come up with a meaningful use for "continue N" in a script.
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="CONTINUENEX"></a><p><b>Example 11-24. Using <i class="FIRSTTERM">continue N</i> in an actual task</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Albert Reiner gives an example of how to use "continue N":
  # ---------------------------------------------------------
  
  #  Suppose I have a large number of jobs that need to be run, with
  #+ any data that is to be treated in files of a given name pattern
  #+ in a directory. There are several machines that access
  #+ this directory, and I want to distribute the work over these
  #+ different boxen.
  #  Then I usually nohup something like the following on every box:
  
  while true
  do
    for n in .iso.*
    do
      [ "$n" = ".iso.opts" ] &amp;&amp; continue
      beta=${n#.iso.}
      [ -r .Iso.$beta ] &amp;&amp; continue
      [ -r .lock.$beta ] &amp;&amp; sleep 10 &amp;&amp; continue
      lockfile -r0 .lock.$beta || continue
      echo -n "$beta: " `date`
      run-isotherm $beta
      date
      ls -alF .Iso.$beta
      [ -r .Iso.$beta ] &amp;&amp; rm -f .lock.$beta
      continue 2
    done
    break
  done
  
  exit 0
  
  #  The details, in particular the sleep N, are particular to my
  #+ application, but the general pattern is:
  
  while true
  do
    for job in {pattern}
    do
      {job already done or running} &amp;&amp; continue
      {mark job as running, do job, mark job as done}
      continue 2
    done
    break        # Or something like `sleep 600' to avoid termination.
  done
  
  #  This way the script will stop only when there are no more jobs to do
  #+ (including jobs that were added during runtime). Through the use
  #+ of appropriate lockfiles it can be run on several machines
  #+ concurrently without duplication of calculations [which run a couple
  #+ of hours in my case, so I really want to avoid this]. Also, as search
  #+ always starts again from the beginning, one can encode priorities in
  #+ the file names. Of course, one could also do this without `continue 2',
  #+ but then one would have to actually check whether or not some job
  #+ was done (so that we should immediately look for the next job) or not
  #+ (in which case we terminate or sleep for a long time before checking
  #+ for a new job).</pre></font></td></tr></tbody></table></div><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">continue N</b> construct is
          difficult to understand and tricky to use in any meaningful
          context. It is probably best avoided.</p></td></tr></tbody></table></div></dd></dl></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="TESTBRANCH"></a>11.4. Testing and Branching</h1><p>The <b class="COMMAND">case</b> and <b class="COMMAND">select</b>
      constructs are technically not loops, since they do not iterate the
      execution of a code block. Like loops, however, they direct
      program flow according to conditions at the top or bottom of
      the block.</p><p></p><div class="VARIABLELIST"><p><b><a name="CASEESAC1"></a>Controlling program flow in a code
        block</b></p><dl><dt><b class="COMMAND">case (in) / esac</b></dt><dd><p>The <b class="COMMAND">case</b> construct is the shell
          scripting analog to <tt class="REPLACEABLE"><i>switch</i></tt>
          in <b class="COMMAND">C/C++</b>.
          It permits branching to one of a number of code blocks,
          depending on condition tests. It serves as a kind of
          shorthand for multiple <span class="TOKEN">if/then/else</span>
          statements and is an appropriate tool for creating
          menus.</p><p></p><p><b class="COMMAND">case</b>   "$<tt class="REPLACEABLE"><i>variable</i></tt>"   in <br><br>  &nbsp;"$<tt class="REPLACEABLE"><i>condition1</i></tt>" ) <br>  &nbsp;<tt class="REPLACEABLE"><i>command</i></tt>... <br>  &nbsp;;; <br><br>  &nbsp;"$<tt class="REPLACEABLE"><i>condition2</i></tt>" ) <br>  &nbsp;<tt class="REPLACEABLE"><i>command</i></tt>... <br>  &nbsp;;; <br><br><br><b class="COMMAND">esac</b> </p><p></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>	      </p><p></p><ul><li><p>Quoting the variables is not mandatory,
      since word splitting does not take place.</p></li><li><p><a name="CASEPAREN"></a>Each test line
                      ends with a right paren <b class="COMMAND">)</b>.
  
    <a name="AEN7087" href="#FTN.AEN7087"><span class="footnote">[54]</span></a>
          </p></li><li><p>Each condition block ends
      with a <em>double</em> semicolon
      <span class="TOKEN">;;</span>.</p></li><li><p>If a condition tests
                  <i class="FIRSTTERM">true</i>, then the associated
      commands execute and the <b class="COMMAND">case</b>
      block terminates.</p></li><li><p>The entire <b class="COMMAND">case</b>
      block ends with an <b class="COMMAND">esac</b>
      (<i class="WORDASWORD">case</i> spelled backwards).</p></li></ul>
        <p></p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="EX29"></a><p><b>Example 11-25. Using <i class="FIRSTTERM">case</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Testing ranges of characters.
  
  echo; echo "Hit a key, then hit return."
  read Keypress
  
  case "$Keypress" in
    [[:lower:]]   ) echo "Lowercase letter";;
    [[:upper:]]   ) echo "Uppercase letter";;
    [0-9]         ) echo "Digit";;
    *             ) echo "Punctuation, whitespace, or other";;
  esac      #  Allows ranges of characters in [square brackets],
            #+ or POSIX ranges in [[double square brackets.
  
  #  In the first version of this example,
  #+ the tests for lowercase and uppercase characters were
  #+ [a-z] and [A-Z].
  #  This no longer works in certain locales and/or Linux distros.
  #  POSIX is more portable.
  #  Thanks to Frank Wang for pointing this out.
  
  #  Exercise:
  #  --------
  #  As the script stands, it accepts a single keystroke, then terminates.
  #  Change the script so it accepts repeated input,
  #+ reports on each keystroke, and terminates only when "X" is hit.
  #  Hint: enclose everything in a "while" loop.
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="EX30"></a><p><b>Example 11-26. Creating menus using <i class="FIRSTTERM">case</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  # Crude address database
  
  clear # Clear the screen.
  
  echo "          Contact List"
  echo "          ------- ----"
  echo "Choose one of the following persons:" 
  echo
  echo "[E]vans, Roland"
  echo "[J]ones, Mildred"
  echo "[S]mith, Julie"
  echo "[Z]ane, Morris"
  echo
  
  read person
  
  case "$person" in
  # Note variable is quoted.
  
    "E" | "e" )
    # Accept upper or lowercase input.
    echo
    echo "Roland Evans"
    echo "4321 Flash Dr."
    echo "Hardscrabble, CO 80753"
    echo "(303) 734-9874"
    echo "(303) 734-9892 fax"
    echo "revans@zzy.net"
    echo "Business partner &amp; old friend"
    ;;
  # Note double semicolon to terminate each option.
  
    "J" | "j" )
    echo
    echo "Mildred Jones"
    echo "249 E. 7th St., Apt. 19"
    echo "New York, NY 10009"
    echo "(212) 533-2814"
    echo "(212) 533-9972 fax"
    echo "milliej@loisaida.com"
    echo "Ex-girlfriend"
    echo "Birthday: Feb. 11"
    ;;
  
  # Add info for Smith &amp; Zane later.
  
            * )
     # Default option.	  
     # Empty input (hitting RETURN) fits here, too.
     echo
     echo "Not yet in database."
    ;;
  
  esac
  
  echo
  
  #  Exercise:
  #  --------
  #  Change the script so it accepts multiple inputs,
  #+ instead of terminating after displaying just one address.
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="CASECL"></a></p><p>An exceptionally clever use of <b class="COMMAND">case</b>
          involves testing for command-line parameters.
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#! /bin/bash
  
  case "$1" in
    "") echo "Usage: ${0##*/} &lt;filename&gt;"; exit $E_PARAM;;
                        # No command-line parameters,
                        # or first parameter empty.
  # Note that ${0##*/} is ${var##pattern} param substitution.
                        # Net result is $0.
  
    -*) FILENAME=./$1;;   #  If filename passed as argument ($1)
                        #+ starts with a dash,
                        #+ replace it with ./$1
                        #+ so further commands don't interpret it
                        #+ as an option.
  
    * ) FILENAME=$1;;     # Otherwise, $1.
  esac</pre></font></td></tr></tbody></table></p><p>Here is a more straightforward example of
          command-line parameter handling:
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#! /bin/bash
  
  
  while [ $# -gt 0 ]; do    # Until you run out of parameters . . .
    case "$1" in
      -d|--debug)
                # "-d" or "--debug" parameter?
                DEBUG=1
                ;;
      -c|--conf)
                CONFFILE="$2"
                shift
                if [ ! -f $CONFFILE ]; then
                  echo "Error: Supplied file doesn't exist!"
                  exit $E_CONFFILE     # File not found error.
                fi
                ;;
    esac
    shift       # Check next set of parameters.
  done
  
  #  From Stefano Falsetto's "Log2Rot" script,
  #+ part of his "rottlog" package.
  #  Used with permission.</pre></font></td></tr></tbody></table></p><div class="EXAMPLE"><a name="CASECMD"></a><p><b>Example 11-27. Using <i class="FIRSTTERM">command substitution</i>
          to generate the <i class="FIRSTTERM">case</i> variable</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # case-cmd.sh: Using command substitution to generate a "case" variable.
  
  case $( arch ) in   # $( arch ) returns machine architecture.
                      # Equivalent to 'uname -m' ...
    i386 ) echo "80386-based machine";;
    i486 ) echo "80486-based machine";;
    i586 ) echo "Pentium-based machine";;
    i686 ) echo "Pentium2+-based machine";;
    *    ) echo "Other type of machine";;
  esac
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="CSGLOB"></a></p><p>A <b class="COMMAND">case</b> construct can filter strings for
          <a href="#GLOBBINGREF">globbing</a> patterns.</p><div class="EXAMPLE"><a name="MATCHSTRING"></a><p><b>Example 11-28. Simple string matching</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # match-string.sh: Simple string matching
  #                  using a 'case' construct.
  
  match_string ()
  { # Exact string match.
    MATCH=0
    E_NOMATCH=90
    PARAMS=2     # Function requires 2 arguments.
    E_BAD_PARAMS=91
  
    [ $# -eq $PARAMS ] || return $E_BAD_PARAMS
  
    case "$1" in
    "$2") return $MATCH;;
    *   ) return $E_NOMATCH;;
    esac
  
  }  
  
  
  a=one
  b=two
  c=three
  d=two
  
  
  match_string $a     # wrong number of parameters
  echo $?             # 91
  
  match_string $a $b  # no match
  echo $?             # 90
  
  match_string $b $d  # match
  echo $?             # 0
  
  
  exit 0		    </pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="ISALPHA"></a><p><b>Example 11-29. Checking for alphabetic input</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # isalpha.sh: Using a "case" structure to filter a string.
  
  SUCCESS=0
  FAILURE=1   #  Was FAILURE=-1,
              #+ but Bash no longer allows negative return value.
  
  isalpha ()  # Tests whether *first character* of input string is alphabetic.
  {
  if [ -z "$1" ]                # No argument passed?
  then
    return $FAILURE
  fi
  
  case "$1" in
    [a-zA-Z]*) return $SUCCESS;;  # Begins with a letter?
    *        ) return $FAILURE;;
  esac
  }             # Compare this with "isalpha ()" function in C.
  
  
  isalpha2 ()   # Tests whether *entire string* is alphabetic.
  {
    [ $# -eq 1 ] || return $FAILURE
  
    case $1 in
    *[!a-zA-Z]*|"") return $FAILURE;;
                 *) return $SUCCESS;;
    esac
  }
  
  isdigit ()    # Tests whether *entire string* is numerical.
  {             # In other words, tests for integer variable.
    [ $# -eq 1 ] || return $FAILURE
  
    case $1 in
      *[!0-9]*|"") return $FAILURE;;
                *) return $SUCCESS;;
    esac
  }
  
  
  
  check_var ()  # Front-end to isalpha ().
  {
  if isalpha "$@"
  then
    echo "\"$*\" begins with an alpha character."
    if isalpha2 "$@"
    then        # No point in testing if first char is non-alpha.
      echo "\"$*\" contains only alpha characters."
    else
      echo "\"$*\" contains at least one non-alpha character."
    fi  
  else
    echo "\"$*\" begins with a non-alpha character."
                # Also "non-alpha" if no argument passed.
  fi
  
  echo
  
  }
  
  digit_check ()  # Front-end to isdigit ().
  {
  if isdigit "$@"
  then
    echo "\"$*\" contains only digits [0 - 9]."
  else
    echo "\"$*\" has at least one non-digit character."
  fi
  
  echo
  
  }
  
  a=23skidoo
  b=H3llo
  c=-What?
  d=What?
  e=$(echo $b)   # Command substitution.
  f=AbcDef
  g=27234
  h=27a34
  i=27.34
  
  check_var $a
  check_var $b
  check_var $c
  check_var $d
  check_var $e
  check_var $f
  check_var     # No argument passed, so what happens?
  #
  digit_check $g
  digit_check $h
  digit_check $i
  
  
  exit 0        # Script improved by S.C.
  
  # Exercise:
  # --------
  #  Write an 'isfloat ()' function that tests for floating point numbers.
  #  Hint: The function duplicates 'isdigit ()',
  #+ but adds a test for a mandatory decimal point.</pre></font></td></tr></tbody></table></div></dd><dt><a name="SELECTREF"></a><b class="COMMAND">select</b></dt><dd><p>The <b class="COMMAND">select</b> construct, adopted from the Korn
          Shell, is yet another tool for building menus.</p><p></p><p><b class="COMMAND">select</b>   <tt class="REPLACEABLE"><i>variable</i></tt>  [in <tt class="REPLACEABLE"><i>list</i></tt>]<br>  do <br>  &nbsp;<tt class="REPLACEABLE"><i>command</i></tt>... <br>  &nbsp;break <br>  done </p><p></p><p>This prompts the user to enter one of the choices presented in the
          variable list.  Note that <b class="COMMAND">select</b> uses the
          <tt class="VARNAME">$PS3</tt> prompt (<tt class="PROMPT">#? </tt>) by default, 
      but this may be changed.</p><div class="EXAMPLE"><a name="EX31"></a><p><b>Example 11-30. Creating menus using <i class="FIRSTTERM">select</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  PS3='Choose your favorite vegetable: ' # Sets the prompt string.
                                         # Otherwise it defaults to #? .
  
  echo
  
  select vegetable in "beans" "carrots" "potatoes" "onions" "rutabagas"
  do
    echo
    echo "Your favorite veggie is $vegetable."
    echo "Yuck!"
    echo
    break  # What happens if there is no 'break' here?
  done
  
  exit
  
  # Exercise:
  # --------
  #  Fix this script to accept user input not specified in
  #+ the "select" statement.
  #  For example, if the user inputs "peas,"
  #+ the script would respond "Sorry. That is not on the menu."</pre></font></td></tr></tbody></table></div><p><a name="INLISTOMIT"></a></p><p>If <tt class="USERINPUT"><b>in <tt class="REPLACEABLE"><i>list</i></tt></b></tt> is
          omitted, then <b class="COMMAND">select</b> uses the list of command
          line arguments (<tt class="VARNAME">$@</tt>) passed to the script or
          the function containing the <b class="COMMAND">select</b>
          construct.</p><p>Compare this to the behavior of a 
          </p><p><b class="COMMAND">for</b>   <tt class="REPLACEABLE"><i>variable</i></tt>  [in <tt class="REPLACEABLE"><i>list</i></tt>]</p>
          construct with the 
          <tt class="USERINPUT"><b>in <tt class="REPLACEABLE"><i>list</i></tt></b></tt>
          omitted.<p></p><div class="EXAMPLE"><a name="EX32"></a><p><b>Example 11-31. Creating menus using <i class="FIRSTTERM">select</i>
          in a function</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  PS3='Choose your favorite vegetable: '
  
  echo
  
  choice_of()
  {
  select vegetable
  # [in list] omitted, so 'select' uses arguments passed to function.
  do
    echo
    echo "Your favorite veggie is $vegetable."
    echo "Yuck!"
    echo
    break
  done
  }
  
  choice_of beans rice carrots radishes rutabaga spinach
  #         $1    $2   $3      $4       $5       $6
  #         passed to choice_of() function
  
  exit 0</pre></font></td></tr></tbody></table></div><p>See also <a href="#RESISTOR">Example 37-3</a>.</p></dd></dl></div></div></div><div class="CHAPTER"><hr><h1><a name="COMMANDSUB"></a>Chapter 12. Command Substitution</h1><p>	     <a name="COMMANDSUBREF"></a><b class="COMMAND">Command
         substitution</b> reassigns the output of a command
      <a name="AEN7205" href="#FTN.AEN7205"><span class="footnote">[55]</span></a>
         or even multiple commands; it literally plugs the command
         output into another context.
  
            <a name="AEN7211" href="#FTN.AEN7211"><span class="footnote">[56]</span></a>
         </p><p><a name="BACKQUOTESREF"></a>The classic form of command
          substitution uses <i class="FIRSTTERM">backquotes</i>
          (`...`). Commands within backquotes (backticks) generate
          command-line text.
  
          <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">script_name=`basename $0`
  echo "The name of this script is $script_name."</pre></font></td></tr></tbody></table></p><div class="FORMALPARA"><p><b>The output of commands can be used as arguments to
          another command, to set a variable, and even for generating
          the argument list in a <a href="#FORLOOPREF1">for</a>
          loop. </b></p></div><p>	      <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">rm `cat filename`   # <span class="QUOTE">"filename"</span> contains a list of files to delete.
  #
  # S. C. points out that "arg list too long" error might result.
  # Better is              xargs rm -- &lt; filename 
  # ( -- covers those cases where <span class="QUOTE">"filename"</span> begins with a <span class="QUOTE">"-"</span> )
  
  textfile_listing=`ls *.txt`
  # Variable contains names of all *.txt files in current working directory.
  echo $textfile_listing
  
  textfile_listing2=$(ls *.txt)   # The alternative form of command substitution.
  echo $textfile_listing2
  # Same result.
  
  # A possible problem with putting a list of files into a single string
  # is that a newline may creep in.
  #
  # A safer way to assign a list of files to a parameter is with an array.
  #      shopt -s nullglob    # If no match, filename expands to nothing.
  #      textfile_listing=( *.txt )
  #
  # Thanks, S.C.</pre></font></td></tr></tbody></table>
              </p><div class="NOTE"><p></p><table class="NOTE" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p><a name="CSSUBSH"></a>Command substitution
                invokes a <a href="#SUBSHELLSREF">subshell</a>.</p></td></tr></tbody></table></div><div class="CAUTION"><p></p><table class="CAUTION" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p><a name="CSWS"></a>Command substitution may
                  result in <a href="#WSPLITREF">word splitting</a>.
            <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">COMMAND `echo a b`     # 2 args: a and b
  
  COMMAND "`echo a b`"   # 1 arg: "a b"
  
  COMMAND `echo`         # no arg
  
  COMMAND "`echo`"       # one empty arg
  
  
  # Thanks, S.C.</pre></font></td></tr></tbody></table></p><p><a name="CSTRNL"></a></p><p>Even when there is no word splitting, command
            substitution can remove trailing newlines.
  
      <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># cd "`pwd`"  # This should always work.
  # However...
  
  mkdir 'dir with trailing newline
  '
  
  cd 'dir with trailing newline
  '
  
  cd "`pwd`"  # Error message:
  # bash: cd: /tmp/file with trailing newline: No such file or directory
  
  cd "$PWD"   # Works fine.
  
  
  
  
  
  old_tty_setting=$(stty -g)   # Save old terminal setting.
  echo "Hit a key "
  stty -icanon -echo           # Disable "canonical" mode for terminal.
                               # Also, disable *local* echo.
  key=$(dd bs=1 count=1 2&gt; /dev/null)   # Using 'dd' to get a keypress.
  stty "$old_tty_setting"      # Restore old setting. 
  echo "You hit ${#key} key."  # ${#variable} = number of characters in $variable
  #
  # Hit any key except RETURN, and the output is "You hit 1 key."
  # Hit RETURN, and it's "You hit 0 key."
  # The newline gets eaten in the command substitution.
  
  #Code snippet by StÃ©phane Chazelas.</pre></font></td></tr></tbody></table>
                </p></td></tr></tbody></table></div><div class="CAUTION"><p></p><table class="CAUTION" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>Using <b class="COMMAND">echo</b> to output an
      <i class="FIRSTTERM">unquoted</i> variable set with command
      substitution removes trailing newlines characters from
      the output of the reassigned command(s). This can cause
      unpleasant surprises.
  
      <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">dir_listing=`ls -l`
  echo $dir_listing     # unquoted
  
  # Expecting a nicely ordered directory listing.
  
  # However, what you get is:
  # total 3 -rw-rw-r-- 1 bozo bozo 30 May 13 17:15 1.txt -rw-rw-r-- 1 bozo
  # bozo 51 May 15 20:57 t2.sh -rwxr-xr-x 1 bozo bozo 217 Mar 5 21:13 wi.sh
  
  # The newlines disappeared.
  
  
  echo "$dir_listing"   # quoted
  # -rw-rw-r--    1 bozo       30 May 13 17:15 1.txt
  # -rw-rw-r--    1 bozo       51 May 15 20:57 t2.sh
  # -rwxr-xr-x    1 bozo      217 Mar  5 21:13 wi.sh</pre></font></td></tr></tbody></table>
                </p></td></tr></tbody></table></div><p>Command substitution even permits setting a variable to the
           contents of a file, using either <a href="#IOREDIRREF">redirection</a> or the <a href="#CATREF">cat</a> command.</p><p>	         <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">variable1=`&lt;file1`      #  Set "variable1" to contents of "file1".
  variable2=`cat file2`   #  Set "variable2" to contents of "file2".
                          #  This, however, forks a new process,
                          #+ so the line of code executes slower than the above version.
  
  #  Note that the variables may contain embedded whitespace,
  #+ or even (horrors), control characters.
  
  #  It is not necessary to explicitly assign a variable.
  echo "` &lt;$0`"           # Echoes the script itself to stdout.</pre></font></td></tr></tbody></table>
               </p><p>	         <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#  Excerpts from system file, /etc/rc.d/rc.sysinit
  #+ (on a Red Hat Linux installation)
  
  
  if [ -f /fsckoptions ]; then
          fsckoptions=`cat /fsckoptions`
  ...
  fi
  #
  #
  if [ -e "/proc/ide/${disk[$device]}/media" ] ; then
               hdmedia=`cat /proc/ide/${disk[$device]}/media`
  ...
  fi
  #
  #
  if [ ! -n "`uname -r | grep -- "-"`" ]; then
         ktag="`cat /proc/version`"
  ...
  fi
  #
  #
  if [ $usb = "1" ]; then
      sleep 5
      mouseoutput=`cat /proc/bus/usb/devices 2&gt;/dev/null|grep -E "^I.*Cls=03.*Prot=02"`
      kbdoutput=`cat /proc/bus/usb/devices 2&gt;/dev/null|grep -E "^I.*Cls=03.*Prot=01"`
  ...
  fi</pre></font></td></tr></tbody></table>
               </p><div class="CAUTION"><p></p><table class="CAUTION" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>Do not set a variable to the contents of a
           <em>long</em> text file unless you have a very good
           reason for doing so. Do not set a variable to the contents of a
           <i class="FIRSTTERM">binary</i> file, even as a joke.</p><div class="EXAMPLE"><a name="STUPSCR"></a><p><b>Example 12-1. Stupid script tricks</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # stupid-script-tricks.sh: Don't try this at home, folks.
  # From "Stupid Script Tricks," Volume I.
  
  exit 99  ### Comment out this line if you dare.
  
  dangerous_variable=`cat /boot/vmlinuz`   # The compressed Linux kernel itself.
  
  echo "string-length of \$dangerous_variable = ${#dangerous_variable}"
  # string-length of $dangerous_variable = 794151
  # (Newer kernels are bigger.)
  # Does not give same count as 'wc -c /boot/vmlinuz'.
  
  # echo "$dangerous_variable"
  # Don't try this! It would hang the script.
  
  
  #  The document author is aware of no useful applications for
  #+ setting a variable to the contents of a binary file.
  
  exit 0</pre></font></td></tr></tbody></table></div><p>Notice that a <i class="FIRSTTERM">buffer overrun</i>
           does not occur. This is one instance where an interpreted
           language, such as Bash, provides more protection from
           programmer mistakes than a compiled language.</p></td></tr></tbody></table></div><p><a name="CSVL"></a></p><p>Command substitution permits setting a variable to the
      output of a <a href="#FORLOOPREF1">loop</a>. The
      key to this is grabbing the output of an <a href="#ECHOREF">echo</a> command within the
      loop.</p><div class="EXAMPLE"><a name="CSUBLOOP"></a><p><b>Example 12-2. Generating a variable from a loop</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # csubloop.sh: Setting a variable to the output of a loop.
  
  variable1=`for i in 1 2 3 4 5
  do
    echo -n "$i"                 #  The 'echo' command is critical
  done`                          #+ to command substitution here.
  
  echo "variable1 = $variable1"  # variable1 = 12345
  
  
  i=0
  variable2=`while [ "$i" -lt 10 ]
  do
    echo -n "$i"                 # Again, the necessary 'echo'.
    let "i += 1"                 # Increment.
  done`
  
  echo "variable2 = $variable2"  # variable2 = 0123456789
  
  #  Demonstrates that it's possible to embed a loop
  #+ inside a variable declaration.
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="CSTOOLSET"></a></p><table class="SIDEBAR" border="1" cellpadding="5"><tbody><tr><td><div class="SIDEBAR"><a name="AEN7273"></a><p></p><p>Command substitution makes it possible to extend the
      toolset available to Bash. It is simply a matter
      of writing a program or script that outputs to
      <tt class="FILENAME">stdout</tt> (like a well-behaved UNIX
      tool should) and assigning that output to a variable.</p><p>		<table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#include &lt;stdio.h&gt;
  
  /*  "Hello, world." C program  */		
  
  int main()
  {
    printf( "Hello, world.\n" );
    return (0);
  }</pre></font></td></tr></tbody></table>
          <table border="1" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>gcc -o hello hello.c</b></tt>
          </pre></font></td></tr></tbody></table>
      </p><p>                <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # hello.sh		
  
  greeting=`./hello`
  echo $greeting</pre></font></td></tr></tbody></table>
          <table border="1" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>sh hello.sh</b></tt>
  <tt class="COMPUTEROUTPUT">Hello, world.</tt>
            </pre></font></td></tr></tbody></table>
            </p><p></p></div></td></tr></tbody></table><div class="NOTE"><p></p><table class="NOTE" width="100%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p><a name="CSPARENS"></a>The <b class="COMMAND">$(...)</b>
      form has superseded backticks for command
      substitution.</p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">output=$(sed -n /"$1"/p $file)   # From "grp.sh"	example.
          
  # Setting a variable to the contents of a text file.
  File_contents1=$(cat $file1)      
  File_contents2=$(&lt;$file2)        # Bash permits this also.</pre></font></td></tr></tbody></table></p><p>The <b class="COMMAND">$(...)</b> form of command substitution
            treats a double backslash in a different way than
      <b class="COMMAND">`...`</b>.</p><p>		
          <table border="1" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo `echo \\`</b></tt>
  <tt class="COMPUTEROUTPUT"></tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $(echo \\)</b></tt>
  <tt class="COMPUTEROUTPUT">\</tt>
          </pre></font></td></tr></tbody></table>
                </p><p><a name="CSNEST"></a></p><p>The <b class="COMMAND">$(...)</b> form of command
                  substitution permits nesting.
        <a name="AEN7308" href="#FTN.AEN7308"><span class="footnote">[57]</span></a>
      
      </p><p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">word_count=$( wc -w $(echo * | awk '{print $8}') )</pre></font></td></tr></tbody></table>
                </p><p>Or, for something a bit more elaborate . . .</p><div class="EXAMPLE"><a name="AGRAM2"></a><p><b>Example 12-3. Finding anagrams</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # agram2.sh
  # Example of nested command substitution.
  
  #  Uses "anagram" utility
  #+ that is part of the author's "yawl" word list package.
  #  http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz
  #  http://bash.deta.in/yawl-0.3.2.tar.gz
  
  E_NOARGS=86
  E_BADARG=87
  MINLEN=7
  
  if [ -z "$1" ]
  then
    echo "Usage $0 LETTERSET"
    exit $E_NOARGS         # Script needs a command-line argument.
  elif [ ${#1} -lt $MINLEN ]
  then
    echo "Argument must have at least $MINLEN letters."
    exit $E_BADARG
  fi
  
  
  
  FILTER='.......'         # Must have at least 7 letters.
  #       1234567
  Anagrams=( $(echo $(anagram $1 | grep $FILTER) ) )
  #          $(     $(  nested command sub.    ) )
  #        (              array assignment         )
  
  echo
  echo "${#Anagrams[*]}  7+ letter anagrams found"
  echo
  echo ${Anagrams[0]}      # First anagram.
  echo ${Anagrams[1]}      # Second anagram.
                           # Etc.
  
  # echo "${Anagrams[*]}"  # To list all the anagrams in a single line . . .
  
  #  Look ahead to the Arrays chapter for enlightenment on
  #+ what's going on here.
  
  # See also the agram.sh script for an exercise in anagram finding.
  
  exit $?</pre></font></td></tr></tbody></table></div></td></tr></tbody></table></div><p>Examples of command substitution in shell scripts:
         </p><p></p><ol type="1"><li><p><a href="#BINGREP">Example 11-8</a></p></li><li><p><a href="#CASECMD">Example 11-27</a></p></li><li><p><a href="#SEEDINGRANDOM">Example 9-16</a></p></li><li><p><a href="#EX57">Example 16-3</a></p></li><li><p><a href="#LOWERCASE">Example 16-22</a></p></li><li><p><a href="#GRP">Example 16-17</a></p></li><li><p><a href="#EX53">Example 16-54</a></p></li><li><p><a href="#EX24">Example 11-14</a></p></li><li><p><a href="#SYMLINKS">Example 11-11</a></p></li><li><p><a href="#STRIPC">Example 16-32</a></p></li><li><p><a href="#REDIR4">Example 20-8</a></p></li><li><p><a href="#TREE">Example A-16</a></p></li><li><p><a href="#PIDID">Example 29-3</a></p></li><li><p><a href="#MONTHLYPMT">Example 16-47</a></p></li><li><p><a href="#BASE">Example 16-48</a></p></li><li><p><a href="#ALTBC">Example 16-49</a></p></li></ol>
       <p></p></div><div class="CHAPTER"><hr><h1><a name="ARITHEXP"></a>Chapter 13. Arithmetic Expansion</h1><p><a name="ARITHEXPREF"></a>Arithmetic expansion provides a
    powerful tool for performing (integer) arithmetic
    operations in scripts. Translating a string into a
    numerical expression is relatively straightforward using
    <i class="FIRSTTERM">backticks</i>, <i class="FIRSTTERM">double
    parentheses</i>, or <i class="FIRSTTERM">let</i>.</p><p></p><div class="VARIABLELIST"><p><b><a name="ARITHEXPVAR1"></a>Variations</b></p><dl><dt>Arithmetic expansion with <a href="#BACKQUOTESREF">backticks</a> (often used in
      conjunction with <a href="#EXPRREF">expr</a>)</dt><dd><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">z=`expr $z + 3`          # The 'expr' command performs the expansion.</pre></font></td></tr></tbody></table></p></dd><dt>Arithmetic expansion with <a href="#DBLPARENS">double
      parentheses</a>, and using <a href="#LETREF">let</a></dt><dd><p>The use of <i class="FIRSTTERM">backticks</i>
          (<i class="FIRSTTERM">backquotes</i>) in arithmetic
          expansion has been superseded by <i class="FIRSTTERM">double
          parentheses</i> --
          <tt class="USERINPUT"><b>((...))</b></tt> and
          <tt class="USERINPUT"><b>$((...))</b></tt> -- and also by the very
          convenient <a href="#LETREF">let</a> construction.</p><p>	      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">z=$(($z+3))
  z=$((z+3))                                  #  Also correct.
                                              #  Within double parentheses,
                                              #+ parameter dereferencing
                                              #+ is optional.
  
  # $((EXPRESSION)) is arithmetic expansion.  #  Not to be confused with
                                              #+ command substitution.
  
  
  
  # You may also use operations within double parentheses without assignment.
  
    n=0
    echo "n = $n"                             # n = 0
  
    (( n += 1 ))                              # Increment.
  # (( $n += 1 )) is incorrect!
    echo "n = $n"                             # n = 1
  
  
  let z=z+3
  let "z += 3"  #  Quotes permit the use of spaces in variable assignment.
                #  The 'let' operator actually performs arithmetic evaluation,
                #+ rather than expansion.</pre></font></td></tr></tbody></table>
        </p><p>Examples of arithmetic expansion in scripts:
         </p><p></p><ol type="1"><li><p><a href="#EX45">Example 16-9</a></p></li><li><p><a href="#EX25">Example 11-15</a></p></li><li><p><a href="#EX66">Example 27-1</a></p></li><li><p><a href="#BUBBLE">Example 27-11</a></p></li><li><p><a href="#TREE">Example A-16</a></p></li></ol>
       <p></p></dd></dl></div></div><div class="CHAPTER"><hr><h1><a name="RECESS-TIME"></a>Chapter 14. Recess Time</h1><p><em>	  This bizarre little intermission gives the reader a chance to
      relax and maybe laugh a bit.
        </em></p><a name="AEN7432"></a><blockquote class="BLOCKQUOTE"><p class="LITERALLAYOUT">&nbsp;&nbsp;<br>
  <br>
    &nbsp;&nbsp;Fellow&nbsp;Linux&nbsp;user,&nbsp;greetings!&nbsp;You&nbsp;are&nbsp;reading&nbsp;something&nbsp;which<br>
    &nbsp;&nbsp;will&nbsp;bring&nbsp;you&nbsp;luck&nbsp;and&nbsp;good&nbsp;fortune.&nbsp;Just&nbsp;e-mail&nbsp;a&nbsp;copy&nbsp;of<br>
    &nbsp;&nbsp;this&nbsp;document&nbsp;to&nbsp;10&nbsp;of&nbsp;your&nbsp;friends.&nbsp;Before&nbsp;making&nbsp;the&nbsp;copies,<br>
    &nbsp;&nbsp;send&nbsp;a&nbsp;100-line&nbsp;Bash&nbsp;script&nbsp;to&nbsp;the&nbsp;first&nbsp;person&nbsp;on&nbsp;the&nbsp;list<br>
    &nbsp;&nbsp;at&nbsp;the&nbsp;bottom&nbsp;of&nbsp;this&nbsp;letter.&nbsp;Then&nbsp;delete&nbsp;their&nbsp;name&nbsp;and&nbsp;add<br>
    &nbsp;&nbsp;yours&nbsp;to&nbsp;the&nbsp;bottom&nbsp;of&nbsp;the&nbsp;list.<br>
  <br>
    &nbsp;&nbsp;Don't&nbsp;break&nbsp;the&nbsp;chain!&nbsp;Make&nbsp;the&nbsp;copies&nbsp;within&nbsp;48&nbsp;hours.<br>
    &nbsp;&nbsp;Wilfred&nbsp;P.&nbsp;of&nbsp;Brooklyn&nbsp;failed&nbsp;to&nbsp;send&nbsp;out&nbsp;his&nbsp;ten&nbsp;copies&nbsp;and<br>
    &nbsp;&nbsp;woke&nbsp;the&nbsp;next&nbsp;morning&nbsp;to&nbsp;find&nbsp;his&nbsp;job&nbsp;description&nbsp;changed<br>
    &nbsp;&nbsp;to&nbsp;"COBOL&nbsp;programmer."&nbsp;Howard&nbsp;L.&nbsp;of&nbsp;Newport&nbsp;News&nbsp;sent<br>
    &nbsp;&nbsp;out&nbsp;his&nbsp;ten&nbsp;copies&nbsp;and&nbsp;within&nbsp;a&nbsp;month&nbsp;had&nbsp;enough&nbsp;hardware<br>
    &nbsp;&nbsp;to&nbsp;build&nbsp;a&nbsp;100-node&nbsp;Beowulf&nbsp;cluster&nbsp;dedicated&nbsp;to&nbsp;playing<br>
    &nbsp;&nbsp;<em>Tuxracer</em>.&nbsp;Amelia&nbsp;V.&nbsp;of&nbsp;Chicago&nbsp;laughed&nbsp;at&nbsp;this&nbsp;letter<br>
    &nbsp;&nbsp;and&nbsp;broke&nbsp;the&nbsp;chain.&nbsp;Shortly&nbsp;thereafter,&nbsp;a&nbsp;fire&nbsp;broke&nbsp;out<br>
    &nbsp;&nbsp;in&nbsp;her&nbsp;terminal&nbsp;and&nbsp;she&nbsp;now&nbsp;spends&nbsp;her&nbsp;days&nbsp;writing<br>
    &nbsp;&nbsp;documentation&nbsp;for&nbsp;MS&nbsp;Windows.<br>
  <br>
    &nbsp;&nbsp;Don't&nbsp;break&nbsp;the&nbsp;chain!&nbsp;&nbsp;Send&nbsp;out&nbsp;your&nbsp;ten&nbsp;copies&nbsp;today!<br>
  <br>
    </p></blockquote><p><em>Courtesy 'NIX "fortune cookies", with some
      alterations and many apologies</em></p></div></div><div class="PART"><a name="PART4"></a><div class="TITLEPAGE"><h1 class="TITLE">Part 4. Commands</h1><div class="PARTINTRO"><a name="AEN7439"></a><p><a name="PART4A"></a></p><p>Mastering the commands on your Linux machine is an indispensable
        prelude to writing effective shell scripts.</p><p>This section covers the following commands:</p><p></p><ul><li><p><a href="#DOTREF">.</a>
             (See also <a href="#SOURCEREF">source</a>)</p></li><li><p><a href="#ACREF">ac</a></p></li><li><p><a href="#USERADDREF">adduser</a></p></li><li><p><a href="#AGETTYREF">agetty</a></p></li><li><p><a href="#AGREPREF">agrep</a></p></li><li><p><a href="#ARREF">ar</a></p></li><li><p><a href="#ARCHREF">arch</a></p></li><li><p><a href="#ATREF">at</a></p></li><li><p><a href="#AUTOLOADREF">autoload</a></p></li><li><p><a href="#AWKREF">awk</a>
       (See also <a href="#AWKMATH">Using
       <b class="COMMAND">awk</b> for
       math operations</a>)</p></li><li><p><a href="#BADBLOCKSREF">badblocks</a></p></li><li><p><a href="#BANNERREF">banner</a></p></li><li><p><a href="#BASENAMEREF">basename</a></p></li><li><p><a href="#BATCHREF">batch</a></p></li><li><p><a href="#BCREF">bc</a></p></li><li><p><a href="#BGREF">bg</a></p></li><li><p><a href="#BINDREF">bind</a></p></li><li><p><a href="#BISONREF">bison</a></p></li><li><p><a href="#BLTREF">builtin</a></p></li><li><p><a href="#BZGREPREF">bzgrep</a></p></li><li><p><a href="#BZIPREF">bzip2</a></p></li><li><p><a href="#CALREF">cal</a></p></li><li><p><a href="#CALLERREF">caller</a></p></li><li><p><a href="#CATREF">cat</a></p></li><li><p><a href="#CDREF">cd</a></p></li><li><p><a href="#CHATTRREF">chattr</a></p></li><li><p><a href="#CHFNREF">chfn</a></p></li><li><p><a href="#CHGRPREF">chgrp</a></p></li><li><p><a href="#CHKCONFIGREF">chkconfig</a></p></li><li><p><a href="#CHMODREF">chmod</a></p></li><li><p><a href="#CHOWNREF">chown</a></p></li><li><p><a href="#CHROOTREF">chroot</a></p></li><li><p><a href="#CKSUMREF">cksum</a></p></li><li><p><a href="#CLEARREF">clear</a></p></li><li><p><a href="#CLOCKREF">clock</a></p></li><li><p><a href="#CMPREF">cmp</a></p></li><li><p><a href="#COLREF">col</a></p></li><li><p><a href="#COLRMREF">colrm</a></p></li><li><p><a href="#COLUMNREF">column</a></p></li><li><p><a href="#COMMREF">comm</a></p></li><li><p><a href="#COMMANDREF">command</a></p></li><li><p><a href="#COMPGENREF">compgen</a></p></li><li><p><a href="#COMPLETEREF">complete</a></p></li><li><p><a href="#COMPRESSREF">compress</a></p></li><li><p><a href="#COPROCREF">coproc</a></p></li><li><p><a href="#CPREF">cp</a></p></li><li><p><a href="#CPIOREF">cpio</a></p></li><li><p><a href="#CRONREF">cron</a></p></li><li><p><a href="#CRYPTREF">crypt</a></p></li><li><p><a href="#CSPLITREF">csplit</a></p></li><li><p><a href="#CUREF">cu</a></p></li><li><p><a href="#CUTREF">cut</a></p></li><li><p><a href="#DATEREF">date</a></p></li><li><p><a href="#DCREF">dc</a></p></li><li><p><a href="#DDREF">dd</a></p></li><li><p><a href="#DEBUGFSREF">debugfs</a></p></li><li><p><a href="#DECLAREREF">declare</a></p></li><li><p><a href="#DEPMODREF">depmod</a></p></li><li><p><a href="#DFREF">df</a></p></li><li><p><a href="#DIALOGREF">dialog</a></p></li><li><p><a href="#DIFFREF">diff</a></p></li><li><p><a href="#DIFF3REF">diff3</a></p></li><li><p><a href="#DIFFSTATREF">diffstat</a></p></li><li><p><a href="#DIGREF">dig</a></p></li><li><p><a href="#DIRNAMEREF">dirname</a></p></li><li><p><a href="#DIRSD">dirs</a></p></li><li><p><a href="#DISOWNREF">disown</a></p></li><li><p><a href="#DMESGREF">dmesg</a></p></li><li><p><a href="#DOEXECREF">doexec</a></p></li><li><p><a href="#DOS2UNIXREF">dos2unix</a></p></li><li><p><a href="#DUREF">du</a></p></li><li><p><a href="#DUMPREF">dump</a></p></li><li><p><a href="#DUMPE2FSREF">dumpe2fs</a></p></li><li><p><a href="#E2FSCKREF">e2fsck</a></p></li><li><p><a href="#ECHOREF">echo</a></p></li><li><p><a href="#EGREPREF">egrep</a></p></li><li><p><a href="#ENABLEREF">enable</a></p></li><li><p><a href="#ENSCRIPTREF">enscript</a></p></li><li><p><a href="#ENVVREF">env</a></p></li><li><p><a href="#EQNREF">eqn</a></p></li><li><p><a href="#EVALREF">eval</a></p></li><li><p><a href="#EXECREF">exec</a></p></li><li><p><a href="#EXITREF">exit</a>
       (Related topic: <a href="#EXITSTATUSREF">exit
       status</a>)</p></li><li><p><a href="#EXPANDREF">expand</a></p></li><li><p><a href="#EXPORTREF">export</a></p></li><li><p><a href="#EXPRREF">expr</a></p></li><li><p><a href="#FACTORREF">factor</a></p></li><li><p><a href="#FALSEREF">false</a></p></li><li><p><a href="#FDFORMATREF">fdformat</a></p></li><li><p><a href="#FDISKREF">fdisk</a></p></li><li><p><a href="#FGREF">fg</a></p></li><li><p><a href="#FGREPREF">fgrep</a></p></li><li><p><a href="#FILEREF">file</a></p></li><li><p><a href="#FINDREF">find</a></p></li><li><p><a href="#FINGERREF">finger</a></p></li><li><p><a href="#FLEXREF">flex</a></p></li><li><p><a href="#FLOCKREF">flock</a></p></li><li><p><a href="#FMTREF">fmt</a></p></li><li><p><a href="#FOLDREF">fold</a></p></li><li><p><a href="#FREEREF">free</a></p></li><li><p><a href="#FSCKREF">fsck</a></p></li><li><p><a href="#FTPREF">ftp</a></p></li><li><p><a href="#FUSERREF">fuser</a></p></li><li><p><a href="#GETFACLREF">getfacl</a></p></li><li><p><a href="#GETOPTY">getopt</a></p></li><li><p><a href="#GETOPTSX">getopts</a></p></li><li><p><a href="#GETTEXTREF">gettext</a></p></li><li><p><a href="#GETTYREF">getty</a></p></li><li><p><a href="#GNOMEMOUNTREF">gnome-mount</a></p></li><li><p><a href="#GREPREF">grep</a></p></li><li><p><a href="#GROFFREF">groff</a></p></li><li><p><a href="#GROUPMODREF">groupmod</a></p></li><li><p><a href="#GROUPSCMDREF">groups</a>
       (Related topic: the <a href="#GROUPSREF">$GROUPS</a>
       variable)</p></li><li><p><a href="#GSREF">gs</a></p></li><li><p><a href="#GZIPREF">gzip</a></p></li><li><p><a href="#HALTREF">halt</a></p></li><li><p><a href="#HASHCMDREF">hash</a></p></li><li><p><a href="#HDPARMREF">hdparm</a></p></li><li><p><a href="#HEADREF">head</a></p></li><li><p><a href="#HELPREF">help</a></p></li><li><p><a href="#HEXDUMPREF">hexdump</a></p></li><li><p><a href="#HOSTREF">host</a></p></li><li><p><a href="#HOSTIDREF">hostid</a></p></li><li><p><a href="#HNAMEREF">hostname</a>
       (Related topic: the <a href="#HOSTNAMEREF">$HOSTNAME</a>
       variable)</p></li><li><p><a href="#HWCLOCKREF">hwclock</a></p></li><li><p><a href="#ICONVREF">iconv</a></p></li><li><p><a href="#IDREF">id</a>
       (Related topic: the <a href="#UIDREF">$UID</a>
           variable)</p></li><li><p><a href="#IFCONFIGREF">ifconfig</a></p></li><li><p><a href="#INFOREF">info</a></p></li><li><p><a href="#INFOCMPREF">infocmp</a></p></li><li><p><a href="#INITREF">init</a></p></li><li><p><a href="#INSMODREF">insmod</a></p></li><li><p><a href="#INSTALLREF">install</a></p></li><li><p><a href="#IPREF">ip</a></p></li><li><p><a href="#IPCALCREF">ipcalc</a></p></li><li><p><a href="#IPTABLESREF">iptables</a></p></li><li><p><a href="#IWCONFIGREF">iwconfig</a></p></li><li><p><a href="#JOBSREF">jobs</a></p></li><li><p><a href="#JOINREF">join</a></p></li><li><p><a href="#JOTREF">jot</a></p></li><li><p><a href="#KILLREF">kill</a></p></li><li><p><a href="#KILLALLREF">killall</a></p></li><li><p><a href="#LASTREF">last</a></p></li><li><p><a href="#LASTCOMMREF">lastcomm</a></p></li><li><p><a href="#LASTLOGREF">lastlog</a></p></li><li><p><a href="#LDDREF">ldd</a></p></li><li><p><a href="#LESSREF">less</a></p></li><li><p><a href="#LETREF">let</a></p></li><li><p><a href="#LEXREF">lex</a></p></li><li><p><a href="#LIDREF">lid</a></p></li><li><p><a href="#LINKREF">ln</a></p></li><li><p><a href="#LOCATEREF">locate</a></p></li><li><p><a href="#LOCKFILEREF">lockfile</a></p></li><li><p><a href="#LOGGERREF">logger</a></p></li><li><p><a href="#LOGNAMEREF">logname</a></p></li><li><p><a href="#LOGOUTREF">logout</a></p></li><li><p><a href="#LOGROTATEREF">logrotate</a></p></li><li><p><a href="#LOOKREF">look</a></p></li><li><p><a href="#LOSETUPREF">losetup</a></p></li><li><p><a href="#LPREF">lp</a></p></li><li><p><a href="#LSREF">ls</a></p></li><li><p><a href="#LSDEVREF">lsdev</a></p></li><li><p><a href="#LSMODREF">lsmod</a></p></li><li><p><a href="#LSOFREF">lsof</a></p></li><li><p><a href="#LSPCIREF">lspci</a></p></li><li><p><a href="#LSUSBREF">lsusb</a></p></li><li><p><a href="#LTRACEREF">ltrace</a></p></li><li><p><a href="#LYNXREF">lynx</a></p></li><li><p><a href="#LZMAREF">lzcat</a></p></li><li><p><a href="#LZMAREF">lzma</a></p></li><li><p><a href="#M4REF">m4</a></p></li><li><p><a href="#COMMMAIL1">mail</a></p></li><li><p><a href="#MAILSTATSREF">mailstats</a></p></li><li><p><a href="#MAILTOREF">mailto</a></p></li><li><p><a href="#MAKEREF">make</a></p></li><li><p><a href="#MAKEDEVREF">MAKEDEV</a></p></li><li><p><a href="#MANREF">man</a></p></li><li><p><a href="#MAPFILEREF">mapfile</a></p></li><li><p><a href="#MCOOKIEREF">mcookie</a></p></li><li><p><a href="#MD5SUMREF">md5sum</a></p></li><li><p><a href="#MERGEREF">merge</a></p></li><li><p><a href="#MESGREF">mesg</a></p></li><li><p><a href="#MIMENCODEREF">mimencode</a></p></li><li><p><a href="#MKBOOTDISKREF">mkbootdisk</a></p></li><li><p><a href="#MKDIRREF">mkdir</a></p></li><li><p><a href="#MKDOSFSREF">mkdosfs</a></p></li><li><p><a href="#MKE2FSREF">mke2fs</a></p></li><li><p><a href="#MKFIFOREF">mkfifo</a></p></li><li><p><a href="#MKISOFSREF">mkisofs</a></p></li><li><p><a href="#MKNODREF">mknod</a></p></li><li><p><a href="#MKSWAPREF">mkswap</a></p></li><li><p><a href="#MKTEMPREF">mktemp</a></p></li><li><p><a href="#MMENCODEREF">mmencode</a></p></li><li><p><a href="#MODINFOREF">modinfo</a></p></li><li><p><a href="#MODPROBEREF">modprobe</a></p></li><li><p><a href="#MOREREF">more</a></p></li><li><p><a href="#MOUNTREF">mount</a></p></li><li><p><a href="#MSGFMTREF">msgfmt</a></p></li><li><p><a href="#MVREF">mv</a></p></li><li><p><a href="#NCREF">nc</a></p></li><li><p><a href="#NETCONFIGREF">netconfig</a></p></li><li><p><a href="#NETSTATREF">netstat</a></p></li><li><p><a href="#NEWGRPREF">newgrp</a></p></li><li><p><a href="#NICEREF">nice</a></p></li><li><p><a href="#NLREF">nl</a></p></li><li><p><a href="#NMREF">nm</a></p></li><li><p><a href="#NMAPREF">nmap</a></p></li><li><p><a href="#NOHUPREF">nohup</a></p></li><li><p><a href="#NSLOOKUPREF">nslookup</a></p></li><li><p><a href="#OBJDUMPREF">objdump</a></p></li><li><p><a href="#ODREF">od</a></p></li><li><p><a href="#OPENSSLREF">openssl</a></p></li><li><p><a href="#PASSWDREF">passwd</a></p></li><li><p><a href="#PASTEREF">paste</a></p></li><li><p><a href="#PATCHREF">patch</a>
       (Related topic: <a href="#DIFFREF">diff</a>)</p></li><li><p><a href="#PATHCHKREF">pathchk</a></p></li><li><p><a href="#PAXREF">pax</a></p></li><li><p><a href="#PGREPREF">pgrep</a></p></li><li><p><a href="#PIDOFREF">pidof</a></p></li><li><p><a href="#PINGREF">ping</a></p></li><li><p><a href="#PKILLREF">pkill</a></p></li><li><p><a href="#DIRSD">popd</a></p></li><li><p><a href="#PRREF">pr</a></p></li><li><p><a href="#PRINTENVREF">printenv</a></p></li><li><p><a href="#PRINTFREF">printf</a></p></li><li><p><a href="#PROCINFOREF">procinfo</a></p></li><li><p><a href="#PPSSREF">ps</a></p></li><li><p><a href="#PSTREEREF">pstree</a></p></li><li><p><a href="#PTXREF">ptx</a></p></li><li><p><a href="#DIRSD">pushd</a></p></li><li><p><a href="#PWD2REF">pwd</a>
       (Related topic: the <a href="#PWDREF">$PWD</a>
       variable)</p></li><li><p><a href="#QUOTAREF">quota</a></p></li><li><p><a href="#RCPREF">rcp</a></p></li><li><p><a href="#RDEVREF">rdev</a></p></li><li><p><a href="#RDISTREF">rdist</a></p></li><li><p><a href="#READREF">read</a></p></li><li><p><a href="#READELFREF">readelf</a></p></li><li><p><a href="#READLINKREF">readlink</a></p></li><li><p><a href="#READONLYREF">readonly</a></p></li><li><p><a href="#REBOOTREF">reboot</a></p></li><li><p><a href="#RECODEREF">recode</a></p></li><li><p><a href="#NICE2REF">renice</a></p></li><li><p><a href="#RESETREF">reset</a></p></li><li><p><a href="#RESIZEREF">resize</a></p></li><li><p><a href="#RESTOREREF">restore</a></p></li><li><p><a href="#REVREF">rev</a></p></li><li><p><a href="#RLOGINREF">rlogin</a></p></li><li><p><a href="#RMREF">rm</a></p></li><li><p><a href="#RMDIRREF">rmdir</a></p></li><li><p><a href="#RMMODREF">rmmod</a></p></li><li><p><a href="#ROUTEREF">route</a></p></li><li><p><a href="#RPMREF">rpm</a></p></li><li><p><a href="#RPM2CPIOREF">rpm2cpio</a></p></li><li><p><a href="#RSHREF">rsh</a></p></li><li><p><a href="#RSYNCREF">rsync</a></p></li><li><p><a href="#RUNLEVELREF">runlevel</a></p></li><li><p><a href="#RUNPARTSREF">run-parts</a></p></li><li><p><a href="#RXREF">rx</a></p></li><li><p><a href="#RZREF">rz</a></p></li><li><p><a href="#SARREF">sar</a></p></li><li><p><a href="#SCPREF">scp</a></p></li><li><p><a href="#SCRIPTREF">script</a></p></li><li><p><a href="#SDIFFREF">sdiff</a></p></li><li><p><a href="#SEDREF">sed</a></p></li><li><p><a href="#SEQREF">seq</a></p></li><li><p><a href="#SERVICEREF">service</a></p></li><li><p><a href="#SETREF">set</a></p></li><li><p><a href="#SETFACLREF">setfacl</a></p></li><li><p><a href="#SETQUOTAREF">setquota</a></p></li><li><p><a href="#SETSERIALREF">setserial</a></p></li><li><p><a href="#SETTERMREF">setterm</a></p></li><li><p><a href="#SHA1SUMREF">sha1sum</a></p></li><li><p><a href="#SHARREF">shar</a></p></li><li><p><a href="#SHOPTREF">shopt</a></p></li><li><p><a href="#SHREDREF">shred</a></p></li><li><p><a href="#SHUTDOWNREF">shutdown</a></p></li><li><p><a href="#SIZEREF">size</a></p></li><li><p><a href="#NICE2REF">skill</a></p></li><li><p><a href="#SLEEPREF">sleep</a></p></li><li><p><a href="#SLOCATEREF">slocate</a></p></li><li><p><a href="#NICE2REF">snice</a></p></li><li><p><a href="#SORTREF">sort</a></p></li><li><p><a href="#SOURCEREF">source</a></p></li><li><p><a href="#SOXREF">sox</a></p></li><li><p><a href="#SPLITREF">split</a></p></li><li><p><a href="#SQREF">sq</a></p></li><li><p><a href="#SSHREF">ssh</a></p></li><li><p><a href="#STATREF">stat</a></p></li><li><p><a href="#STRACEREF">strace</a></p></li><li><p><a href="#STRINGSREF">strings</a></p></li><li><p><a href="#STRIPREF">strip</a></p></li><li><p><a href="#STTYREF">stty</a></p></li><li><p><a href="#SUREF">su</a></p></li><li><p><a href="#SUDOREF">sudo</a></p></li><li><p><a href="#SUMREF">sum</a></p></li><li><p><a href="#SUSPENDREF">suspend</a></p></li><li><p><a href="#SWAPONREF">swapoff</a></p></li><li><p><a href="#SWAPONREF">swapon</a></p></li><li><p><a href="#RXREF">sx</a></p></li><li><p><a href="#SYNCREF">sync</a></p></li><li><p><a href="#RZREF">sz</a></p></li><li><p><a href="#CATREF">tac</a></p></li><li><p><a href="#TAILREF">tail</a></p></li><li><p><a href="#TARREF">tar</a></p></li><li><p><a href="#TBLREF">tbl</a></p></li><li><p><a href="#TCPDUMPREF">tcpdump</a></p></li><li><p><a href="#TEEREF">tee</a></p></li><li><p><a href="#TELINITREF">telinit</a></p></li><li><p><a href="#TELNETREF">telnet</a></p></li><li><p><a href="#TEXREF">Tex</a></p></li><li><p><a href="#TEXEXECREF">texexec</a></p></li><li><p><a href="#TIMREF">time</a></p></li><li><p><a href="#TIMESREF">times</a></p></li><li><p><a href="#TMPWATCHREF">tmpwatch</a></p></li><li><p><a href="#TOPREF">top</a></p></li><li><p><a href="#TOUCHREF">touch</a></p></li><li><p><a href="#TPUTREF">tput</a></p></li><li><p><a href="#TRREF">tr</a></p></li><li><p><a href="#TRACEROUTEREF">traceroute</a></p></li><li><p><a href="#TRUEREF">true</a></p></li><li><p><a href="#TSETREF">tset</a></p></li><li><p><a href="#TSORTREF">tsort</a></p></li><li><p><a href="#TTYREF">tty</a></p></li><li><p><a href="#TUNE2FSREF">tune2fs</a></p></li><li><p><a href="#TYPEREF">type</a></p></li><li><p><a href="#DECLAREREF">typeset</a></p></li><li><p><a href="#ULIMITREF">ulimit</a></p></li><li><p><a href="#UMASKREF">umask</a></p></li><li><p><a href="#UMOUNTREF">umount</a></p></li><li><p><a href="#UNAMEREF">uname</a></p></li><li><p><a href="#UNARCREF">unarc</a></p></li><li><p><a href="#UNARCREF">unarj</a></p></li><li><p><a href="#UNCOMPRESSREF">uncompress</a></p></li><li><p><a href="#EXPANDREF">unexpand</a></p></li><li><p><a href="#UNIQREF">uniq</a></p></li><li><p><a href="#UNITSREF">units</a></p></li><li><p><a href="#LZMAREF">unlzma</a></p></li><li><p><a href="#UNARCREF">unrar</a></p></li><li><p><a href="#UNSETREF">unset</a></p></li><li><p><a href="#SQREF">unsq</a></p></li><li><p><a href="#ZIPREF">unzip</a></p></li><li><p><a href="#UPTIMEREF">uptime</a></p></li><li><p><a href="#LSUSBREF">usbmodules</a></p></li><li><p><a href="#USERADDREF">useradd</a></p></li><li><p><a href="#USERADDREF">userdel</a></p></li><li><p><a href="#USERMODREF">usermod</a></p></li><li><p><a href="#USERSREF">users</a></p></li><li><p><a href="#USLEEPREF">usleep</a></p></li><li><p><a href="#UUCPREF">uucp</a></p></li><li><p><a href="#UUDECODEREF">uudecode</a></p></li><li><p><a href="#UUENCODEREF">uuencode</a></p></li><li><p><a href="#UUXREF">uux</a></p></li><li><p><a href="#VACATIONREF">vacation</a></p></li><li><p><a href="#VDIRREF">vdir</a></p></li><li><p><a href="#VMSTATREF">vmstat</a></p></li><li><p><a href="#VRFYREF">vrfy</a></p></li><li><p><a href="#WREF">w</a></p></li><li><p><a href="#WAITREF">wait</a></p></li><li><p><a href="#WALLREF">wall</a></p></li><li><p><a href="#WATCHREF">watch</a></p></li><li><p><a href="#WCREF">wc</a></p></li><li><p><a href="#WGETREF">wget</a></p></li><li><p><a href="#WHATISREF">whatis</a></p></li><li><p><a href="#WHEREISREF">whereis</a></p></li><li><p><a href="#WHICHREF">which</a></p></li><li><p><a href="#WHOREF">who</a></p></li><li><p><a href="#WHOAMIREF">whoami</a></p></li><li><p><a href="#WHOISREF">whois</a></p></li><li><p><a href="#WRITEREF">write</a></p></li><li><p><a href="#XARGSREF">xargs</a></p></li><li><p><a href="#XRANDRREF">xrandr</a></p></li><li><p><a href="#XZREF">xz</a></p></li><li><p><a href="#YACCREF">yacc</a></p></li><li><p><a href="#YESREF">yes</a></p></li><li><p><a href="#ZCATREF">zcat</a></p></li><li><p><a href="#ZDIFFREF">zdiff</a></p></li><li><p><a href="#ZDUMPREF">zdump</a></p></li><li><p><a href="#ZEGREPREF">zegrep</a></p></li><li><p><a href="#ZEGREPREF">zfgrep</a></p></li><li><p><a href="#ZEGREPREF">zgrep</a></p></li><li><p><a href="#ZIPREF">zip</a></p></li></ul></div><div class="TOC"><dl><dt><b>Table of Contents</b></dt><dt>15. <a href="#INTERNAL">Internal Commands and Builtins</a></dt><dd><dl><dt>15.1. <a href="#AEN9644">Job Control Commands</a></dt></dl></dd><dt>16. <a href="#EXTERNAL">External Filters, Programs and Commands</a></dt><dd><dl><dt>16.1. <a href="#BASIC">Basic Commands</a></dt><dt>16.2. <a href="#MOREADV">Complex Commands</a></dt><dt>16.3. <a href="#TIMEDATE">Time / Date Commands</a></dt><dt>16.4. <a href="#TEXTPROC">Text Processing Commands</a></dt><dt>16.5. <a href="#FILEARCHIV">File and Archiving Commands</a></dt><dt>16.6. <a href="#COMMUNICATIONS">Communications Commands</a></dt><dt>16.7. <a href="#TERMINALCCMDS">Terminal Control Commands</a></dt><dt>16.8. <a href="#MATHC">Math Commands</a></dt><dt>16.9. <a href="#EXTMISC">Miscellaneous Commands</a></dt></dl></dd><dt>17. <a href="#SYSTEM">System and Administrative Commands</a></dt><dd><dl><dt>17.1. <a href="#SYSSCRIPTS">Analyzing a System Script</a></dt></dl></dd></dl></div></div><div class="CHAPTER"><hr><h1><a name="INTERNAL"></a>Chapter 15. Internal Commands and Builtins</h1><p><a name="BUILTINREF"></a>A <i class="FIRSTTERM">builtin</i>
    is a <b class="COMMAND">command</b> contained within the Bash tool
    set, literally <i class="FIRSTTERM">built in</i>. This is either
    for performance reasons -- builtins execute faster than external
    commands, which usually require <i class="FIRSTTERM">forking off</i>
      <a name="AEN8607" href="#FTN.AEN8607"><span class="footnote">[58]</span></a>
    a separate process -- or because a particular builtin needs
    direct access to the shell internals.</p><p><a name="FORKREF"></a></p><table class="SIDEBAR" border="1" cellpadding="5"><tbody><tr><td><div class="SIDEBAR"><a name="AEN8611"></a><p></p><p><a name="PARENTREF"></a>When a command or
         the shell itself initiates (or
         <i class="FIRSTTERM">spawns</i>) a new
         subprocess to carry out a task, this is called
         <i class="FIRSTTERM">forking</i>. This new process
         is the <i class="FIRSTTERM">child</i>, and the process
         that <i class="FIRSTTERM">forked</i> it off is the
         <i class="FIRSTTERM">parent</i>. While the <i class="FIRSTTERM">child
         process</i> is doing its work, the
         <i class="FIRSTTERM">parent process</i> is still
         executing.</p><p>Note that while a <i class="FIRSTTERM">parent
         process</i> gets the <i class="FIRSTTERM">process
         ID</i> of the <i class="FIRSTTERM">child
         process</i>, and can thus pass arguments to it,
         <em>the reverse is not true</em>. <a href="#PARCHILDPROBREF">This can create problems
         that are subtle and hard to track down.</a></p><div class="EXAMPLE"><a name="SPAWNSCR"></a><p><b>Example 15-1. A script that spawns multiple instances of itself</b></p><table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # spawn.sh
  
  
  PIDS=$(pidof sh $0)  # Process IDs of the various instances of this script.
  P_array=( $PIDS )    # Put them in an array (why?).
  echo $PIDS           # Show process IDs of parent and child processes.
  let "instances = ${#P_array[*]} - 1"  # Count elements, less 1.
                                        # Why subtract 1?
  echo "$instances instance(s) of this script running."
  echo "[Hit Ctl-C to exit.]"; echo
  
  
  sleep 1              # Wait.
  sh $0                # Play it again, Sam.
  
  exit 0               # Not necessary; script will never get to here.
                       # Why not?
  
  #  After exiting with a Ctl-C,
  #+ do all the spawned instances of the script die?
  #  If so, why?
  
  # Note:
  # ----
  # Be careful not to run this script too long.
  # It will eventually eat up too many system resources.
  
  #  Is having a script spawn multiple instances of itself
  #+ an advisable scripting technique.
  #  Why or why not?</pre></font></td></tr></tbody></table></div><p><a name="BLTINFRK"></a></p><p>Generally, a Bash <i class="FIRSTTERM">builtin</i>
         does not fork a subprocess when it executes within
         a script. An external system command or filter in
         a script usually <em>will</em> fork a
         subprocess.</p><p></p></div></td></tr></tbody></table><p>A builtin may be a synonym to a system command of the same
    name, but Bash reimplements it internally.  For example,
    the Bash <b class="COMMAND">echo</b> command is not the same as
    <tt class="FILENAME">/bin/echo</tt>, although their behavior is
    almost identical.
       <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  echo "This line uses the \"echo\" builtin."
  /bin/echo "This line uses the /bin/echo system command."</pre></font></td></tr></tbody></table>
    </p><p><a name="KEYWORDREF"></a>A <i class="FIRSTTERM">keyword</i>
    is a <i class="FIRSTTERM">reserved</i> word, token or
    operator. Keywords have a special meaning to the shell,
    and indeed are the building blocks of the shell's
    syntax. As examples, <i class="FIRSTTERM">for</i>,
    <i class="FIRSTTERM">while</i>, <i class="FIRSTTERM">do</i>,
    and <i class="FIRSTTERM">!</i> are keywords. Similar to a <a href="#BUILTINREF">builtin</a>, a keyword is hard-coded into
    Bash, but unlike a <i class="FIRSTTERM">builtin</i>, a keyword is
    not in itself a command, but <em>a subunit of a command
    construct</em>.
  
       <a name="AEN8650" href="#FTN.AEN8650"><span class="footnote">[59]</span></a>
  
    </p><p></p><div class="VARIABLELIST"><p><b><a name="INTIO1"></a>I/O</b></p><dl><dt><a name="ECHOREF"></a><b class="COMMAND">echo</b></dt><dd><p>prints (to <tt class="FILENAME">stdout</tt>) an expression
          or variable (see <a href="#EX9">Example 4-1</a>). 
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo Hello
  echo $a</pre></font></td></tr></tbody></table></p><p>An <b class="COMMAND">echo</b> requires the
          <tt class="OPTION">-e</tt> option to print escaped characters. See
          <a href="#ESCAPED">Example 5-2</a>.</p><p>Normally, each <b class="COMMAND">echo</b> command prints
          a terminal newline, but the <tt class="OPTION">-n</tt> option
          suppresses this.</p><p><a name="ECHOGREPREF"></a></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>An <b class="COMMAND">echo</b> can be used to feed a
          sequence of commands down a pipe.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">if echo "$VAR" | grep -q txt   # if [[ $VAR = *txt* ]]
  then
    echo "$VAR contains the substring sequence \"txt\""
  fi</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div><p><a name="ECHOCS"></a></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>An <b class="COMMAND">echo</b>, in combination with
          <a href="#COMMANDSUBREF">command substitution</a>
          can set a variable.</p><p><tt class="USERINPUT"><b>a=`echo
          "HELLO" | tr A-Z a-z`</b></tt></p><p>See also <a href="#LOWERCASE">Example 16-22</a>, <a href="#EX57">Example 16-3</a>, <a href="#MONTHLYPMT">Example 16-47</a>, and <a href="#BASE">Example 16-48</a>.</p></td></tr></tbody></table></div><p>Be aware that <b class="COMMAND">echo `command`</b>
          deletes any linefeeds that the output
          of <tt class="REPLACEABLE"><i>command</i></tt>
          generates.</p><p>The <a href="#IFSREF">$IFS</a> (internal field
          separator) variable normally contains
          <span class="TOKEN">\n</span> (linefeed) as one of its set of
          <a href="#WHITESPACEREF">whitespace</a>
          characters. Bash therefore splits the output of
          <tt class="REPLACEABLE"><i>command</i></tt> at linefeeds
          into arguments to <b class="COMMAND">echo</b>.  Then
          <b class="COMMAND">echo</b> outputs these arguments,
          separated by spaces.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -l /usr/share/apps/kjezz/sounds</b></tt>
  <tt class="COMPUTEROUTPUT">-rw-r--r--    1 root     root         1407 Nov  7  2000 reflect.au
   -rw-r--r--    1 root     root          362 Nov  7  2000 seconds.au</tt>
  
  
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo `ls -l /usr/share/apps/kjezz/sounds`</b></tt>
  <tt class="COMPUTEROUTPUT">total 40 -rw-r--r-- 1 root root 716 Nov 7 2000 reflect.au -rw-r--r-- 1 root root ...</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>              So, how can we embed a linefeed within an
          <a href="#ECHOREF">echoed</a> character string?
  
         <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Embedding a linefeed?
  echo "Why doesn't this string \n split on two lines?"
  # Doesn't split.
  
  # Let's try something else.
  
  echo
         
  echo $"A line of text containing
  a linefeed."
  # Prints as two distinct lines (embedded linefeed).
  # But, is the "$" variable prefix really necessary?
  
  echo
  
  echo "This string splits
  on two lines."
  # No, the "$" is not needed.
  
  echo
  echo "---------------"
  echo
  
  echo -n $"Another line of text containing
  a linefeed."
  # Prints as two distinct lines (embedded linefeed).
  # Even the -n option fails to suppress the linefeed here.
  
  echo
  echo
  echo "---------------"
  echo
  echo
  
  # However, the following doesn't work as expected.
  # Why not? Hint: Assignment to a variable.
  string1=$"Yet another line of text containing
  a linefeed (maybe)."
  
  echo $string1
  # Yet another line of text containing a linefeed (maybe).
  #                                    ^
  # Linefeed becomes a space.
  
  # Thanks, Steve Parker, for pointing this out.</pre></font></td></tr></tbody></table>
              </p><p><a name="BINECHO"></a></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>This command is a shell builtin, and not the same as
          <tt class="FILENAME">/bin/echo</tt>, although its behavior is
          similar.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>type -a echo</b></tt>
  <tt class="COMPUTEROUTPUT">echo is a shell builtin
   echo is /bin/echo</tt>
          </pre></font></td></tr></tbody></table>
      </p></td></tr></tbody></table></div></dd><dt><a name="PRINTFREF"></a><b class="COMMAND">printf</b></dt><dd><p>The <b class="COMMAND">printf</b>, formatted print, command is an
          enhanced <b class="COMMAND">echo</b>. It is a limited variant
          of the <i class="FIRSTTERM">C</i> language
          <tt class="FUNCTION">printf()</tt> library function, and its
          syntax is somewhat different.</p><p><b class="COMMAND">printf</b>   <tt class="REPLACEABLE"><i>format-string</i></tt>...   <tt class="REPLACEABLE"><i>parameter</i></tt>... </p><p>This is the Bash <i class="FIRSTTERM">builtin</i> version
          of the <tt class="FILENAME">/bin/printf</tt> or
          <tt class="FILENAME">/usr/bin/printf</tt> command. See the
          <b class="COMMAND">printf</b> <a href="#MANREF">manpage</a> (of the system command)
          for in-depth coverage.</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>Older versions of Bash may not support
          <b class="COMMAND">printf</b>.</p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="EX47"></a><p><b>Example 15-2. <i class="FIRSTTERM">printf</i> in action</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # printf demo
  
  declare -r PI=3.14159265358979     # Read-only variable, i.e., a constant.
  declare -r DecimalConstant=31373
  
  Message1="Greetings,"
  Message2="Earthling."
  
  echo
  
  printf "Pi to 2 decimal places = %1.2f" $PI
  echo
  printf "Pi to 9 decimal places = %1.9f" $PI  # It even rounds off correctly.
  
  printf "\n"                                  # Prints a line feed,
                                               # Equivalent to 'echo' . . .
  
  printf "Constant = \t%d\n" $DecimalConstant  # Inserts tab (\t).
  
  printf "%s %s \n" $Message1 $Message2
  
  echo
  
  # ==========================================#
  # Simulation of C function, sprintf().
  # Loading a variable with a formatted string.
  
  echo 
  
  Pi12=$(printf "%1.12f" $PI)
  echo "Pi to 12 decimal places = $Pi12"      # Roundoff error!
  
  Msg=`printf "%s %s \n" $Message1 $Message2`
  echo $Msg; echo $Msg
  
  #  As it happens, the 'sprintf' function can now be accessed
  #+ as a loadable module to Bash,
  #+ but this is not portable.
  
  exit 0</pre></font></td></tr></tbody></table></div><p>Formatting error messages is a useful application of
          <b class="COMMAND">printf</b></p><p>	        <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">E_BADDIR=85
  
  var=nonexistent_directory
  
  error()
  {
    printf "$@" &gt;&amp;2
    # Formats positional params passed, and sends them to stderr.
    echo
    exit $E_BADDIR
  }
  
  cd $var || error $"Can't cd to %s." "$var"
  
  # Thanks, S.C.</pre></font></td></tr></tbody></table>
              </p><p>See also <a href="#PROGRESSBAR">Example 36-17</a>.</p></dd><dt><a name="READREF"></a><b class="COMMAND">read</b></dt><dd><p><span class="QUOTE">"Reads"</span> the value
        of a variable from <tt class="FILENAME">stdin</tt>, that
        is, interactively fetches input from the keyboard. The
        <tt class="OPTION">-a</tt> option lets <b class="COMMAND">read</b>
        get array variables (see <a href="#EX67">Example 27-6</a>).</p><div class="EXAMPLE"><a name="EX36"></a><p><b>Example 15-3. Variable assignment, using <i class="FIRSTTERM">read</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # "Reading" variables.
  
  echo -n "Enter the value of variable 'var1': "
  # The -n option to echo suppresses newline.
  
  read var1
  # Note no '$' in front of var1, since it is being set.
  
  echo "var1 = $var1"
  
  
  echo
  
  # A single 'read' statement can set multiple variables.
  echo -n "Enter the values of variables 'var2' and 'var3' "
  echo =n "(separated by a space or tab): "
  read var2 var3
  echo "var2 = $var2      var3 = $var3"
  #  If you input only one value,
  #+ the other variable(s) will remain unset (null).
  
  exit 0</pre></font></td></tr></tbody></table></div><p>A <b class="COMMAND">read</b> without an associated variable
          assigns its input to the dedicated variable <a href="#REPLYREF">$REPLY</a>.</p><div class="EXAMPLE"><a name="READNOVAR"></a><p><b>Example 15-4. What happens when <i class="FIRSTTERM">read</i> has no
            variable</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # read-novar.sh
  
  echo
  
  # -------------------------- #
  echo -n "Enter a value: "
  read var
  echo "\"var\" = "$var""
  # Everything as expected here.
  # -------------------------- #
  
  echo
  
  # ------------------------------------------------------------------- #
  echo -n "Enter another value: "
  read           #  No variable supplied for 'read', therefore...
                 #+ Input to 'read' assigned to default variable, $REPLY.
  var="$REPLY"
  echo "\"var\" = "$var""
  # This is equivalent to the first code block.
  # ------------------------------------------------------------------- #
  
  echo
  echo "========================="
  echo
  
  
  #  This example is similar to the "reply.sh" script.
  #  However, this one shows that $REPLY is available
  #+ even after a 'read' to a variable in the conventional way.
  
  
  # ================================================================= #
  
  #  In some instances, you might wish to discard the first value read.
  #  In such cases, simply ignore the $REPLY variable.
  
  { # Code block.
  read            # Line 1, to be discarded.
  read line2      # Line 2, saved in variable.
    } &lt;$0
  echo "Line 2 of this script is:"
  echo "$line2"   #   # read-novar.sh
  echo            #   #!/bin/bash  line discarded.
  
  # See also the soundcard-on.sh script.
  
  exit 0</pre></font></td></tr></tbody></table></div><p>Normally, inputting a <tt class="USERINPUT"><b>\</b></tt>
          suppresses a newline during input to
          a <b class="COMMAND">read</b>. The <tt class="OPTION">-r</tt>
          option causes an inputted <tt class="USERINPUT"><b>\</b></tt> to be
          interpreted literally.</p><div class="EXAMPLE"><a name="READR"></a><p><b>Example 15-5. Multi-line input to <i class="FIRSTTERM">read</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  echo
  
  echo "Enter a string terminated by a \\, then press &lt;ENTER&gt;."
  echo "Then, enter a second string (no \\ this time), and again press &lt;ENTER&gt;."
  
  read var1     # The "\" suppresses the newline, when reading $var1.
                #     first line \
                #     second line
  
  echo "var1 = $var1"
  #     var1 = first line second line
  
  #  For each line terminated by a "\"
  #+ you get a prompt on the next line to continue feeding characters into var1.
  
  echo; echo
  
  echo "Enter another string terminated by a \\ , then press &lt;ENTER&gt;."
  read -r var2  # The -r option causes the "\" to be read literally.
                #     first line \
  
  echo "var2 = $var2"
  #     var2 = first line \
  
  # Data entry terminates with the first &lt;ENTER&gt;.
  
  echo 
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="READOPTIONS"></a></p><p>The <b class="COMMAND">read</b> command has some interesting
          options that permit echoing a prompt and even reading keystrokes
          without hitting <b class="KEYCAP">ENTER</b>.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Read a keypress without hitting ENTER.
  
  read -s -n1 -p "Hit a key " keypress
  echo; echo "Keypress was "\"$keypress\""."
  
  # -s option means do not echo input.
  # -n N option means accept only N characters of input.
  # -p option means echo the following prompt before reading input.
  
  # Using these options is tricky, since they need to be in the correct order.</pre></font></td></tr></tbody></table></p><p><a name="READARROW"></a></p><p>The <tt class="OPTION">-n</tt> option to <b class="COMMAND">read</b>
          also allows detection of the <b class="KEYCAP">arrow keys</b>
          and certain of the other unusual keys.</p><div class="EXAMPLE"><a name="ARROWDETECT"></a><p><b>Example 15-6. Detecting the arrow keys</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # arrow-detect.sh: Detects the arrow keys, and a few more.
  # Thank you, Sandro Magi, for showing me how.
  
  # --------------------------------------------
  # Character codes generated by the keypresses.
  arrowup='\[A'
  arrowdown='\[B'
  arrowrt='\[C'
  arrowleft='\[D'
  insert='\[2'
  delete='\[3'
  # --------------------------------------------
  
  SUCCESS=0
  OTHER=65
  
  echo -n "Press a key...  "
  # May need to also press ENTER if a key not listed above pressed.
  read -n3 key                      # Read 3 characters.
  
  echo -n "$key" | grep "$arrowup"  #Check if character code detected.
  if [ "$?" -eq $SUCCESS ]
  then
    echo "Up-arrow key pressed."
    exit $SUCCESS
  fi
  
  echo -n "$key" | grep "$arrowdown"
  if [ "$?" -eq $SUCCESS ]
  then
    echo "Down-arrow key pressed."
    exit $SUCCESS
  fi
  
  echo -n "$key" | grep "$arrowrt"
  if [ "$?" -eq $SUCCESS ]
  then
    echo "Right-arrow key pressed."
    exit $SUCCESS
  fi
  
  echo -n "$key" | grep "$arrowleft"
  if [ "$?" -eq $SUCCESS ]
  then
    echo "Left-arrow key pressed."
    exit $SUCCESS
  fi
  
  echo -n "$key" | grep "$insert"
  if [ "$?" -eq $SUCCESS ]
  then
    echo "\"Insert\" key pressed."
    exit $SUCCESS
  fi
  
  echo -n "$key" | grep "$delete"
  if [ "$?" -eq $SUCCESS ]
  then
    echo "\"Delete\" key pressed."
    exit $SUCCESS
  fi
  
  
  echo " Some other key pressed."
  
  exit $OTHER
  
  # ========================================= #
  
  #  Mark Alexander came up with a simplified
  #+ version of the above script (Thank you!).
  #  It eliminates the need for grep.
  
  #!/bin/bash
  
    uparrow=$'\x1b[A'
    downarrow=$'\x1b[B'
    leftarrow=$'\x1b[D'
    rightarrow=$'\x1b[C'
  
    read -s -n3 -p "Hit an arrow key: " x
  
    case "$x" in
    $uparrow)
       echo "You pressed up-arrow"
       ;;
    $downarrow)
       echo "You pressed down-arrow"
       ;;
    $leftarrow)
       echo "You pressed left-arrow"
       ;;
    $rightarrow)
       echo "You pressed right-arrow"
       ;;
    esac
  
  exit $?
  
  # ========================================= #
  
  # Antonio Macchi has a simpler alternative.
  
  #!/bin/bash
  
  while true
  do
    read -sn1 a
    test "$a" == `echo -en "\e"` || continue
    read -sn1 a
    test "$a" == "[" || continue
    read -sn1 a
    case "$a" in
      A)  echo "up";;
      B)  echo "down";;
      C)  echo "right";;
      D)  echo "left";;
    esac
  done
  
  # ========================================= #
  
  #  Exercise:
  #  --------
  #  1) Add detection of the "Home," "End," "PgUp," and "PgDn" keys.</pre></font></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <tt class="OPTION">-n</tt> option to <b class="COMMAND">read</b>
          will not detect the <b class="KEYCAP">ENTER</b> (newline)
          key.</p></td></tr></tbody></table></div><p><a name="READTIMED"></a></p><p>The <tt class="OPTION">-t</tt> option to <b class="COMMAND">read</b>
          permits timed input (see <a href="#TOUT">Example 9-4</a> and <a href="#QKY">Example A-41</a>).</p><p><a name="READFD"></a>The <tt class="OPTION">-u</tt> option
                  takes the <a href="#FDREF">file descriptor</a>
                  of the target file.</p><p><a name="READREDIR0"></a></p><p>The <b class="COMMAND">read</b> command may also
          <span class="QUOTE">"read"</span> its variable value from a file
          <a href="#IOREDIRREF">redirected</a> to
          <tt class="FILENAME">stdin</tt>.  If the file contains
          more than one line, only the first line is assigned
          to the variable. If <b class="COMMAND">read</b>
          has more than one parameter, then each of
          these variables gets assigned a successive <a href="#WHITESPACEREF">whitespace-delineated</a>
          string. Caution!</p><div class="EXAMPLE"><a name="READREDIR"></a><p><b>Example 15-7. Using <i class="FIRSTTERM">read</i> with
            <a href="#IOREDIRREF">file redirection</a></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  read var1 &lt;data-file
  echo "var1 = $var1"
  # var1 set to the entire first line of the input file "data-file"
  
  read var2 var3 &lt;data-file
  echo "var2 = $var2   var3 = $var3"
  # Note non-intuitive behavior of "read" here.
  # 1) Rewinds back to the beginning of input file.
  # 2) Each variable is now set to a corresponding string,
  #    separated by whitespace, rather than to an entire line of text.
  # 3) The final variable gets the remainder of the line.
  # 4) If there are more variables to be set than whitespace-terminated strings
  #    on the first line of the file, then the excess variables remain empty.
  
  echo "------------------------------------------------"
  
  # How to resolve the above problem with a loop:
  while read line
  do
    echo "$line"
  done &lt;data-file
  # Thanks, Heiner Steven for pointing this out.
  
  echo "------------------------------------------------"
  
  # Use $IFS (Internal Field Separator variable) to split a line of input to
  # "read", if you do not want the default to be whitespace.
  
  echo "List of all users:"
  OIFS=$IFS; IFS=:       # /etc/passwd uses ":" for field separator.
  while read name passwd uid gid fullname ignore
  do
    echo "$name ($fullname)"
  done &lt;/etc/passwd   # I/O redirection.
  IFS=$OIFS              # Restore original $IFS.
  # This code snippet also by Heiner Steven.
  
  
  
  #  Setting the $IFS variable within the loop itself
  #+ eliminates the need for storing the original $IFS
  #+ in a temporary variable.
  #  Thanks, Dim Segebart, for pointing this out.
  echo "------------------------------------------------"
  echo "List of all users:"
  
  while IFS=: read name passwd uid gid fullname ignore
  do
    echo "$name ($fullname)"
  done &lt;/etc/passwd   # I/O redirection.
  
  echo
  echo "\$IFS still $IFS"
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p><a name="PIPEREADREF0"></a></p><p><a href="#PIPEREF">Piping</a> output
          to a <i class="FIRSTTERM">read</i>, using <a href="#ECHOREF">echo</a> to set variables <a href="#BADREAD0">will fail</a>.</p><p><a name="READPIPEREF"></a>Yet, piping the output of <a href="#CATREF">cat</a> <em>seems</em> to
          work.</p><p><a name="WHILEREADREF"></a></p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">cat file1 file2 |
  while read line
  do
  echo $line
  done</pre></font></td></tr></tbody></table></p><p>However, as BjÃ¶n Eriksson shows:</p><div class="EXAMPLE"><a name="READPIPE"></a><p><b>Example 15-8. Problems reading from a pipe</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/sh
  # readpipe.sh
  # This example contributed by Bjon Eriksson.
  
  ### shopt -s lastpipe
  
  last="(null)"
  cat $0 |
  while read line
  do
      echo "{$line}"
      last=$line
  done
  
  echo
  echo "++++++++++++++++++++++"
  printf "\nAll done, last: $last\n" #  The output of this line
                                     #+ changes if you uncomment line 5.
                                     #  (Bash, version -ge 4.2 required.)
  
  exit 0  # End of code.
          # (Partial) output of script follows.
          # The 'echo' supplies extra brackets.
  
  #############################################
  
  ./readpipe.sh 
  
  {#!/bin/sh}
  {last="(null)"}
  {cat $0 |}
  {while read line}
  {do}
  {echo "{$line}"}
  {last=$line}
  {done}
  {printf "nAll done, last: $lastn"}
  
  
  All done, last: (null)
  
  The variable (last) is set within the loop/subshell
  but its value does not persist outside the loop.</pre></font></td></tr></tbody></table></div><p>The <i class="FIRSTTERM">gendiff</i> script, usually
                found in <tt class="FILENAME">/usr/bin</tt> on
                many Linux distros, pipes the output of <a href="#FINDREF">find</a> to a <i class="FIRSTTERM">while
                read</i> construct.
  
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">find $1 \( -name "*$2" -o -name ".*$2" \) -print |
  while read f; do
  . . .</pre></font></td></tr></tbody></table>
              </p></td></tr></tbody></table></div><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>It is possible to <i class="FIRSTTERM">paste</i> text into
            the input field of a <i class="FIRSTTERM">read</i> (but
      <em>not</em> multiple lines!). See <a href="#PADSW">Example A-38</a>.</p></td></tr></tbody></table></div></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="INTFILESYSTEM1"></a>Filesystem</b></p><dl><dt><a name="CDREF"></a><b class="COMMAND">cd</b></dt><dd><p>The familiar <b class="COMMAND">cd</b> change directory
          command finds use in scripts where execution of a command
          requires being in a specified directory.</p><p>  
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)</pre></font></td></tr></tbody></table>
          [from the <a href="#COXEX">previously cited</a>
          example by Alan Cox]</p><p>The <tt class="OPTION">-P</tt> (physical) option to
          <b class="COMMAND">cd</b> causes it to ignore symbolic
          links.</p><p><b class="COMMAND">cd -</b> changes to <a href="#OLDPWD">$OLDPWD</a>, the previous working
        directory.</p><p><a name="DOUBLESLASHREF"></a></p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">cd</b> command does not function
          as expected when presented with two forward slashes.
  
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cd //</b></tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>pwd</b></tt>
  <tt class="COMPUTEROUTPUT">//</tt>
          </pre></font></td></tr></tbody></table>
          The output should, of course, be <tt class="COMPUTEROUTPUT">/</tt>.
          This is a problem both from the command-line and in a script.</p></td></tr></tbody></table></div></dd><dt><a name="PWD2REF"></a><b class="COMMAND">pwd</b></dt><dd><p>Print Working Directory. This gives the user's
          (or script's) current directory (see <a href="#EX37">Example 15-9</a>). The effect is identical to
          reading the value of the builtin variable <a href="#PWDREF">$PWD</a>.</p></dd><dt><a name="DIRSD"></a><b class="COMMAND">pushd</b>, <b class="COMMAND">popd</b>, <b class="COMMAND">dirs</b></dt><dd><p>This command set is a mechanism for bookmarking
          working directories, a means of moving back and forth
          through directories in an orderly manner. A pushdown <a href="#STACKDEFREF">stack</a> is used to keep track
          of directory names. Options allow various manipulations
          of the directory stack.</p><p><a name="PUSHDREF"></a><tt class="USERINPUT"><b>pushd
          dir-name</b></tt> pushes the path
          <tt class="REPLACEABLE"><i>dir-name</i></tt> onto the directory
          stack (to the <i class="FIRSTTERM">top</i> of the stack)
          and simultaneously changes the current working directory
          to <tt class="REPLACEABLE"><i>dir-name</i></tt></p><p><a name="POPDREF"></a><b class="COMMAND">popd</b> removes
          (pops) the top directory path name off the directory stack
          and simultaneously changes the current working directory
          to the directory now at the <i class="FIRSTTERM">top</i> of
          the stack.</p><p><a name="DIRSREF"></a><b class="COMMAND">dirs</b> lists
          the contents of the directory stack (compare this
          with the <a href="#DIRSTACKREF">$DIRSTACK</a>
          variable).  A successful <b class="COMMAND">pushd</b>
          or <b class="COMMAND">popd</b> will automatically invoke
          <b class="COMMAND">dirs</b>.</p><p>Scripts that require various changes to the current
          working directory without hard-coding the directory name
          changes can make good use of these commands. Note that
          the implicit <tt class="VARNAME">$DIRSTACK</tt> array variable,
          accessible from within a script, holds the contents of
          the directory stack.
        </p><div class="EXAMPLE"><a name="EX37"></a><p><b>Example 15-9. Changing the current working directory</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  dir1=/usr/local
  dir2=/var/spool
  
  pushd $dir1
  # Will do an automatic 'dirs' (list directory stack to stdout).
  echo "Now in directory `pwd`." # Uses back-quoted 'pwd'.
  
  # Now, do some stuff in directory 'dir1'.
  pushd $dir2
  echo "Now in directory `pwd`."
  
  # Now, do some stuff in directory 'dir2'.
  echo "The top entry in the DIRSTACK array is $DIRSTACK."
  popd
  echo "Now back in directory `pwd`."
  
  # Now, do some more stuff in directory 'dir1'.
  popd
  echo "Now back in original working directory `pwd`."
  
  exit 0
  
  # What happens if you don't 'popd' -- then exit the script?
  # Which directory do you end up in? Why?</pre></font></td></tr></tbody></table></div></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="INTVAR1"></a>Variables</b></p><dl><dt><a name="LETREF"></a><b class="COMMAND">let</b></dt><dd><p>The <b class="COMMAND">let</b> command carries out
                      <i class="FIRSTTERM">arithmetic</i> operations on variables.
  
            <a name="AEN9009" href="#FTN.AEN9009"><span class="footnote">[60]</span></a>
          
          In many cases, it functions as a less complex version
                      of <a href="#EXPRREF">expr</a>.</p><div class="EXAMPLE"><a name="EX46"></a><p><b>Example 15-10. Letting <i class="FIRSTTERM">let</i> do arithmetic.</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  echo
  
  let a=11            # Same as 'a=11'
  let a=a+5           # Equivalent to  let "a = a + 5"
                      # (Double quotes and spaces make it more readable.)
  echo "11 + 5 = $a"  # 16
  
  let "a &lt;&lt;= 3"       # Equivalent to  let "a = a &lt;&lt; 3"
  echo "\"\$a\" (=16) left-shifted 3 places = $a"
                      # 128
  
  let "a /= 4"        # Equivalent to  let "a = a / 4"
  echo "128 / 4 = $a" # 32
  
  let "a -= 5"        # Equivalent to  let "a = a - 5"
  echo "32 - 5 = $a"  # 27
  
  let "a *=  10"      # Equivalent to  let "a = a * 10"
  echo "27 * 10 = $a" # 270
  
  let "a %= 8"        # Equivalent to  let "a = a % 8"
  echo "270 modulo 8 = $a  (270 / 8 = 33, remainder $a)"
                      # 6
  
  
  # Does "let" permit C-style operators?
  # Yes, just as the (( ... )) double-parentheses construct does.
  
  let a++             # C-style (post) increment.
  echo "6++ = $a"     # 6++ = 7
  let a--             # C-style decrement.
  echo "7-- = $a"     # 7-- = 6
  # Of course, ++a, etc., also allowed . . .
  echo
  
  
  # Trinary operator.
  
  # Note that $a is 6, see above.
  let "t = a&lt;7?7:11"   # True
  echo $t  # 7
  
  let a++
  let "t = a&lt;7?7:11"   # False
  echo $t  #     11
  
  exit</pre></font></td></tr></tbody></table></div><p><a name="EXITVALANOMALY02"></a></p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>The <i class="FIRSTTERM">let</i> command can,
                        in certain contexts, return a surprising <a href="#EXITSTATUSREF">exit status</a>.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Evgeniy Ivanov points out:
  
  var=0
  echo $?     # 0
              # As expected.
  
  let var++
  echo $?     # 1
              # The command was successful, so why isn't $?=0 ???
              # Anomaly!
  
  let var++
  echo $?     # 0
              # As expected.
  
  
  # Likewise . . .
  
  let var=0
  echo $?     # 1
              # The command was successful, so why isn't $?=0 ???
  
  #  However, as Jeff Gorak points out,
  #+ this is part of the design spec for 'let' . . .
  # "If the last ARG evaluates to 0, let returns 1;
  #  let returns 0 otherwise." ['help let']</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div></dd><dt><a name="EVALREF"></a><b class="COMMAND">eval</b></dt><dd><p><tt class="USERINPUT"><b>eval arg1 [arg2] ... [argN]</b></tt></p><p>Combines the arguments in an expression or list of
                expressions and <tt class="REPLACEABLE"><i>evaluates</i></tt> them.
                Any variables within the expression are expanded. The
          net result is to <b class="COMMAND">convert a string into a
                command</b>.</p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">eval</b> command can be used for
          code generation from the command-line or within a script.
          </p></td></tr></tbody></table></div><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>command_string="ps ax"</b></tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>process="ps ax"</b></tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>eval "$command_string" | grep "$process"</b></tt>
  <tt class="COMPUTEROUTPUT">26973 pts/3    R+     0:00 grep --color ps ax
   26974 pts/3    R+     0:00 ps ax</tt>
          </pre></font></td></tr></tbody></table>
          </p><p><a name="EVALFORCED"></a></p><p>Each invocation of <i class="FIRSTTERM">eval</i> forces
          a re-<em>evaluation</em> of its arguments.
    <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">a='$b'
  b='$c'
  c=d
  
  echo $a             # $b
                      # First level.
  eval echo $a        # $c
                      # Second level.
  eval eval echo $a   # d
                      # Third level.
  
  # Thank you, E. Choroba.</pre></font></td></tr></tbody></table></p><p><a name="EVALEFF"></a></p><div class="EXAMPLE"><a name="EX43"></a><p><b>Example 15-11. Showing the effect of <i class="FIRSTTERM">eval</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Exercising "eval" ...
  
  y=`eval ls -l`  #  Similar to y=`ls -l`
  echo $y         #+ but linefeeds removed because "echoed" variable is unquoted.
  echo
  echo "$y"       #  Linefeeds preserved when variable is quoted.
  
  echo; echo
  
  y=`eval df`     #  Similar to y=`df`
  echo $y         #+ but linefeeds removed.
  
  #  When LF's not preserved, it may make it easier to parse output,
  #+ using utilities such as "awk".
  
  echo
  echo "==========================================================="
  echo
  
  eval "`seq 3 | sed -e 's/.*/echo var&amp;=ABCDEFGHIJ/'`"
  # var1=ABCDEFGHIJ
  # var2=ABCDEFGHIJ
  # var3=ABCDEFGHIJ
  
  echo
  echo "==========================================================="
  echo
  
  
  # Now, showing how to do something useful with "eval" . . .
  # (Thank you, E. Choroba!)
  
  version=3.4     #  Can we split the version into major and minor
                  #+ part in one command?
  echo "version = $version"
  eval major=${version/./;minor=}     #  Replaces '.' in version by ';minor='
                                      #  The substitution yields '3; minor=4'
                                      #+ so eval does minor=4, major=3
  echo Major: $major, minor: $minor   #  Major: 3, minor: 4</pre></font></td></tr></tbody></table></div><p><a name="ARRCHOICE0"></a></p><div class="EXAMPLE"><a name="ARRCHOICE"></a><p><b>Example 15-12. Using <i class="FIRSTTERM">eval</i> to select
                        among variables</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # arr-choice.sh
  
  #  Passing arguments to a function to select
  #+ one particular variable out of a group.
  
  arr0=( 10 11 12 13 14 15 )
  arr1=( 20 21 22 23 24 25 )
  arr2=( 30 31 32 33 34 35 )
  #       0  1  2  3  4  5      Element number (zero-indexed)
  
  
  choose_array ()
  {
    eval array_member=\${arr${array_number}[element_number]}
    #                 ^       ^^^^^^^^^^^^
    #  Using eval to construct the name of a variable,
    #+ in this particular case, an array name.
  
    echo "Element $element_number of array $array_number is $array_member"
  } #  Function can be rewritten to take parameters.
  
  array_number=0    # First array.
  element_number=3
  choose_array      # 13
  
  array_number=2    # Third array.
  element_number=4
  choose_array      # 34
  
  array_number=3    # Null array (arr3 not allocated).
  element_number=4
  choose_array      # (null)
  
  # Thank you, Antonio Macchi, for pointing this out.</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="ECHOPARAMS"></a><p><b>Example 15-13. <i class="FIRSTTERM">Echoing</i> the
            <i class="FIRSTTERM">command-line parameters</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # echo-params.sh
  
  # Call this script with a few command-line parameters.
  # For example:
  #     sh echo-params.sh first second third fourth fifth
  
  params=$#              # Number of command-line parameters.
  param=1                # Start at first command-line param.
  
  while [ "$param" -le "$params" ]
  do
    echo -n "Command-line parameter "
    echo -n \$$param     #  Gives only the *name* of variable.
  #         ^^^          #  $1, $2, $3, etc.
                         #  Why?
                         #  \$ escapes the first "$"
                         #+ so it echoes literally,
                         #+ and $param dereferences "$param" . . .
                         #+ . . . as expected.
    echo -n " = "
    eval echo \$$param   #  Gives the *value* of variable.
  # ^^^^      ^^^        #  The "eval" forces the *evaluation*
                         #+ of \$$
                         #+ as an indirect variable reference.
  
  (( param ++ ))         # On to the next.
  done
  
  exit $?
  
  # =================================================
  
  $ sh echo-params.sh first second third fourth fifth
  Command-line parameter $1 = first
  Command-line parameter $2 = second
  Command-line parameter $3 = third
  Command-line parameter $4 = fourth
  Command-line parameter $5 = fifth</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="EX44"></a><p><b>Example 15-14. Forcing a log-off</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Killing ppp to force a log-off.
  # For dialup connection, of course.
  
  # Script should be run as root user.
  
  SERPORT=ttyS3
  #  Depending on the hardware and even the kernel version,
  #+ the modem port on your machine may be different --
  #+ /dev/ttyS1 or /dev/ttyS2.
  
  
  killppp="eval kill -9 `ps ax | awk '/ppp/ { print $1 }'`"
  #                     -------- process ID of ppp -------  
  
  $killppp                     # This variable is now a command.
  
  
  # The following operations must be done as root user.
  
  chmod 666 /dev/$SERPORT      # Restore r+w permissions, or else what?
  #  Since doing a SIGKILL on ppp changed the permissions on the serial port,
  #+ we restore permissions to previous state.
  
  rm /var/lock/LCK..$SERPORT   # Remove the serial port lock file. Why?
  
  exit $?
  
  # Exercises:
  # ---------
  # 1) Have script check whether root user is invoking it.
  # 2) Do a check on whether the process to be killed
  #+   is actually running before attempting to kill it.   
  # 3) Write an alternate version of this script based on 'fuser':
  #+      if [ fuser -s /dev/modem ]; then . . .</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="ROT14"></a><p><b>Example 15-15. A version of <i class="FIRSTTERM">rot13</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # A version of "rot13" using 'eval'.
  # Compare to "rot13.sh" example.
  
  setvar_rot_13()              # "rot13" scrambling
  {
    local varname=$1 varvalue=$2
    eval $varname='$(echo "$varvalue" | tr a-z n-za-m)'
  }
  
  
  setvar_rot_13 var "foobar"   # Run "foobar" through rot13.
  echo $var                    # sbbone
  
  setvar_rot_13 var "$var"     # Run "sbbone" through rot13.
                               # Back to original variable.
  echo $var                    # foobar
  
  # This example by Stephane Chazelas.
  # Modified by document author.
  
  exit 0</pre></font></td></tr></tbody></table></div><p>Here is another example of using
                <i class="FIRSTTERM">eval</i> to
                <em>evaluate</em> a complex expression,
                this one from an earlier version of YongYe's <a href="https://github.com/yongye/shell/blob/master/Tetris_Game.sh" target="_top">Tetris
                game script</a>.</p><p>           <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">eval ${1}+=\"${x} ${y} \"</pre></font></td></tr></tbody></table>
             </p><p><a href="#SAMORSE">Example A-53</a> uses
          <i class="FIRSTTERM">eval</i> to convert <a href="#ARRAYREF">array</a> elements into a command
                list.</p><p>The <i class="FIRSTTERM">eval</i> command occurs
          in the older version of <a href="#IVRREF">indirect
          referencing</a>.
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">eval var=\$$var</pre></font></td></tr></tbody></table> 
          </p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>The <i class="FIRSTTERM">eval</i> command can
                  be used to <a href="#BRACEEXPREF3">parameterize
                  <i class="FIRSTTERM">brace expansion</i></a>.</p></td></tr></tbody></table></div><p><a name="EVALRISK"></a></p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">eval</b> command can be
          risky, and normally should be avoided when there
          exists a reasonable alternative. An <tt class="USERINPUT"><b>eval
          $COMMANDS</b></tt> executes the contents of
          <tt class="REPLACEABLE"><i>COMMANDS</i></tt>, which may
          contain such unpleasant surprises as <b class="COMMAND">rm -rf
          *</b>. Running an <b class="COMMAND">eval</b> on
          unfamiliar code written by persons unknown is living
          dangerously.</p></td></tr></tbody></table></div></dd><dt><a name="SETREF"></a><b class="COMMAND">set</b></dt><dd><p>The <b class="COMMAND">set</b> command changes
          the value of internal script variables/options. One use for
          this is to toggle <a href="#OPTIONSREF">option
          flags</a> which help determine the behavior of the
          script. Another application for it is to reset the <a href="#POSPARAMREF">positional parameters</a> that
          a script sees as the result of a command (<tt class="USERINPUT"><b>set
          `command`</b></tt>). The script can then parse the
          <a href="#FIELDREF">fields</a> of the command
          output.</p><div class="EXAMPLE"><a name="EX34"></a><p><b>Example 15-16. Using <i class="FIRSTTERM">set</i> with positional
            parameters</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # ex34.sh
  # Script "set-test"
  
  # Invoke this script with three command-line parameters,
  # for example, "sh ex34.sh one two three".
  
  echo
  echo "Positional parameters before  set \`uname -a\` :"
  echo "Command-line argument #1 = $1"
  echo "Command-line argument #2 = $2"
  echo "Command-line argument #3 = $3"
  
  
  set `uname -a` # Sets the positional parameters to the output
                 # of the command `uname -a`
  
  echo
  echo +++++
  echo $_        # +++++
  # Flags set in script.
  echo $-        # hB
  #                Anomalous behavior?
  echo
  
  echo "Positional parameters after  set \`uname -a\` :"
  # $1, $2, $3, etc. reinitialized to result of `uname -a`
  echo "Field #1 of 'uname -a' = $1"
  echo "Field #2 of 'uname -a' = $2"
  echo "Field #3 of 'uname -a' = $3"
  echo \#\#\#
  echo $_        # ###
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div><p>More fun with positional parameters.</p><div class="EXAMPLE"><a name="REVPOSPARAMS"></a><p><b>Example 15-17. Reversing the positional parameters</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # revposparams.sh: Reverse positional parameters.
  # Script by Dan Jacobson, with stylistic revisions by document author.
  
  
  set a\ b c d\ e;
  #     ^      ^     Spaces escaped 
  #       ^ ^        Spaces not escaped
  OIFS=$IFS; IFS=:;
  #              ^   Saving old IFS and setting new one.
  
  echo
  
  until [ $# -eq 0 ]
  do          #      Step through positional parameters.
    echo "### k0 = "$k""     # Before
    k=$1:$k;  #      Append each pos param to loop variable.
  #     ^
    echo "### k = "$k""      # After
    echo
    shift;
  done
  
  set $k  #  Set new positional parameters.
  echo -
  echo $# #  Count of positional parameters.
  echo -
  echo
  
  for i   #  Omitting the "in list" sets the variable -- i --
          #+ to the positional parameters.
  do
    echo $i  # Display new positional parameters.
  done
  
  IFS=$OIFS  # Restore IFS.
  
  #  Question:
  #  Is it necessary to set an new IFS, internal field separator,
  #+ in order for this script to work properly?
  #  What happens if you don't? Try it.
  #  And, why use the new IFS -- a colon -- in line 17,
  #+ to append to the loop variable?
  #  What is the purpose of this?
  
  exit 0
  
  $ ./revposparams.sh
  
  ### k0 = 
  ### k = a b
  
  ### k0 = a b
  ### k = c a b
  
  ### k0 = c a b
  ### k = d e c a b
  
  -
  3
  -
  
  d e
  c
  a b</pre></font></td></tr></tbody></table></div><p>Invoking <b class="COMMAND">set</b> without any options or
          arguments simply lists all the <a href="#ENVREF">environmental</a> and other variables
          that have been initialized.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>set</b></tt>
  <tt class="COMPUTEROUTPUT">AUTHORCOPY=/home/bozo/posts
   BASH=/bin/bash
   BASH_VERSION=$'2.05.8(1)-release'
   ...
   XAUTHORITY=/home/bozo/.Xauthority
   _=/etc/bashrc
   variable22=abc
   variable23=xzy</tt>
          </pre></font></td></tr></tbody></table>
              </p><p>Using <b class="COMMAND">set</b> with the <tt class="OPTION">--</tt>
          option explicitly assigns the contents of a variable to
          the positional parameters. If no variable follows the
          <tt class="OPTION">--</tt> it <i class="FIRSTTERM">unsets</i>
          the positional parameters.</p><div class="EXAMPLE"><a name="SETPOS"></a><p><b>Example 15-18. Reassigning the positional parameters</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  variable="one two three four five"
  
  set -- $variable
  # Sets positional parameters to the contents of "$variable".
  
  first_param=$1
  second_param=$2
  shift; shift        # Shift past first two positional params.
  # shift 2             also works.
  remaining_params="$*"
  
  echo
  echo "first parameter = $first_param"             # one
  echo "second parameter = $second_param"           # two
  echo "remaining parameters = $remaining_params"   # three four five
  
  echo; echo
  
  # Again.
  set -- $variable
  first_param=$1
  second_param=$2
  echo "first parameter = $first_param"             # one
  echo "second parameter = $second_param"           # two
  
  # ======================================================
  
  set --
  # Unsets positional parameters if no variable specified.
  
  first_param=$1
  second_param=$2
  echo "first parameter = $first_param"             # (null value)
  echo "second parameter = $second_param"           # (null value)
  
  exit 0</pre></font></td></tr></tbody></table></div><p>See also <a href="#EX22A">Example 11-2</a> and <a href="#EX33A">Example 16-56</a>.</p></dd><dt><a name="UNSETREF"></a><b class="COMMAND">unset</b></dt><dd><p>The <b class="COMMAND">unset</b> command deletes a
          shell variable, effectively setting it to
          <i class="FIRSTTERM">null</i>. Note that this command does
          not affect positional parameters.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>unset PATH</b></tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $PATH</b></tt>
  <tt class="COMPUTEROUTPUT">
  </tt>
  <tt class="PROMPT">bash$ </tt></pre></font></td></tr></tbody></table>
        </p><div class="EXAMPLE"><a name="UNS"></a><p><b>Example 15-19. <span class="QUOTE">"Unsetting"</span> a variable</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # unset.sh: Unsetting a variable.
  
  variable=hello                       #  Initialized.
  echo "variable = $variable"
  
  unset variable                       #  Unset.
                                       #  In this particular context,
                                       #+ same effect as:   variable=
  echo "(unset) variable = $variable"  #  $variable is null.
  
  if [ -z "$variable" ]                #  Try a string-length test.
  then
    echo "\$variable has zero length."
  fi
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>In most contexts, an <i class="FIRSTTERM">undeclared</i>
                variable and one that has been <i class="FIRSTTERM">unset</i>
          are equivalent. However, the <a href="#UNDDR">              ${parameter:-default}</a> parameter substitution
                construct can distinguish between the two.</p></td></tr></tbody></table></div></dd><dt><a name="EXPORTREF"></a><b class="COMMAND">export</b></dt><dd><p><a name="EXPORTREF2"></a></p><p>The <b class="COMMAND">export</b>
  
          <a name="AEN9199" href="#FTN.AEN9199"><span class="footnote">[61]</span></a>
      
          command makes available variables to all child processes
          of the running script or shell. One important use
          of the <b class="COMMAND">export</b> command is in <a href="#FILESREF1">startup files</a>, to initialize
          and make accessible <a href="#ENVREF">environmental
          variables</a> to subsequent user processes.</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>Unfortunately, <a href="#PARCHILDPROBREF">	     there is no way to export variables back to the parent
         process</a>, to the process that called or invoked the
         script or shell.</p></td></tr></tbody></table></div><p><a name="EXPORTAWK"></a></p><div class="EXAMPLE"><a name="COLTOTALER3"></a><p><b>Example 15-20. Using <i class="FIRSTTERM">export</i> to pass a variable to an
          embedded <i class="FIRSTTERM">awk</i> script</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  #  Yet another version of the "column totaler" script (col-totaler.sh)
  #+ that adds up a specified column (of numbers) in the target file.
  #  This uses the environment to pass a script variable to 'awk' . . .
  #+ and places the awk script in a variable.
  
  
  ARGS=2
  E_WRONGARGS=85
  
  if [ $# -ne "$ARGS" ] # Check for proper number of command-line args.
  then
     echo "Usage: `basename $0` filename column-number"
     exit $E_WRONGARGS
  fi
  
  filename=$1
  column_number=$2
  
  #===== Same as original script, up to this point =====#
  
  export column_number
  # Export column number to environment, so it's available for retrieval.
  
  
  # -----------------------------------------------
  awkscript='{ total += $ENVIRON["column_number"] }
  END { print total }'
  # Yes, a variable can hold an awk script.
  # -----------------------------------------------
  
  # Now, run the awk script.
  awk "$awkscript" "$filename"
  
  # Thanks, Stephane Chazelas.
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>It is possible to initialize and export
        variables in the same operation, as in <b class="COMMAND">export
        var1=xxx</b>.</p><p>However, as Greg Keraunen points out, in certain
        situations this may have a different effect than
        setting a variable, then exporting it.</p><p>	        <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>export var=(a b); echo ${var[0]}</b></tt>
  <tt class="COMPUTEROUTPUT">(a b)</tt>
  
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>var=(a b); export var; echo ${var[0]}</b></tt>
  <tt class="COMPUTEROUTPUT">a</tt>
          </pre></font></td></tr></tbody></table>
        </p></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>A variable to be exported may require special
                  treatment.  See <a href="#BASHPROF">Example M-2</a>.</p></td></tr></tbody></table></div></dd><dt><a name="DECLARE2REF"></a><b class="COMMAND">declare</b>, <b class="COMMAND">typeset</b></dt><dd><p>The <a href="#DECLAREREF">declare</a> and
          <a href="#DECLAREREF">typeset</a> commands specify
          and/or restrict properties of variables.</p></dd><dt><a name="READONLYREF"></a><b class="COMMAND">readonly</b></dt><dd><p>Same as <a href="#DECLAREREF">declare -r</a>,
          sets a variable as read-only, or, in effect, as a
          constant. Attempts to change the variable fail with
          an error message. This is the shell analog of the
          <i class="FIRSTTERM">C</i> language <b class="COMMAND">const</b>
          type qualifier.</p></dd><dt><a name="GETOPTSX"></a><b class="COMMAND">getopts</b></dt><dd><p>This powerful tool parses command-line arguments passed
          to the script. This is the Bash analog of the <a href="#GETOPTY">getopt</a> external command and the
          <i class="FIRSTTERM">getopt</i> library function familiar to
          <i class="FIRSTTERM">C</i> programmers. It permits passing
          and concatenating multiple options
  
          <a name="AEN9289" href="#FTN.AEN9289"><span class="footnote">[62]</span></a>
  
          and associated arguments to a script (for
          example <tt class="USERINPUT"><b>scriptname -abc -e
          /usr/local</b></tt>).</p><p><a name="GETOPTSOPT"></a></p><p>The <b class="COMMAND">getopts</b> construct uses two implicit
          variables. <tt class="VARNAME">$OPTIND</tt> is the argument
          pointer (<i class="WORDASWORD">OPTion INDex</i>)
          and <tt class="VARNAME">$OPTARG</tt> (<i class="WORDASWORD">OPTion
          ARGument</i>) the (optional) argument attached
          to an option. A colon following the option name in the
          declaration tags that option as having an associated
          argument.</p><p>A <b class="COMMAND">getopts</b> construct usually comes
          packaged in a <a href="#WHILELOOPREF">while
          loop</a>, which processes the options and
          arguments one at a time, then increments the implicit
          <tt class="VARNAME">$OPTIND</tt> variable to point to the
          next.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>		</p><p></p><ol type="1"><li><p>The arguments passed from the command-line to
            the script must be preceded by a
            dash (<tt class="OPTION">-</tt>). It is the
            prefixed <tt class="OPTION">-</tt> that lets
            <b class="COMMAND">getopts</b> recognize command-line
            arguments as <i class="FIRSTTERM">options</i>.
            In fact, <b class="COMMAND">getopts</b> will not process
            arguments without the prefixed <tt class="OPTION">-</tt>,
            and will terminate option processing at the first
            argument encountered lacking them.</p></li><li><p>The <b class="COMMAND">getopts</b> template
            differs slightly from the standard <a href="#WHILELOOPREF">while loop</a>, in that
            it lacks condition brackets.</p></li><li><p>The <b class="COMMAND">getopts</b> construct is a highly
           functional replacement for the traditional
           <a href="#GETOPTY">getopt</a> external
           command.</p></li></ol>
          <p></p></td></tr></tbody></table></div><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">while getopts ":abcde:fg" Option
  # Initial declaration.
  # a, b, c, d, e, f, and g are the options (flags) expected.
  # The : after option 'e' shows it will have an argument passed with it.
  do
    case $Option in
      a ) # Do something with variable 'a'.
      b ) # Do something with variable 'b'.
      ...
      e)  # Do something with 'e', and also with $OPTARG,
          # which is the associated argument passed with option 'e'.
      ...
      g ) # Do something with variable 'g'.
    esac
  done
  shift $(($OPTIND - 1))
  # Move argument pointer to next.
  
  # All this is not nearly as complicated as it looks &lt;grin&gt;.</pre></font></td></tr></tbody></table></p><div class="EXAMPLE"><a name="EX33"></a><p><b>Example 15-21. Using <i class="FIRSTTERM">getopts</i> to read the
            options/arguments passed to a script</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # ex33.sh: Exercising getopts and OPTIND
  #          Script modified 10/09/03 at the suggestion of Bill Gradwohl.
  
  
  # Here we observe how 'getopts' processes command-line arguments to script.
  # The arguments are parsed as "options" (flags) and associated arguments.
  
  # Try invoking this script with:
  #   'scriptname -mn'
  #   'scriptname -oq qOption' (qOption can be some arbitrary string.)
  #   'scriptname -qXXX -r'
  #
  #   'scriptname -qr'
  #+      - Unexpected result, takes "r" as the argument to option "q"
  #   'scriptname -q -r' 
  #+      - Unexpected result, same as above
  #   'scriptname -mnop -mnop'  - Unexpected result
  #   (OPTIND is unreliable at stating where an option came from.)
  #
  #  If an option expects an argument ("flag:"), then it will grab
  #+ whatever is next on the command-line.
  
  NO_ARGS=0 
  E_OPTERROR=85
  
  if [ $# -eq "$NO_ARGS" ]    # Script invoked with no command-line args?
  then
    echo "Usage: `basename $0` options (-mnopqrs)"
    exit $E_OPTERROR          # Exit and explain usage.
                              # Usage: scriptname -options
                              # Note: dash (-) necessary
  fi  
  
  
  while getopts ":mnopq:rs" Option
  do
    case $Option in
      m     ) echo "Scenario #1: option -m-   [OPTIND=${OPTIND}]";;
      n | o ) echo "Scenario #2: option -$Option-   [OPTIND=${OPTIND}]";;
      p     ) echo "Scenario #3: option -p-   [OPTIND=${OPTIND}]";;
      q     ) echo "Scenario #4: option -q-\
                    with argument \"$OPTARG\"   [OPTIND=${OPTIND}]";;
      #  Note that option 'q' must have an associated argument,
      #+ otherwise it falls through to the default.
      r | s ) echo "Scenario #5: option -$Option-";;
      *     ) echo "Unimplemented option chosen.";;   # Default.
    esac
  done
  
  shift $(($OPTIND - 1))
  #  Decrements the argument pointer so it points to next argument.
  #  $1 now references the first non-option item supplied on the command-line
  #+ if one exists.
  
  exit $?
  
  #   As Bill Gradwohl states,
  #  "The getopts mechanism allows one to specify:  scriptname -mnop -mnop
  #+  but there is no reliable way to differentiate what came
  #+ from where by using OPTIND."
  #  There are, however, workarounds.</pre></font></td></tr></tbody></table></div></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="INTSCRBEH1"></a>Script Behavior</b></p><dl><dt><a name="SOURCEREF"></a><b class="COMMAND">source</b>, <span class="TOKEN">.</span> (<a href="#DOTREF">dot</a> command)</dt><dd><p>This command, when invoked from the command-line,
          executes a script. Within a script, a
          <tt class="USERINPUT"><b>source file-name</b></tt>
          loads the file <tt class="FILENAME">file-name</tt>.
          <i class="FIRSTTERM">Sourcing</i> a file (dot-command)
          <i class="FIRSTTERM">imports</i>
         code into the script, appending to the script (same effect
         as the <tt class="USERINPUT"><b>#include</b></tt> directive in a
         <i class="FIRSTTERM">C</i> program). The net result is the
         same as if the <span class="QUOTE">"sourced"</span> lines of code were
         physically present in the body of the script. This is useful
         in situations when multiple scripts use a common data file
         or function library.</p><div class="EXAMPLE"><a name="EX38"></a><p><b>Example 15-22. <span class="QUOTE">"Including"</span> a data file</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  #  Note that this example must be invoked with bash, i.e., bash ex38.sh
  #+ not  sh ex38.sh !
  
  . data-file    # Load a data file.
  # Same effect as "source data-file", but more portable.
  
  #  The file "data-file" must be present in current working directory,
  #+ since it is referred to by its basename.
  
  # Now, let's reference some data from that file.
  
  echo "variable1 (from data-file) = $variable1"
  echo "variable3 (from data-file) = $variable3"
  
  let "sum = $variable2 + $variable4"
  echo "Sum of variable2 + variable4 (from data-file) = $sum"
  echo "message1 (from data-file) is \"$message1\""
  #                                  Escaped quotes
  echo "message2 (from data-file) is \"$message2\""
  
  print_message This is the message-print function in the data-file.
  
  
  exit $?</pre></font></td></tr></tbody></table><p>File <tt class="FILENAME">data-file</tt> for <a href="#EX38">Example 15-22</a>, above.  Must be present in same
      directory.</p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># This is a data file loaded by a script.
  # Files of this type may contain variables, functions, etc.
  # It loads with a 'source' or '.' command from a shell script.
  
  # Let's initialize some variables.
  
  variable1=23
  variable2=474
  variable3=5
  variable4=97
  
  message1="Greetings from *** line $LINENO *** of the data file!"
  message2="Enough for now. Goodbye."
  
  print_message ()
  {   # Echoes any message passed to it.
  
    if [ -z "$1" ]
    then
      return 1 # Error, if argument missing.
    fi
  
    echo
  
    until [ -z "$1" ]
    do             # Step through arguments passed to function.
      echo -n "$1" # Echo args one at a time, suppressing line feeds.
      echo -n " "  # Insert spaces between words.
      shift        # Next one.
    done  
  
    echo
  
    return 0
  }</pre></font></td></tr></tbody></table></div><p>If the <i class="FIRSTTERM">sourced</i> file is itself
           an executable script, then it will run, then return
           control to the script that called it. A
           <i class="FIRSTTERM">sourced</i> executable script may use a
          <a href="#RETURNREF">return</a> for this
          purpose.</p><p><a name="SOURCEPARAMS"></a></p><p>	      Arguments may be (optionally) passed to the
          <i class="FIRSTTERM">sourced</i> file as <a href="#POSPARAMREF1">positional parameters</a>.
           <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">source $filename $arg1 arg2</pre></font></td></tr></tbody></table>
        </p><p>It is even possible for a script to
        <i class="FIRSTTERM">source</i> itself, though this does not
        seem to have any practical applications.</p><div class="EXAMPLE"><a name="SELFSOURCE"></a><p><b>Example 15-23. A (useless) script that sources itself</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # self-source.sh: a script sourcing itself "recursively."
  # From "Stupid Script Tricks," Volume II.
  
  MAXPASSCNT=100    # Maximum number of execution passes.
  
  echo -n  "$pass_count  "
  #  At first execution pass, this just echoes two blank spaces,
  #+ since $pass_count still uninitialized.
  
  let "pass_count += 1"
  #  Assumes the uninitialized variable $pass_count
  #+ can be incremented the first time around.
  #  This works with Bash and pdksh, but
  #+ it relies on non-portable (and possibly dangerous) behavior.
  #  Better would be to initialize $pass_count to 0 before incrementing.
  
  while [ "$pass_count" -le $MAXPASSCNT ]
  do
    . $0   # Script "sources" itself, rather than calling itself.
           # ./$0 (which would be true recursion) doesn't work here. Why?
  done  
  
  #  What occurs here is not actually recursion,
  #+ since the script effectively "expands" itself, i.e.,
  #+ generates a new section of code
  #+ with each pass through the 'while' loop',
  #  with each 'source' in line 20.
  #
  #  Of course, the script interprets each newly 'sourced' "#!" line
  #+ as a comment, and not as the start of a new script.
  
  echo
  
  exit 0   # The net effect is counting from 1 to 100.
           # Very impressive.
  
  # Exercise:
  # --------
  # Write a script that uses this trick to actually do something useful.</pre></font></td></tr></tbody></table></div></dd><dt><a name="EXITREF"></a><b class="COMMAND">exit</b></dt><dd><p>Unconditionally terminates a script.
          <a name="AEN9393" href="#FTN.AEN9393"><span class="footnote">[63]</span></a>
            The <b class="COMMAND">exit</b> command may optionally take an
      integer argument, which is returned to the shell as
      the <a href="#EXITSTATUSREF">exit status</a>
      of the script. It is good practice to end all but the
      simplest scripts with an <tt class="USERINPUT"><b>exit 0</b></tt>,
      indicating a successful run.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>If a script terminates with an <b class="COMMAND">exit</b>
          lacking an argument, the exit status of the script is the exit
          status of the last command executed in the script, not counting
          the <b class="COMMAND">exit</b>. This is equivalent to an
          <b class="COMMAND">exit $?</b>.</p></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>An <b class="COMMAND">exit</b> command may also be used to
          terminate a <a href="#SUBSHELLSREF">subshell</a>.</p></td></tr></tbody></table></div></dd><dt><a name="EXECREF"></a><b class="COMMAND">exec</b></dt><dd><p>	      This shell builtin replaces the current process with
          a specified command. Normally, when the shell encounters
          a command, it <a href="#FORKREF">forks off</a> a
          child process to actually execute the command.  Using the
          <b class="COMMAND">exec</b> builtin, the shell does not fork,
          and the command <i class="FIRSTTERM">exec</i>'ed replaces
          the shell.  When used in a script, therefore, it forces an
          exit from the script when the <b class="COMMAND">exec</b>'ed
          command terminates.
      <a name="AEN9425" href="#FTN.AEN9425"><span class="footnote">[64]</span></a>
        </p><div class="EXAMPLE"><a name="EX54"></a><p><b>Example 15-24. Effects of <i class="FIRSTTERM">exec</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  exec echo "Exiting \"$0\" at line $LINENO."   # Exit from script here.
  # $LINENO is an internal Bash variable set to the line number it's on.
  
  # ----------------------------------
  # The following lines never execute.
  
  echo "This echo fails to echo."
  
  exit 99                       #  This script will not exit here.
                                #  Check exit value after script terminates
                                #+ with an 'echo $?'.
                                #  It will *not* be 99.</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="SELFEXEC"></a><p><b>Example 15-25. A script that <i class="FIRSTTERM">exec's</i> itself</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # self-exec.sh
  
  # Note: Set permissions on this script to 555 or 755,
  #       then call it with ./self-exec.sh or sh ./self-exec.sh.
  
  echo
  
  echo "This line appears ONCE in the script, yet it keeps echoing."
  echo "The PID of this instance of the script is still $$."
  #     Demonstrates that a subshell is not forked off.
  
  echo "==================== Hit Ctl-C to exit ===================="
  
  sleep 1
  
  exec $0   #  Spawns another instance of this same script
            #+ that replaces the previous one.
  
  echo "This line will never echo!"  # Why not?
  
  exit 99                            # Will not exit here!
                                     # Exit code will not be 99!</pre></font></td></tr></tbody></table></div><p>An <b class="COMMAND">exec</b> also serves to <a href="#USINGEXECREF">reassign
          file descriptors</a>.	For example, <tt class="USERINPUT"><b>exec
          &lt;zzz-file</b></tt> replaces <tt class="FILENAME">stdin</tt>
          with the file <tt class="FILENAME">zzz-file</tt>.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <tt class="OPTION">-exec</tt> option to
          <a href="#FINDREF">find</a> is
          <tt class="REPLACEABLE"><i>not</i></tt> the same as the
          <b class="COMMAND">exec</b> shell builtin.</p></td></tr></tbody></table></div></dd><dt><a name="SHOPTREF"></a><b class="COMMAND">shopt</b></dt><dd><p>This command permits changing <i class="FIRSTTERM">shell
          options</i> on the fly (see <a href="#AL">Example 25-1</a>
          and <a href="#UNAL">Example 25-2</a>).  It often appears in the Bash
          <a href="#FILESREF1">startup files</a>, but also has
          its uses in scripts. Needs <a href="#BASH2REF">version
          2</a> or later of Bash.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">shopt -s cdspell
  # Allows minor misspelling of directory names with 'cd'
  # Option -s sets, -u unsets.
  
  cd /hpme  # Oops! Mistyped '/home'.
  pwd       # /home
            # The shell corrected the misspelling.</pre></font></td></tr></tbody></table></p></dd><dt><b class="COMMAND">caller</b><a name="CALLERREF"></a></dt><dd><p>Putting a <b class="COMMAND">caller</b> command
           inside a <a href="#FUNCTIONREF">function</a>
           echoes to <tt class="FILENAME">stdout</tt> information about
           the <i class="FIRSTTERM">caller</i> of that function.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  function1 ()
  {
    # Inside function1 ().
    caller 0   # Tell me about it.
  }
  
  function1    # Line 9 of script.
  
  # 9 main test.sh
  # ^                 Line number that the function was called from.
  #   ^^^^            Invoked from "main" part of script.
  #        ^^^^^^^    Name of calling script.
  
  caller 0     # Has no effect because it's not inside a function.</pre></font></td></tr></tbody></table></p><p>A <b class="COMMAND">caller</b> command can also return
          <i class="FIRSTTERM">caller</i> information from a script <a href="#SOURCEREF">sourced</a> within another
          script. Analogous to a function, this is a <span class="QUOTE">"subroutine
          call."</span></p><p>You may find this command useful in debugging.</p></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="INTCOMMAND1"></a>Commands</b></p><dl><dt><a name="TRUEREF"></a><b class="COMMAND">true</b></dt><dd><p>A command that returns a successful
        (<span class="RETURNVALUE">zero</span>) <a href="#EXITSTATUSREF">exit status</a>, but does
        nothing else.
      </p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>true</b></tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $?</b></tt>
  <tt class="COMPUTEROUTPUT">0</tt>
          </pre></font></td></tr></tbody></table>
        </p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Endless loop
  while true   # alias for ":"
  do
     operation-1
     operation-2
     ...
     operation-n
     # Need a way to break out of loop or script will hang.
  done</pre></font></td></tr></tbody></table></p></dd><dt><a name="FALSEREF"></a><b class="COMMAND">false</b></dt><dd><p>A command that returns an unsuccessful <a href="#EXITSTATUSREF">exit status</a>,
        but does nothing else.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>false</b></tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $?</b></tt>
  <tt class="COMPUTEROUTPUT">1</tt>
          </pre></font></td></tr></tbody></table>
        </p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Testing "false" 
  if false
  then
    echo "false evaluates \"true\""
  else
    echo "false evaluates \"false\""
  fi
  # false evaluates "false"
  
  
  # Looping while "false" (null loop)
  while false
  do
     # The following code will not execute.
     operation-1
     operation-2
     ...
     operation-n
     # Nothing happens!
  done   </pre></font></td></tr></tbody></table></p></dd><dt><a name="TYPEREF"></a><b class="COMMAND">type [cmd]</b></dt><dd><p>Similar to the <a href="#WHICHREF">which</a> external command,
        <b class="COMMAND">type cmd</b> identifies
        <span class="QUOTE">"cmd."</span> Unlike <b class="COMMAND">which</b>,
        <b class="COMMAND">type</b> is a Bash builtin. The useful
        <tt class="OPTION">-a</tt> option to <b class="COMMAND">type</b>
        identifies <tt class="REPLACEABLE"><i>keywords</i></tt>
        and <tt class="REPLACEABLE"><i>builtins</i></tt>, and also locates
        system commands with identical names.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>type '['</b></tt>
  <tt class="COMPUTEROUTPUT">[ is a shell builtin</tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>type -a '['</b></tt>
  <tt class="COMPUTEROUTPUT">[ is a shell builtin
   [ is /usr/bin/[</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>type type</b></tt>
  <tt class="COMPUTEROUTPUT">type is a shell builtin</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>The <b class="COMMAND">type</b> command can be useful
                for <a href="#DEVNULLREDIRECT">testing whether a
                certain command exists</a>.</p></dd><dt><a name="HASHCMDREF"></a><b class="COMMAND">hash [cmds]</b></dt><dd><p>Records the <i class="FIRSTTERM">path</i>
        name of specified commands -- in the shell <i class="FIRSTTERM">hash
        table</i>
  
            <a name="AEN9591" href="#FTN.AEN9591"><span class="footnote">[65]</span></a>
          
                -- so the shell or script will not need to search the
                <a href="#PATHREF">$PATH</a> on subsequent calls to those
                commands. When <b class="COMMAND">hash</b> is called with no
          arguments, it simply lists the commands that have been hashed.
          The <tt class="OPTION">-r</tt> option resets the hash table.</p></dd><dt><a name="BINDREF"></a><b class="COMMAND">bind</b></dt><dd><p>The <b class="COMMAND">bind</b> builtin displays or modifies
      <i class="FIRSTTERM">readline</i>
        <a name="AEN9621" href="#FTN.AEN9621"><span class="footnote">[66]</span></a>
      key bindings.</p></dd><dt><a name="HELPREF"></a><b class="COMMAND">help</b></dt><dd><p>Gets a short usage summary of a shell builtin. This is
        the counterpart to <a href="#WHATISREF">whatis</a>,
        but for builtins. The display of <i class="FIRSTTERM">help</i>
        information got a much-needed update in the <a href="#BASH4REF">version 4 release</a> of Bash.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>help exit</b></tt>
  <tt class="COMPUTEROUTPUT">exit: exit [n]
      Exit the shell with a status of N.  If N is omitted, the exit status
      is that of the last command executed.</tt>
          </pre></font></td></tr></tbody></table>
          </p></dd></dl></div><div class="SECT1"><hr><h1 class="SECT1"><a name="AEN9644"></a>15.1. Job Control Commands</h1><p>Certain of the following job control commands take a
      <i class="FIRSTTERM">job identifier</i> as an argument. See
      the <a href="#JOBIDTABLE">table</a> at end of the
      chapter.</p><p></p><div class="VARIABLELIST"><dl><dt><a name="JOBSREF"></a><b class="COMMAND">jobs</b></dt><dd><p>Lists the jobs running in the background, giving
            the <i class="FIRSTTERM">job number</i>.
      Not as useful as <a href="#PPSSREF">ps</a>.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>It is all too easy to confuse
      <i class="FIRSTTERM">jobs</i> and
      <i class="FIRSTTERM">processes</i>.  Certain <a href="#BUILTINREF">builtins</a>, such as
      <b class="COMMAND">kill</b>, <b class="COMMAND">disown</b>, and
      <b class="COMMAND">wait</b> accept either a job number or a
      process number as an argument. The <a href="#FGREF">fg</a>,
      <a href="#BGREF">bg</a> and <b class="COMMAND">jobs</b>
      commands accept only a job number.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>sleep 100 &amp;</b></tt>
  <tt class="COMPUTEROUTPUT">[1] 1384</tt>
  
  <tt class="PROMPT">bash $ </tt><tt class="USERINPUT"><b>jobs</b></tt>
  <tt class="COMPUTEROUTPUT">[1]+  Running                 sleep 100 &amp;</tt></pre></font></td></tr></tbody></table>
          </p><p><span class="QUOTE">"1"</span> is the job number (jobs are
      maintained by the current shell). <span class="QUOTE">"1384"</span>
      is the <a href="#PPIDREF">PID</a> or <i class="FIRSTTERM">process ID
      number</i> (processes are maintained by the system). To kill
      this job/process, either a <b class="COMMAND">kill %1</b>
      or a <b class="COMMAND">kill 1384</b> works.</p><p><em>Thanks, S.C.</em></p></td></tr></tbody></table></div></dd><dt><a name="DISOWNREF"></a><b class="COMMAND">disown</b></dt><dd><p>Remove job(s) from the shell's table of active jobs.</p></dd><dt><a name="FGREF"></a><b class="COMMAND">fg</b>, <a name="BGREF"></a><b class="COMMAND">bg</b></dt><dd><p>The <b class="COMMAND">fg</b> command switches a job
          running in the background into the foreground.  The
          <b class="COMMAND">bg</b> command restarts a suspended job, and
          runs it in the background. If no job number is specified,
          then the <b class="COMMAND">fg</b> or <b class="COMMAND">bg</b>
          command acts upon the currently running job.</p></dd><dt><a name="WAITREF"></a><b class="COMMAND">wait</b></dt><dd><p>Suspend script execution until all jobs running in
            background have terminated, or until the job number or
            process ID specified as an option terminates. Returns the <a href="#EXITSTATUSREF">exit status</a> of waited-for
            command.</p><p>You may use the <b class="COMMAND">wait</b> command
      to prevent a script from exiting before a background
      job finishes executing (this would create a dreaded
      <a href="#ZOMBIEREF">orphan process</a>).</p><div class="EXAMPLE"><a name="EX39"></a><p><b>Example 15-26. Waiting for a process to finish before proceeding</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  ROOT_UID=0   # Only users with $UID 0 have root privileges.
  E_NOTROOT=65
  E_NOPARAMS=66
  
  if [ "$UID" -ne "$ROOT_UID" ]
  then
    echo "Must be root to run this script."
    # "Run along kid, it's past your bedtime."
    exit $E_NOTROOT
  fi  
  
  if [ -z "$1" ]
  then
    echo "Usage: `basename $0` find-string"
    exit $E_NOPARAMS
  fi
  
  
  echo "Updating 'locate' database..."
  echo "This may take a while."
  updatedb /usr &amp;     # Must be run as root.
  
  wait
  # Don't run the rest of the script until 'updatedb' finished.
  # You want the the database updated before looking up the file name.
  
  locate $1
  
  #  Without the 'wait' command, in the worse case scenario,
  #+ the script would exit while 'updatedb' was still running,
  #+ leaving it as an orphan process.
  
  exit 0</pre></font></td></tr></tbody></table></div><p>Optionally, <b class="COMMAND">wait</b> can take a <i class="FIRSTTERM">job
      identifier</i> as an argument, for example,
      <tt class="REPLACEABLE"><i>wait%1</i></tt> or <tt class="REPLACEABLE"><i>wait
                  $PPID</i></tt>.
  
    <a name="AEN9753" href="#FTN.AEN9753"><span class="footnote">[67]</span></a>
      
      See the <a href="#JOBIDTABLE">job id table</a>.</p><p><a name="WAITHANG"></a></p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>Within a script, running a command in the background
      with an ampersand (&amp;) may cause the script
      to hang until <b class="KEYCAP">ENTER</b> is hit. This
      seems to occur with commands that write to
      <tt class="FILENAME">stdout</tt>. It can be a major annoyance.
        <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # test.sh		  
  
  ls -l &amp;
  echo "Done."</pre></font></td></tr></tbody></table>
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>./test.sh</b></tt>
  <tt class="COMPUTEROUTPUT">Done.
   [bozo@localhost test-scripts]$ total 1
   -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh
   _</tt>
                 </pre></font></td></tr></tbody></table>
           </p><a name="AEN9768"></a><blockquote class="BLOCKQUOTE"><p class="LITERALLAYOUT">&nbsp;&nbsp;&nbsp;&nbsp;As&nbsp;Walter&nbsp;Brameld&nbsp;IV&nbsp;explains&nbsp;it:<br>
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;As&nbsp;far&nbsp;as&nbsp;I&nbsp;can&nbsp;tell,&nbsp;such&nbsp;scripts&nbsp;don't&nbsp;actually&nbsp;hang.&nbsp;It&nbsp;just<br>
  &nbsp;&nbsp;&nbsp;&nbsp;seems&nbsp;that&nbsp;they&nbsp;do&nbsp;because&nbsp;the&nbsp;background&nbsp;command&nbsp;writes&nbsp;text&nbsp;to<br>
  &nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;console&nbsp;after&nbsp;the&nbsp;prompt.&nbsp;The&nbsp;user&nbsp;gets&nbsp;the&nbsp;impression&nbsp;that<br>
  &nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;prompt&nbsp;was&nbsp;never&nbsp;displayed.&nbsp;Here's&nbsp;the&nbsp;sequence&nbsp;of&nbsp;events:<br>
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;Script&nbsp;launches&nbsp;background&nbsp;command.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;Script&nbsp;exits.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;3.&nbsp;Shell&nbsp;displays&nbsp;the&nbsp;prompt.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;4.&nbsp;Background&nbsp;command&nbsp;continues&nbsp;running&nbsp;and&nbsp;writing&nbsp;text&nbsp;to&nbsp;the<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;5.&nbsp;Background&nbsp;command&nbsp;finishes.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;6.&nbsp;User&nbsp;doesn't&nbsp;see&nbsp;a&nbsp;prompt&nbsp;at&nbsp;the&nbsp;bottom&nbsp;of&nbsp;the&nbsp;output,&nbsp;thinks&nbsp;script<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;hanging.<br>
    </p></blockquote><p>Placing a <b class="COMMAND">wait</b> after the background
                  command seems to remedy this.
        <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # test.sh		  
  
  ls -l &amp;
  echo "Done."
  wait</pre></font></td></tr></tbody></table>
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>./test.sh</b></tt>
  <tt class="COMPUTEROUTPUT">Done.
   [bozo@localhost test-scripts]$ total 1
   -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh</tt>
                 </pre></font></td></tr></tbody></table>
            <a href="#IOREDIRREF">Redirecting</a> the
                  output of the command to a file or even to
      <tt class="FILENAME">/dev/null</tt> also takes care of this
      problem.
                </p></td></tr></tbody></table></div></dd><dt><a name="SUSPENDREF"></a><b class="COMMAND">suspend</b></dt><dd><p>This has a similar effect to
      <b class="KEYCAP">Control</b>-<b class="KEYCAP">Z</b>, 
      but it suspends the shell (the shell's parent process should
      resume it at an appropriate time).</p></dd><dt><a name="LOGOUTREF"></a><b class="COMMAND">logout</b></dt><dd><p>Exit a login shell, optionally specifying an <a href="#EXITSTATUSREF">exit status</a>.</p></dd><dt><a name="TIMESREF"></a><b class="COMMAND">times</b></dt><dd><p>Gives statistics on the system time elapsed when
            executing commands, in the following form:
      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="COMPUTEROUTPUT">0m0.020s 0m0.020s</tt></pre></font></td></tr></tbody></table></p><p>This capability is of relatively limited value, since it is not common to
      profile and benchmark shell scripts.</p></dd><dt><a name="KILLREF"></a><b class="COMMAND">kill</b></dt><dd><p>Forcibly terminate a process by sending it an
      appropriate <i class="FIRSTTERM">terminate</i> signal
      (see <a href="#KILLPROCESS">Example 17-6</a>).</p><div class="EXAMPLE"><a name="SELFDESTRUCT"></a><p><b>Example 15-27. A script that kills itself</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # self-destruct.sh
  
  kill $$  # Script kills its own process here.
           # Recall that "$$" is the script's PID.
  
  echo "This line will not echo."
  # Instead, the shell sends a "Terminated" message to stdout.
  
  exit 0   # Normal exit? No!
  
  #  After this script terminates prematurely,
  #+ what exit status does it return?
  #
  # sh self-destruct.sh
  # echo $?
  # 143
  #
  # 143 = 128 + 15
  #             TERM signal</pre></font></td></tr></tbody></table></div><p><a name="ZOMBIEREF"></a></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p><tt class="USERINPUT"><b>kill -l</b></tt> lists all the
      <a href="#SIGNALD">signals</a> (as does the
      file <tt class="FILENAME">/usr/include/asm/signal.h</tt>).
      A <tt class="USERINPUT"><b>kill -9</b></tt> is a <i class="FIRSTTERM">sure
      kill</i>, which will usually terminate a
      process that stubbornly refuses to die with a plain
      <b class="COMMAND">kill</b>. Sometimes, a <tt class="USERINPUT"><b>kill
      -15</b></tt> works. A <i class="FIRSTTERM">zombie</i> process,
      that is, a child process that has terminated, but that
      the <a href="#FORKREF">parent process</a>
      has not (yet) killed, cannot be killed by a logged-on
      user -- you can't kill something that is already dead --
      but <b class="COMMAND">init</b> will generally clean it up
      sooner or later.</p></td></tr></tbody></table></div></dd><dt><a name="KILLALLREF"></a><b class="COMMAND">killall</b></dt><dd><p>The <b class="COMMAND">killall</b> command
        kills a running process by <i class="FIRSTTERM">name</i>,
              rather than by <a href="#PROCESSIDREF">process ID</a>.
        If there are multiple instances of a particular command running,
        then doing a <i class="FIRSTTERM">killall</i> on that command will
        terminate them <em>all</em>.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>This refers to the <b class="COMMAND">killall</b>
          command in <tt class="FILENAME">/usr/bin</tt>,
          <em>not</em> the <a href="#KILLALL2REF">killall script</a> in <tt class="FILENAME">/etc/rc.d/init.d</tt>.</p></td></tr></tbody></table></div></dd><dt><a name="COMMANDREF"></a><b class="COMMAND">command</b></dt><dd><p>The <b class="COMMAND">command</b> directive
        disables aliases and functions for the command immediately
        following it.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>command ls</b></tt>
                </pre></font></td></tr></tbody></table>
        </p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>This is one of three shell directives that
          effect script command processing. The others are
          <a href="#BLTREF">builtin</a> and <a href="#ENABLEREF">enable</a>.</p></td></tr></tbody></table></div></dd><dt><a name="BLTREF"></a><b class="COMMAND">builtin</b></dt><dd><p>Invoking <b class="COMMAND">builtin
          BUILTIN_COMMAND</b> runs the command
          <tt class="REPLACEABLE"><i>BUILTIN_COMMAND</i></tt> as a shell <a href="#BUILTINREF">builtin</a>, temporarily disabling
          both functions and external system commands with the
          same name.</p></dd><dt><a name="ENABLEREF"></a><b class="COMMAND">enable</b></dt><dd><p>This either enables or disables a shell
          builtin command. As an example, <tt class="REPLACEABLE"><i>enable -n
          kill</i></tt> disables the shell builtin <a href="#KILLREF">kill</a>, so that when Bash
          subsequently encounters <i class="FIRSTTERM">kill</i>, it invokes
          the external command <tt class="FILENAME">/bin/kill</tt>.</p><p><a name="ENABLEREF1"></a>The <tt class="OPTION">-a</tt>
          option to <i class="FIRSTTERM">enable</i> lists all the
          shell builtins, indicating whether or not they
          are enabled. The <tt class="OPTION">-f filename</tt>
          option lets <i class="FIRSTTERM">enable</i> load a <a href="#BUILTINREF">builtin</a> as a shared library
          (DLL) module from a properly compiled object file.
            <a name="AEN9928" href="#FTN.AEN9928"><span class="footnote">[68]</span></a>.
         </p></dd><dt><a name="AUTOLOADREF"></a><b class="COMMAND">autoload</b></dt><dd><p>This is a port to Bash of the
        <i class="FIRSTTERM">ksh</i> autoloader. With
        <b class="COMMAND">autoload</b> in place, a function with
        an <i class="FIRSTTERM">autoload</i> declaration will load from an
        external file at its first invocation.
          <a name="AEN9949" href="#FTN.AEN9949"><span class="footnote">[69]</span></a>
        This saves system resources.</p><p>Note that <i class="FIRSTTERM">autoload</i> is not a part of the
        core Bash installation. It needs to be loaded in with
        <tt class="REPLACEABLE"><i>enable -f</i></tt> (see above).</p></dd></dl></div><p><a name="JOBIDTABLE0"></a></p><div class="TABLE"><a name="JOBIDTABLE"></a><p><b>Table 15-1. Job identifiers</b></p><table border="1" class="CALSTABLE"><thead><tr><th align="LEFT" valign="TOP">Notation</th><th align="LEFT" valign="TOP">Meaning</th></tr></thead><tbody><tr><td align="LEFT" valign="TOP"><tt class="OPTION">%N</tt></td><td align="LEFT" valign="TOP">Job number [N]</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">%S</tt></td><td align="LEFT" valign="TOP">Invocation (command-line) of job begins with string <em>S</em></td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">%?S</tt></td><td align="LEFT" valign="TOP">Invocation (command-line) of job contains within it string <em>S</em></td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">%%</tt></td><td align="LEFT" valign="TOP"><span class="QUOTE">"current"</span> job (last job stopped in
          foreground or started in background)</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">%+</tt></td><td align="LEFT" valign="TOP"><span class="QUOTE">"current"</span> job (last job stopped in
          foreground or started in background)</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">%-</tt></td><td align="LEFT" valign="TOP">Last job</td></tr><tr><td align="LEFT" valign="TOP"><tt class="OPTION">$!</tt></td><td align="LEFT" valign="TOP">Last background process</td></tr></tbody></table></div></div></div><div class="CHAPTER"><hr><h1><a name="EXTERNAL"></a>Chapter 16. External Filters, Programs and Commands</h1><p><a name="EXTERNALREF"></a></p><p>Standard UNIX commands make shell scripts more versatile. The
    power of scripts comes from coupling system commands and shell
    directives with simple programming constructs.</p><div class="SECT1"><hr><h1 class="SECT1"><a name="BASIC"></a>16.1. Basic Commands</h1><p></p><div class="VARIABLELIST"><p><b><a name="BASICCOMMANDS1"></a>The first commands a novice learns</b></p><dl><dt><a name="LSREF"></a><b class="COMMAND">ls</b></dt><dd><p>The basic file <span class="QUOTE">"list"</span> command. It is all too easy
          to underestimate the power of this humble command. For
          example, using the <tt class="OPTION">-R</tt>, recursive option,
          <b class="COMMAND">ls</b> provides a tree-like listing of
          a directory structure. Other useful options are
          <tt class="OPTION">-S</tt>, sort listing by file size,
          <tt class="OPTION">-t</tt>, sort by file modification time,
          <tt class="OPTION">-v</tt>, sort by (numerical) version numbers
          embedded in the filenames,
                  <a name="AEN10025" href="#FTN.AEN10025"><span class="footnote">[70]</span></a>
          <tt class="OPTION">-b</tt>, show escape characters, and
          <tt class="OPTION">-i</tt>, show file inodes (see <a href="#IDELETE">Example 16-4</a>).</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -l</b></tt>
  <tt class="COMPUTEROUTPUT">-rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter10.txt
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter11.txt
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter12.txt
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter1.txt
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter2.txt
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter3.txt
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:49 Chapter_headings.txt
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:49 Preface.txt</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -lv</b></tt>
  <tt class="COMPUTEROUTPUT"> total 0
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:49 Chapter_headings.txt
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:49 Preface.txt
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter1.txt
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter2.txt
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter3.txt
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter10.txt
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter11.txt
   -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter12.txt</tt></pre></font></td></tr></tbody></table></p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>	      The <i class="FIRSTTERM">ls</i> command returns a
          non-zero <a href="#EXITSTATUSREF">exit status</a> when
          attempting to list a non-existent file.
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls abc</b></tt>
  <tt class="COMPUTEROUTPUT">ls: abc: No such file or directory</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $?</b></tt>
  <tt class="COMPUTEROUTPUT">2</tt></pre></font></td></tr></tbody></table>
        </p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="EX40"></a><p><b>Example 16-1. Using <i class="FIRSTTERM">ls</i> to create a table of contents
      for burning a <span class="ABBREV">CDR</span> disk</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # ex40.sh (burn-cd.sh)
  # Script to automate burning a CDR.
  
  
  SPEED=10         # May use higher speed if your hardware supports it.
  IMAGEFILE=cdimage.iso
  CONTENTSFILE=contents
  # DEVICE=/dev/cdrom     For older versions of cdrecord
  DEVICE="1,0,0"
  DEFAULTDIR=/opt  # This is the directory containing the data to be burned.
                   # Make sure it exists.
                   # Exercise: Add a test for this.
  
  # Uses Joerg Schilling's "cdrecord" package:
  # http://www.fokus.fhg.de/usr/schilling/cdrecord.html
  
  #  If this script invoked as an ordinary user, may need to suid cdrecord
  #+ chmod u+s /usr/bin/cdrecord, as root.
  #  Of course, this creates a security hole, though a relatively minor one.
  
  if [ -z "$1" ]
  then
    IMAGE_DIRECTORY=$DEFAULTDIR
    # Default directory, if not specified on command-line.
  else
      IMAGE_DIRECTORY=$1
  fi
  
  # Create a "table of contents" file.
  ls -lRF $IMAGE_DIRECTORY &gt; $IMAGE_DIRECTORY/$CONTENTSFILE
  # The "l" option gives a "long" file listing.
  # The "R" option makes the listing recursive.
  # The "F" option marks the file types (directories get a trailing /).
  echo "Creating table of contents."
  
  # Create an image file preparatory to burning it onto the CDR.
  mkisofs -r -o $IMAGEFILE $IMAGE_DIRECTORY
  echo "Creating ISO9660 file system image ($IMAGEFILE)."
  
  # Burn the CDR.
  echo "Burning the disk."
  echo "Please be patient, this will take a while."
  wodim -v -isosize dev=$DEVICE $IMAGEFILE
  #  In newer Linux distros, the "wodim" utility assumes the
  #+ functionality of "cdrecord."
  exitcode=$?
  echo "Exit code = $exitcode"
  
  exit $exitcode</pre></font></td></tr></tbody></table></div></dd><dt><a name="CATREF"></a><b class="COMMAND">cat</b>, <b class="COMMAND">tac</b></dt><dd><p><b class="COMMAND">cat</b>, an acronym for
        <i class="WORDASWORD">concatenate</i>,
          lists a file to <tt class="FILENAME">stdout</tt>. When
          combined with redirection (<span class="TOKEN">&gt;</span> or
          <span class="TOKEN">&gt;&gt;</span>), it is commonly used to concatenate
          files.
  
      <a name="CATUSES"></a>
            <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Uses of 'cat'
  cat filename                          # Lists the file.
  
  cat file.1 file.2 file.3 &gt; file.123   # Combines three files into one.</pre></font></td></tr></tbody></table>
  
          The <tt class="OPTION">-n</tt> option to <b class="COMMAND">cat</b>
          inserts consecutive numbers before all lines of the
          target file(s). The <tt class="OPTION">-b</tt> option numbers
          only the non-blank lines. The <tt class="OPTION">-v</tt> option
          echoes nonprintable characters, using <span class="TOKEN">^</span>
          notation. The <tt class="OPTION">-s</tt> option squeezes multiple
          consecutive blank lines into a single blank line.</p><p>See also <a href="#LNUM">Example 16-28</a> and <a href="#ROT13">Example 16-24</a>.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p><a name="CATLESSEFF"></a>
        In a <a href="#PIPEREF">pipe</a>, it may be
        more efficient to <a href="#IOREDIRREF">redirect</a>
        the <tt class="FILENAME">stdin</tt> to a file, rather than to
              <b class="COMMAND">cat</b> the file.
              </p><p>	    <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">cat filename | tr a-z A-Z
  
  tr a-z A-Z &lt; filename   #  Same effect, but starts one less process,
                          #+ and also dispenses with the pipe.</pre></font></td></tr></tbody></table>
              </p></td></tr></tbody></table></div><p><b class="COMMAND">tac</b>, is the inverse of
          <i class="WORDASWORD">cat</i>, listing a file backwards from its end.</p></dd><dt><a name="REVREF"></a><b class="COMMAND">rev</b></dt><dd><p>reverses each line of a file, and outputs to
          <tt class="FILENAME">stdout</tt>.  This does not have the same effect
          as <b class="COMMAND">tac</b>, as it preserves the order of
          the lines, but flips each one around (mirror image).</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cat file1.txt</b></tt>
  <tt class="COMPUTEROUTPUT">This is line 1.
   This is line 2.</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>tac file1.txt</b></tt>
  <tt class="COMPUTEROUTPUT">This is line 2.
   This is line 1.</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>rev file1.txt</b></tt>
  <tt class="COMPUTEROUTPUT">.1 enil si sihT
   .2 enil si sihT</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="CPREF"></a><b class="COMMAND">cp</b></dt><dd><p>This is the file copy command. <tt class="USERINPUT"><b>cp file1
          file2</b></tt> copies <tt class="FILENAME">file1</tt>
          to <tt class="FILENAME">file2</tt>, overwriting
          <tt class="FILENAME">file2</tt> if it already exists (see <a href="#EX42">Example 16-6</a>).</p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>Particularly useful are the <tt class="OPTION">-a</tt>
           archive flag (for copying an entire directory tree),
           the <tt class="OPTION">-u</tt> update flag (which prevents
           overwriting identically-named newer files), and the
           <tt class="OPTION">-r</tt> and <tt class="OPTION">-R</tt> recursive
           flags.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">cp -u source_dir/* dest_dir
  #  "Synchronize" dest_dir to source_dir
  #+  by copying over all newer and not previously existing files.</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div></dd><dt><a name="MVREF"></a><b class="COMMAND">mv</b></dt><dd><p>This is the file <i class="FIRSTTERM">move</i> command.
          It is equivalent to a combination of <b class="COMMAND">cp</b>
          and <b class="COMMAND">rm</b>. It may be used to move multiple
          files to a directory, or even to rename a directory. For
          some examples of using <b class="COMMAND">mv</b> in a script,
          see <a href="#RFE">Example 10-11</a> and <a href="#RN">Example A-2</a>.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>When used in a non-interactive script,
          <b class="COMMAND">mv</b> takes the <tt class="OPTION">-f</tt>
          (<i class="FIRSTTERM">force</i>) option to bypass user
          input.</p><p>When a directory is moved to a preexisting directory,
          it becomes a subdirectory of the destination directory.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>mv source_directory target_directory</b></tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -lF target_directory</b></tt>
  <tt class="COMPUTEROUTPUT">total 1
   drwxrwxr-x    2 bozo  bozo      1024 May 28 19:20 source_directory/</tt>
          </pre></font></td></tr></tbody></table>
        </p></td></tr></tbody></table></div></dd><dt><a name="RMREF"></a><b class="COMMAND">rm</b></dt><dd><p>Delete (remove) a file or files. The <tt class="OPTION">-f</tt>
          option forces removal of even readonly files, and is useful
          for bypassing user input in a script.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p><a name="DASHREM"></a></p><p>The <i class="FIRSTTERM">rm</i> command will, by
      itself,  fail to remove filenames beginning with
      a dash. Why? Because <i class="FIRSTTERM">rm</i>
      sees a dash-prefixed filename as an
      <i class="FIRSTTERM">option</i>.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>rm -badname</b></tt>
  <tt class="COMPUTEROUTPUT">rm: invalid option -- b
   Try `rm --help' for more information.</tt></pre></font></td></tr></tbody></table>
          </p><p>		One clever workaround is to precede
      the filename with a <span class="QUOTE">" -- "</span> (the
      <i class="FIRSTTERM">end-of-options</i> flag).
  
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>rm -- -badname</b></tt></pre></font></td></tr></tbody></table>
      </p><p>	      Another method to is to preface the filename to be removed
          with a <tt class="FILENAME">dot-slash</tt> .
  
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>rm ./-badname</b></tt></pre></font></td></tr></tbody></table>
          </p></td></tr></tbody></table></div><div class="WARNING"><p></p><table class="WARNING" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/warning.gif" hspace="5" alt="Warning"></td><td align="LEFT" valign="TOP"><p><a name="RMRECURS"></a>When used with the
          recursive flag <tt class="OPTION">-r</tt>, this command removes
          files all the way down the directory tree from the current
          directory.  A careless <b class="COMMAND">rm -rf *</b> can wipe
          out a big chunk of a directory structure.</p></td></tr></tbody></table></div></dd><dt><a name="RMDIRREF"></a><b class="COMMAND">rmdir</b></dt><dd><p>Remove directory. The directory must be empty of
          all files -- including <span class="QUOTE">"invisible"</span>
          <i class="FIRSTTERM">dotfiles</i>
  
      <a name="AEN10228" href="#FTN.AEN10228"><span class="footnote">[71]</span></a>
  
          -- for this command to succeed.</p></dd><dt><a name="MKDIRREF"></a><b class="COMMAND">mkdir</b></dt><dd><p>Make directory, creates a new directory. For example,
          <tt class="USERINPUT"><b>mkdir -p project/programs/December</b></tt>
          creates the named directory. The
          <tt class="REPLACEABLE"><i>-p</i></tt> option automatically creates
          any necessary parent directories.</p></dd><dt><a name="CHMODREF"></a><b class="COMMAND">chmod</b></dt><dd><p>Changes the attributes of an existing file or directory
          (see <a href="#EX44">Example 15-14</a>).</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">chmod +x filename
  # Makes "filename" executable for all users.
  
  chmod u+s filename
  # Sets "suid" bit on "filename" permissions.
  # An ordinary user may execute "filename" with same privileges as the file's owner.
  # (This does not apply to shell scripts.)</pre></font></td></tr></tbody></table></p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">chmod 644 filename
  #  Makes "filename" readable/writable to owner, readable to others
  #+ (octal mode).
  
  chmod 444 filename
  #  Makes "filename" read-only for all.
  #  Modifying the file (for example, with a text editor)
  #+ not allowed for a user who does not own the file (except for root),
  #+ and even the file owner must force a file-save
  #+ if she modifies the file.
  #  Same restrictions apply for deleting the file.</pre></font></td></tr></tbody></table></p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">chmod 1777 directory-name
  #  Gives everyone read, write, and execute permission in directory,
  #+ however also sets the "sticky bit".
  #  This means that only the owner of the directory,
  #+ owner of the file, and, of course, root
  #+ can delete any particular file in that directory.
  
  chmod 111 directory-name
  #  Gives everyone execute-only permission in a directory.
  #  This means that you can execute and READ the files in that directory
  #+ (execute permission necessarily includes read permission
  #+ because you can't execute a file without being able to read it).
  #  But you can't list the files or search for them with the "find" command.
  #  These restrictions do not apply to root.
  
  chmod 000 directory-name
  #  No permissions at all for that directory.
  #  Can't read, write, or execute files in it.
  #  Can't even list files in it or "cd" to it.
  #  But, you can rename (mv) the directory
  #+ or delete it (rmdir) if it is empty.
  #  You can even symlink to files in the directory,
  #+ but you can't read, write, or execute the symlinks.
  #  These restrictions do not apply to root.</pre></font></td></tr></tbody></table></p></dd><dt><a name="CHATTRREF"></a><b class="COMMAND">chattr</b></dt><dd><p><b class="COMMAND">Ch</b>ange file
          <b class="COMMAND">attr</b>ibutes. This is analogous to
          <b class="COMMAND">chmod</b> above, but with different options
          and a different invocation syntax, and it works only on
           <i class="FIRSTTERM">ext2/ext3</i> filesystems.</p><p>One particularly interesting <b class="COMMAND">chattr</b>
          option is <tt class="OPTION">i</tt>. A <b class="COMMAND">chattr +i
          <tt class="FILENAME">filename</tt></b> marks the file
          as immutable. The file cannot be modified, linked to, or
          deleted, <em>not even by root</em>. This
          file attribute can be set or removed only by
          <i class="FIRSTTERM">root</i>. In a similar fashion,
          the <tt class="OPTION">a</tt> option marks the file as append
          only.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">root# </tt><tt class="USERINPUT"><b>chattr +i file1.txt</b></tt>
  
  
  <tt class="PROMPT">root# </tt><tt class="USERINPUT"><b>rm file1.txt</b></tt>
  
  <tt class="COMPUTEROUTPUT">rm: remove write-protected regular file `file1.txt'? y
   rm: cannot remove `file1.txt': Operation not permitted</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>If a file has the <tt class="OPTION">s</tt> (secure)
                attribute set, then when it is deleted its block is 
          overwritten with binary zeroes.
      <a name="AEN10301" href="#FTN.AEN10301"><span class="footnote">[72]</span></a>
          </p><p>If a file has the <tt class="OPTION">u</tt> (undelete)
                attribute set, then when it is deleted, its contents can still
          be retrieved (undeleted).</p><p>If a file has the <tt class="OPTION">c</tt> (compress)
                attribute set, then it will automatically be compressed
          on writes to disk, and uncompressed on reads.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The file attributes set with
          <b class="COMMAND">chattr</b> do not show in a file listing
          (<b class="COMMAND">ls -l</b>).</p></td></tr></tbody></table></div></dd><dt><a name="LINKREF"></a><b class="COMMAND">ln</b></dt><dd><p>Creates links to pre-existings files. A <span class="QUOTE">"link"</span>
          is a reference to a file, an alternate name for it.
          The <b class="COMMAND">ln</b> command permits referencing
          the linked file by more than one name and is a superior
          alternative to aliasing (see <a href="#EX18">Example 4-6</a>).</p><p>The <b class="COMMAND">ln</b> creates only a reference, a
           pointer to the file only a few bytes in size.</p><p><a name="SYMLINKREF"></a></p><p>The <b class="COMMAND">ln</b> command is most often used
          with the <tt class="OPTION">-s</tt>, symbolic or
          <span class="QUOTE">"soft"</span> link flag. Advantages of using the
          <tt class="OPTION">-s</tt> flag are that it permits linking across
          file systems or to directories.</p><p>The syntax of the command is a bit tricky. For example:
          <tt class="USERINPUT"><b>ln -s oldfile newfile</b></tt> links the
          previously existing <tt class="FILENAME">oldfile</tt> to the
          newly created link, <tt class="FILENAME">newfile</tt>.</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>If a file named <tt class="FILENAME">newfile</tt> has
          previously existed, an error message will
          result.</p></td></tr></tbody></table></div><table class="SIDEBAR" border="1" cellpadding="5"><tbody><tr><td><div class="SIDEBAR"><a name="AEN10336"></a><p><b>Which type of link to use?</b></p><p>As John Macdonald explains it:</p><p>Both of these [types of links] provide a certain measure of dual reference
      -- if you edit the contents of the file using any name,
      your changes will affect both the original name and either
      a hard or soft new name.  The differences between them
      occurs when you work at a higher level.  The advantage of
      a hard link is that the new name is totally independent
      of the old name -- if you remove or rename the old name,
      that does not affect the hard link, which continues
      to point to the data while it would leave a soft link
      hanging pointing to the old name which is no longer
      there. The advantage of a soft link is that it can refer
      to a different file system (since it is just a reference
      to a file name, not to actual data). And, unlike a hard
      link, a symbolic link can refer to a directory.</p></div></td></tr></tbody></table><p><a name="LINKMINVOK"></a></p><p>Links give the ability to invoke a script (or any other type
          of executable) with multiple names, and having that script
          behave according to how it was invoked.</p><div class="EXAMPLE"><a name="HELLOL"></a><p><b>Example 16-2. Hello or Good-bye</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # hello.sh: Saying "hello" or "goodbye"
  #+          depending on how script is invoked.
  
  # Make a link in current working directory ($PWD) to this script:
  #    ln -s hello.sh goodbye
  # Now, try invoking this script both ways:
  # ./hello.sh
  # ./goodbye
  
  
  HELLO_CALL=65
  GOODBYE_CALL=66
  
  if [ $0 = "./goodbye" ]
  then
    echo "Good-bye!"
    # Some other goodbye-type commands, as appropriate.
    exit $GOODBYE_CALL
  fi
  
  echo "Hello!"
  # Some other hello-type commands, as appropriate.
  exit $HELLO_CALL</pre></font></td></tr></tbody></table></div></dd><dt><a name="MANREF"></a><b class="COMMAND">man</b>, <a name="INFOREF"></a><b class="COMMAND">info</b></dt><dd><p>These commands access the manual and information pages on
          system commands and installed utilities. When available, the
          <i class="FIRSTTERM">info</i> pages usually contain more detailed
          descriptions than do the <i class="FIRSTTERM">man</i> pages.</p><p>There have been various attempts at
          <span class="QUOTE">"automating"</span> the writing of <i class="FIRSTTERM">man
          pages</i>. For a script that makes a tentative first
          step in that direction, see <a href="#MANED">Example A-39</a>.</p></dd></dl></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="MOREADV"></a>16.2. Complex Commands</h1><p></p><div class="VARIABLELIST"><p><b><a name="CCLISTING1"></a>Commands for more advanced users</b></p><dl><dt><a name="FINDREF"></a><b class="COMMAND">find</b></dt><dd><p><a name="FINDREF0"></a></p><p>-exec <tt class="REPLACEABLE"><i>COMMAND</i></tt> \;</p><p>Carries out <tt class="REPLACEABLE"><i>COMMAND</i></tt> on
          each file that <b class="COMMAND">find</b> matches.  The
          command sequence terminates with <span class="TOKEN">;</span> (the
          <span class="QUOTE">";"</span> is <a href="#ESCP">escaped</a> to
          make certain the shell passes it to <b class="COMMAND">find</b>
          literally, without interpreting it as a special character).</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>find ~/ -name '*.txt'</b></tt>
  <tt class="COMPUTEROUTPUT">/home/bozo/.kde/share/apps/karm/karmdata.txt
   /home/bozo/misc/irmeyc.txt
   /home/bozo/test-scripts/1.txt</tt>
          </pre></font></td></tr></tbody></table>
      </p><p><a name="CURLYBRACKETSREF"></a></p><p>If <tt class="REPLACEABLE"><i>COMMAND</i></tt> contains
          <span class="TOKEN">{}</span>, then <b class="COMMAND">find</b>
          substitutes the full path name of the selected file for
          <span class="QUOTE">"{}"</span>.</p><p>          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">find ~/ -name 'core*' -exec rm {} \;
  # Removes all core dump files from user's home directory.</pre></font></td></tr></tbody></table>
      </p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">find /home/bozo/projects -mtime -1
  #                               ^   Note minus sign!
  #  Lists all files in /home/bozo/projects directory tree
  #+ that were modified within the last day (current_day - 1).
  #
  find /home/bozo/projects -mtime 1
  #  Same as above, but modified *exactly* one day ago.
  #
  #  mtime = last modification time of the target file
  #  ctime = last status change time (via 'chmod' or otherwise)
  #  atime = last access time
  
  DIR=/home/bozo/junk_files
  find "$DIR" -type f -atime +5 -exec rm {} \;
  #                          ^           ^^
  #  Curly brackets are placeholder for the path name output by "find."
  #
  #  Deletes all files in "/home/bozo/junk_files"
  #+ that have not been accessed in *at least* 5 days (plus sign ... +5).
  #
  #  "-type filetype", where
  #  f = regular file
  #  d = directory
  #  l = symbolic link, etc.
  #
  #  (The 'find' manpage and info page have complete option listings.)</pre></font></td></tr></tbody></table>
            </p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;
  
  # Finds all IP addresses (xxx.xxx.xxx.xxx) in /etc directory files.
  # There a few extraneous hits. Can they be filtered out?
  
  # Possibly by:
  
  find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n' \
  | grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'
  #
  #  [:digit:] is one of the character classes
  #+ introduced with the POSIX 1003.2 standard. 
  
  # Thanks, StÃ©phane Chazelas. </pre></font></td></tr></tbody></table></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <tt class="OPTION">-exec</tt> option to
          <b class="COMMAND">find</b> should not be confused with the <a href="#EXECREF">exec</a> shell builtin.</p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="EX57"></a><p><b>Example 16-3. <i class="FIRSTTERM">Badname</i>, eliminate file names
      in current directory containing bad characters and <a href="#WHITESPACEREF">whitespace</a>.</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # badname.sh
  # Delete filenames in current directory containing bad characters.
  
  for filename in *
  do
    badname=`echo "$filename" | sed -n /[\+\{\;\"\\\=\?~\(\)\&lt;\&gt;\&amp;\*\|\$]/p`
  # badname=`echo "$filename" | sed -n '/[+{;"\=?~()&lt;&gt;&amp;*|$]/p'`  also works.
  # Deletes files containing these nasties:     + { ; " \ = ? ~ ( ) &lt; &gt; &amp; * | $
  #
    rm $badname 2&gt;/dev/null
  #             ^^^^^^^^^^^ Error messages deep-sixed.
  done
  
  # Now, take care of files containing all manner of whitespace.
  find . -name "* *" -exec rm -f {} \;
  # The path name of the file that _find_ finds replaces the "{}".
  # The '\' ensures that the ';' is interpreted literally, as end of command.
  
  exit 0
  
  #---------------------------------------------------------------------
  # Commands below this line will not execute because of _exit_ command.
  
  # An alternative to the above script:
  find . -name '*[+{;"\\=?~()&lt;&gt;&amp;*|$ ]*' -maxdepth 0 \
  -exec rm -f '{}' \;
  #  The "-maxdepth 0" option ensures that _find_ will not search
  #+ subdirectories below $PWD.
  
  # (Thanks, S.C.)</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="IDELETE"></a><p><b>Example 16-4. Deleting a file by its <i class="FIRSTTERM">inode</i>
            number</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # idelete.sh: Deleting a file by its inode number.
  
  #  This is useful when a filename starts with an illegal character,
  #+ such as ? or -.
  
  ARGCOUNT=1                      # Filename arg must be passed to script.
  E_WRONGARGS=70
  E_FILE_NOT_EXIST=71
  E_CHANGED_MIND=72
  
  if [ $# -ne "$ARGCOUNT" ]
  then
    echo "Usage: `basename $0` filename"
    exit $E_WRONGARGS
  fi  
  
  if [ ! -e "$1" ]
  then
    echo "File \""$1"\" does not exist."
    exit $E_FILE_NOT_EXIST
  fi  
  
  inum=`ls -i | grep "$1" | awk '{print $1}'`
  # inum = inode (index node) number of file
  # -----------------------------------------------------------------------
  # Every file has an inode, a record that holds its physical address info.
  # -----------------------------------------------------------------------
  
  echo; echo -n "Are you absolutely sure you want to delete \"$1\" (y/n)? "
  # The '-v' option to 'rm' also asks this.
  read answer
  case "$answer" in
  [nN]) echo "Changed your mind, huh?"
        exit $E_CHANGED_MIND
        ;;
  *)    echo "Deleting file \"$1\".";;
  esac
  
  find . -inum $inum -exec rm {} \;
  #                           ^^
  #        Curly brackets are placeholder
  #+       for text output by "find."
  echo "File "\"$1"\" deleted!"
  
  exit 0</pre></font></td></tr></tbody></table></div><p>The <b class="COMMAND">find</b> command also works
          without the <tt class="OPTION">-exec</tt> option.</p><p>	    <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  #  Find suid root files.
  #  A strange suid file might indicate a security hole,
  #+ or even a system intrusion.
  
  directory="/usr/sbin"
  # Might also try /sbin, /bin, /usr/bin, /usr/local/bin, etc.
  permissions="+4000"  # suid root (dangerous!)
  
  
  for file in $( find "$directory" -perm "$permissions" )
  do
    ls -ltF --author "$file"
  done</pre></font></td></tr></tbody></table>
        </p><p>See <a href="#EX48">Example 16-30</a>, <a href="#EX58">Example 3-4</a>,
          and <a href="#FINDSTRING">Example 11-10</a> for scripts using
          <b class="COMMAND">find</b>. Its <a href="#MANREF">manpage</a> provides more detail
          on this complex and powerful command.</p></dd><dt><a name="XARGSREF"></a><b class="COMMAND">xargs</b></dt><dd><p>A filter for feeding arguments to a command, and also
          a tool for assembling the commands themselves. It breaks
          a data stream into small enough chunks for filters and
          commands to process.  Consider it as a powerful replacement
          for <a href="#BACKQUOTESREF">backquotes</a>.
          In situations where <a href="#COMMANDSUBREF">command
          substitution</a> fails with a <span class="ERRORNAME">too
          many arguments</span> error,
          substituting <b class="COMMAND">xargs</b> often
          works.
            <a name="AEN10465" href="#FTN.AEN10465"><span class="footnote">[73]</span></a>
          Normally, <b class="COMMAND">xargs</b> reads from
          <tt class="FILENAME">stdin</tt> or from a pipe, but it can also
          be given the output of a file.</p><p>The default command for <b class="COMMAND">xargs</b> is
          <a href="#ECHOREF">echo</a>. This means that input
          piped to <b class="COMMAND">xargs</b> may have linefeeds and
          other whitespace characters stripped out.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -l</b></tt>
  <tt class="COMPUTEROUTPUT">total 0
   -rw-rw-r--    1 bozo  bozo         0 Jan 29 23:58 file1
   -rw-rw-r--    1 bozo  bozo         0 Jan 29 23:58 file2</tt>
  
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ls -l | xargs</b></tt>
  <tt class="COMPUTEROUTPUT">total 0 -rw-rw-r-- 1 bozo bozo 0 Jan 29 23:58 file1 -rw-rw-r-- 1 bozo bozo 0 Jan...</tt>
  
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>find ~/mail -type f | xargs grep "Linux"</b></tt>
  <tt class="COMPUTEROUTPUT">./misc:User-Agent: slrn/0.9.8.1 (Linux)
   ./sent-mail-jul-2005: hosted by the Linux Documentation Project.
   ./sent-mail-jul-2005: (Linux Documentation Project Site, rtf version)
   ./sent-mail-jul-2005: Subject: Criticism of Bozo's Windows/Linux article
   ./sent-mail-jul-2005: while mentioning that the Linux ext2/ext3 filesystem
   . . .</tt>
          </pre></font></td></tr></tbody></table>
          </p><p><tt class="USERINPUT"><b>ls | xargs -p -l gzip</b></tt> <a href="#GZIPREF">gzips</a> every file in current
          directory, one at a time, prompting before each
          operation.</p><p><a name="XARGSONEATATIME"></a></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>Note that <i class="FIRSTTERM">xargs</i> processes the
          arguments passed to it sequentially, <em>one at
          a time</em>.</p><p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>find /usr/bin | xargs file</b></tt>
  <tt class="COMPUTEROUTPUT">/usr/bin:          directory
   /usr/bin/foomatic-ppd-options:          perl script text executable
   . . .</tt>
          </pre></font></td></tr></tbody></table>
          </p></td></tr></tbody></table></div><p><a name="XARGSLIMARGS"></a></p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>An interesting <i class="FIRSTTERM">xargs</i>
          option is <tt class="OPTION">-n <tt class="REPLACEABLE"><i>NN</i></tt></tt>,
          which limits to <tt class="REPLACEABLE"><i>NN</i></tt> the number
          of arguments passed.</p><p><tt class="USERINPUT"><b>ls | xargs -n 8 echo</b></tt> lists the files in the
          current directory in <tt class="LITERAL">8</tt> columns.</p></td></tr></tbody></table></div><p><a name="XARGSWS"></a></p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>Another useful option is
          <tt class="OPTION">-0</tt>, in combination with <tt class="USERINPUT"><b>find
          -print0</b></tt> or <tt class="USERINPUT"><b>grep -lZ</b></tt>. This
          allows handling arguments containing whitespace or
          quotes.</p><p>	    <tt class="USERINPUT"><b>find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f</b></tt>
        </p><p>	    <tt class="USERINPUT"><b>grep -rliwZ GUI / | xargs -0 rm -f</b></tt>
        </p><p>Either of the above will remove any file containing <span class="QUOTE">"GUI"</span>.
          <em>(Thanks, S.C.)</em></p><p>Or:
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">cat /proc/"$pid"/"$OPTION" | xargs -0 echo
  #  Formats output:         ^^^^^^^^^^^^^^^
  #  From Han Holl's fixup of "get-commandline.sh"
  #+ script in "/dev and /proc" chapter.</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p><a name="XARGSMULTIPROCESS"></a></p><p>The <tt class="OPTION">-P</tt> option to
            <i class="FIRSTTERM">xargs</i> permits running
            processes in parallel. This speeds up execution
            in a machine with a multicore CPU.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  ls *gif | xargs -t -n1 -P2 gif2png
  # Converts all the gif images in current directory to png.
  
  # Options:
  # =======
  # -t    Print command to stderr.
  # -n1   At most 1 argument per command line.
  # -P2   Run up to 2 processes simultaneously.
  
  # Thank you, Roberto Polli, for the inspiration.</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="EX41"></a><p><b>Example 16-5. Logfile: Using <i class="FIRSTTERM">xargs</i> to monitor system log</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  # Generates a log file in current directory
  # from the tail end of /var/log/messages.
  
  # Note: /var/log/messages must be world readable
  # if this script invoked by an ordinary user.
  #         #root chmod 644 /var/log/messages
  
  LINES=5
  
  ( date; uname -a ) &gt;&gt;logfile
  # Time and machine name
  echo ---------------------------------------------------------- &gt;&gt;logfile
  tail -n $LINES /var/log/messages | xargs | fmt -s &gt;&gt;logfile
  echo &gt;&gt;logfile
  echo &gt;&gt;logfile
  
  exit 0
  
  #  Note:
  #  ----
  #  As Frank Wang points out,
  #+ unmatched quotes (either single or double quotes) in the source file
  #+ may give xargs indigestion.
  #
  #  He suggests the following substitution for line 15:
  #  tail -n $LINES /var/log/messages | tr -d "\"'" | xargs | fmt -s &gt;&gt;logfile
  
  
  
  #  Exercise:
  #  --------
  #  Modify this script to track changes in /var/log/messages at intervals
  #+ of 20 minutes.
  #  Hint: Use the "watch" command. </pre></font></td></tr></tbody></table></div><p><a name="XARGSCURLYREF"></a></p><p><a href="#CURLYBRACKETSREF">As in
          <b class="COMMAND">find</b></a>, a curly bracket
          pair serves as a placeholder for replacement text.</p><div class="EXAMPLE"><a name="EX42"></a><p><b>Example 16-6. Copying files in current directory to another</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # copydir.sh
  
  #  Copy (verbose) all files in current directory ($PWD)
  #+ to directory specified on command-line.
  
  E_NOARGS=85
  
  if [ -z "$1" ]   # Exit if no argument given.
  then
    echo "Usage: `basename $0` directory-to-copy-to"
    exit $E_NOARGS
  fi  
  
  ls . | xargs -i -t cp ./{} $1
  #            ^^ ^^      ^^
  #  -t is "verbose" (output command-line to stderr) option.
  #  -i is "replace strings" option.
  #  {} is a placeholder for output text.
  #  This is similar to the use of a curly-bracket pair in "find."
  #
  #  List the files in current directory (ls .),
  #+ pass the output of "ls" as arguments to "xargs" (-i -t options),
  #+ then copy (cp) these arguments ({}) to new directory ($1).  
  #
  #  The net result is the exact equivalent of
  #+   cp * $1
  #+ unless any of the filenames has embedded "whitespace" characters.
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="KILLBYNAME"></a><p><b>Example 16-7. Killing processes by name</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # kill-byname.sh: Killing processes by name.
  # Compare this script with kill-process.sh.
  
  #  For instance,
  #+ try "./kill-byname.sh xterm" --
  #+ and watch all the xterms on your desktop disappear.
  
  #  Warning:
  #  -------
  #  This is a fairly dangerous script.
  #  Running it carelessly (especially as root)
  #+ can cause data loss and other undesirable effects.
  
  E_BADARGS=66
  
  if test -z "$1"  # No command-line arg supplied?
  then
    echo "Usage: `basename $0` Process(es)_to_kill"
    exit $E_BADARGS
  fi
  
  
  PROCESS_NAME="$1"
  ps ax | grep "$PROCESS_NAME" | awk '{print $1}' | xargs -i kill {} 2&amp;&gt;/dev/null
  #                                                       ^^      ^^
  
  # ---------------------------------------------------------------
  # Notes:
  # -i is the "replace strings" option to xargs.
  # The curly brackets are the placeholder for the replacement.
  # 2&amp;&gt;/dev/null suppresses unwanted error messages.
  #
  # Can  grep "$PROCESS_NAME" be replaced by pidof "$PROCESS_NAME"?
  # ---------------------------------------------------------------
  
  exit $?
  
  #  The "killall" command has the same effect as this script,
  #+ but using it is not quite as educational.</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="WF2"></a><p><b>Example 16-8. Word frequency analysis using
          <i class="FIRSTTERM">xargs</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # wf2.sh: Crude word frequency analysis on a text file.
  
  # Uses 'xargs' to decompose lines of text into single words.
  # Compare this example to the "wf.sh" script later on.
  
  
  # Check for input file on command-line.
  ARGS=1
  E_BADARGS=85
  E_NOFILE=86
  
  if [ $# -ne "$ARGS" ]
  # Correct number of arguments passed to script?
  then
    echo "Usage: `basename $0` filename"
    exit $E_BADARGS
  fi
  
  if [ ! -f "$1" ]       # Does file exist?
  then
    echo "File \"$1\" does not exist."
    exit $E_NOFILE
  fi
  
  
  
  #####################################################
  cat "$1" | xargs -n1 | \
  #  List the file, one word per line. 
  tr A-Z a-z | \
  #  Shift characters to lowercase.
  sed -e 's/\.//g'  -e 's/\,//g' -e 's/ /\
  /g' | \
  #  Filter out periods and commas, and
  #+ change space between words to linefeed,
  sort | uniq -c | sort -nr
  #  Finally remove duplicates, prefix occurrence count
  #+ and sort numerically.
  #####################################################
  
  #  This does the same job as the "wf.sh" example,
  #+ but a bit more ponderously, and it runs more slowly (why?).
  
  exit $?</pre></font></td></tr></tbody></table></div></dd><dt><a name="EXPRREF"></a><tt class="USERINPUT"><b>expr</b></tt></dt><dd><p>All-purpose expression evaluator:
          Concatenates and evaluates the arguments according
          to the operation given (arguments must be separated
          by spaces). Operations may be arithmetic, comparison,
          string, or logical.</p><p></p><div class="VARIABLELIST"><dl><dt><tt class="USERINPUT"><b>expr 3 + 5</b></tt></dt><dd><p>returns <tt class="LITERAL">8</tt></p></dd><dt><tt class="USERINPUT"><b>expr 5 % 3</b></tt></dt><dd><p>returns 2</p></dd><dt><tt class="USERINPUT"><b>expr 1 / 0</b></tt></dt><dd><p>returns the error message, <span class="ERRORCODE">expr: division by
          zero</span></p><p>Illegal arithmetic operations not allowed.</p></dd><dt><tt class="USERINPUT"><b>expr 5 \* 3</b></tt></dt><dd><p>returns 15</p><p>The multiplication operator
        must be escaped when used in an arithmetic expression
        with <b class="COMMAND">expr</b>.</p></dd><dt><tt class="USERINPUT"><b>y=`expr $y + 1`</b></tt></dt><dd><p>Increment a variable, with the same effect
          as <tt class="USERINPUT"><b>let y=y+1</b></tt> and
          <tt class="USERINPUT"><b>y=$(($y+1))</b></tt>. This is an
          example of <a href="#ARITHEXPREF">arithmetic
          expansion</a>.</p></dd><dt><a name="EXPEXTRSUB"></a><tt class="USERINPUT"><b>z=`expr substr
      $string $position $length`</b></tt></dt><dd><p>Extract substring of $length characters, starting
          at $position.</p></dd></dl></div><div class="EXAMPLE"><a name="EX45"></a><p><b>Example 16-9. Using <i class="FIRSTTERM">expr</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  # Demonstrating some of the uses of 'expr'
  # =======================================
  
  echo
  
  # Arithmetic Operators
  # ---------- ---------
  
  echo "Arithmetic Operators"
  echo
  a=`expr 5 + 3`
  echo "5 + 3 = $a"
  
  a=`expr $a + 1`
  echo
  echo "a + 1 = $a"
  echo "(incrementing a variable)"
  
  a=`expr 5 % 3`
  # modulo
  echo
  echo "5 mod 3 = $a"
  
  echo
  echo
  
  # Logical Operators
  # ------- ---------
  
  #  Returns 1 if true, 0 if false,
  #+ opposite of normal Bash convention.
  
  echo "Logical Operators"
  echo
  
  x=24
  y=25
  b=`expr $x = $y`         # Test equality.
  echo "b = $b"            # 0  ( $x -ne $y )
  echo
  
  a=3
  b=`expr $a \&gt; 10`
  echo 'b=`expr $a \&gt; 10`, therefore...'
  echo "If a &gt; 10, b = 0 (false)"
  echo "b = $b"            # 0  ( 3 ! -gt 10 )
  echo
  
  b=`expr $a \&lt; 10`
  echo "If a &lt; 10, b = 1 (true)"
  echo "b = $b"            # 1  ( 3 -lt 10 )
  echo
  # Note escaping of operators.
  
  b=`expr $a \&lt;= 3`
  echo "If a &lt;= 3, b = 1 (true)"
  echo "b = $b"            # 1  ( 3 -le 3 )
  # There is also a "\&gt;=" operator (greater than or equal to).
  
  
  echo
  echo
  
  
  
  # String Operators
  # ------ ---------
  
  echo "String Operators"
  echo
  
  a=1234zipper43231
  echo "The string being operated upon is \"$a\"."
  
  # length: length of string
  b=`expr length $a`
  echo "Length of \"$a\" is $b."
  
  # index: position of first character in substring
  #        that matches a character in string
  b=`expr index $a 23`
  echo "Numerical position of first \"2\" in \"$a\" is \"$b\"."
  
  # substr: extract substring, starting position &amp; length specified
  b=`expr substr $a 2 6`
  echo "Substring of \"$a\", starting at position 2,\
  and 6 chars long is \"$b\"."
  
  
  #  The default behavior of the 'match' operations is to
  #+ search for the specified match at the BEGINNING of the string.
  #
  #       Using Regular Expressions ...
  b=`expr match "$a" '[0-9]*'`               #  Numerical count.
  echo Number of digits at the beginning of \"$a\" is $b.
  b=`expr match "$a" '\([0-9]*\)'`           #  Note that escaped parentheses
  #                   ==      ==             #+ trigger substring match.
  echo "The digits at the beginning of \"$a\" are \"$b\"."
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="IMPORTANT"><p></p><table class="IMPORTANT" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/important.gif" hspace="5" alt="Important"></td><td align="LEFT" valign="TOP"><p>The <a href="#NULLREF">:
          (<i class="FIRSTTERM">null</i>)</a> operator
          can substitute for <b class="COMMAND">match</b>. For example,
          <tt class="USERINPUT"><b>b=`expr $a : [0-9]*`</b></tt> is the
          exact equivalent of <tt class="USERINPUT"><b>b=`expr match $a
          [0-9]*`</b></tt> in the above listing.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  echo
  echo "String operations using \"expr \$string : \" construct"
  echo "==================================================="
  echo
  
  a=1234zipper5FLIPPER43231
  
  echo "The string being operated upon is \"`expr "$a" : '\(.*\)'`\"."
  #     Escaped parentheses grouping operator.            ==  ==
  
  #       ***************************
  #+          Escaped parentheses
  #+           match a substring
  #       ***************************
  
  
  #  If no escaped parentheses ...
  #+ then 'expr' converts the string operand to an integer.
  
  echo "Length of \"$a\" is `expr "$a" : '.*'`."   # Length of string
  
  echo "Number of digits at the beginning of \"$a\" is `expr "$a" : '[0-9]*'`."
  
  # ------------------------------------------------------------------------- #
  
  echo
  
  echo "The digits at the beginning of \"$a\" are `expr "$a" : '\([0-9]*\)'`."
  #                                                             ==      ==
  echo "The first 7 characters of \"$a\" are `expr "$a" : '\(.......\)'`."
  #         =====                                          ==       ==
  # Again, escaped parentheses force a substring match.
  #
  echo "The last 7 characters of \"$a\" are `expr "$a" : '.*\(.......\)'`."
  #         ====                  end of string operator  ^^
  #  (In fact, means skip over one or more of any characters until specified
  #+  substring found.)
  
  echo
  
  exit 0</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div></dd></dl></div><p>The above script illustrates how
          <b class="COMMAND">expr</b> uses the <i class="FIRSTTERM">escaped
          parentheses -- \( ... \) --</i> grouping operator
          in tandem with <a href="#REGEXREF">regular
          expression</a> parsing to match a substring.
          Here is a another example, this time from <span class="QUOTE">"real
          life."</span>
  
            <table border="0" bgcolor="#E0E0E0" width="100%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Strip the whitespace from the beginning and end.
  LRFDATE=`expr "$LRFDATE" : '[[:space:]]*\(.*\)[[:space:]]*$'`
  
  #  From Peter Knowles' "booklistgen.sh" script
  #+ for converting files to Sony Librie/PRS-50X format.
  #  (http://booklistgensh.peterknowles.com)</pre></font></td></tr></tbody></table>
  
          </p><p><a href="#PERLREF">Perl</a>,
          <a href="#SEDREF">sed</a>, and <a href="#AWKREF">awk</a> have far superior string
          parsing facilities. A short <b class="COMMAND">sed</b> or
          <b class="COMMAND">awk</b> <span class="QUOTE">"subroutine"</span> within
          a script (see <a href="#WRAPPER">Section 36.2</a>) is an attractive
          alternative to <b class="COMMAND">expr</b>.</p><p>See <a href="#STRING-MANIPULATION">Section 10.1</a> for more on
                using <b class="COMMAND">expr</b> in string operations.</p></div><div class="SECT1"><hr><h1 class="SECT1"><a name="TIMEDATE"></a>16.3. Time / Date Commands</h1><p></p><div class="VARIABLELIST"><p><b><a name="TDLISTING1"></a>Time/date and timing</b></p><dl><dt><a name="DATEREF"></a><b class="COMMAND">date</b></dt><dd><p>Simply invoked, <b class="COMMAND">date</b> prints the date and
          time to <tt class="FILENAME">stdout</tt>. Where this command gets
          interesting is in its formatting and parsing options.</p><div class="EXAMPLE"><a name="EX51"></a><p><b>Example 16-10. Using <i class="FIRSTTERM">date</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Exercising the 'date' command
  
  echo "The number of days since the year's beginning is `date +%j`."
  # Needs a leading '+' to invoke formatting.
  # %j gives day of year.
  
  echo "The number of seconds elapsed since 01/01/1970 is `date +%s`."
  #  %s yields number of seconds since "UNIX epoch" began,
  #+ but how is this useful?
  
  prefix=temp
  suffix=$(date +%s)  # The "+%s" option to 'date' is GNU-specific.
  filename=$prefix.$suffix
  echo "Temporary filename = $filename"
  #  It's great for creating "unique and random" temp filenames,
  #+ even better than using $$.
  
  # Read the 'date' man page for more formatting options.
  
  exit 0</pre></font></td></tr></tbody></table></div><p>The <tt class="OPTION">-u</tt> option gives the UTC (Universal
          Coordinated Time).</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>date</b></tt>
  <tt class="COMPUTEROUTPUT">Fri Mar 29 21:07:39 MST 2002</tt>
  
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>date -u</b></tt>
  <tt class="COMPUTEROUTPUT">Sat Mar 30 04:07:42 UTC 2002</tt>
          </pre></font></td></tr></tbody></table>
          </p><p>This option facilitates calculating the time between
          different dates.</p><div class="EXAMPLE"><a name="DATECALC"></a><p><b>Example 16-11. <i class="FIRSTTERM">Date</i> calculations</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # date-calc.sh
  # Author: Nathan Coulter
  # Used in ABS Guide with permission (thanks!).
  
  MPHR=60    # Minutes per hour.
  HPD=24     # Hours per day.
  
  diff () {
          printf '%s' $(( $(date -u -d"$TARGET" +%s) -
                          $(date -u -d"$CURRENT" +%s)))
  #                       %d = day of month.
  }
  
  
  CURRENT=$(date -u -d '2007-09-01 17:30:24' '+%F %T.%N %Z')
  TARGET=$(date -u -d'2007-12-25 12:30:00' '+%F %T.%N %Z')
  # %F = full date, %T = %H:%M:%S, %N = nanoseconds, %Z = time zone.
  
  printf '\nIn 2007, %s ' \
         "$(date -d"$CURRENT +
          $(( $(diff) /$MPHR /$MPHR /$HPD / 2 )) days" '+%d %B')" 
  #       %B = name of month                ^ halfway
  printf 'was halfway between %s ' "$(date -d"$CURRENT" '+%d %B')"
  printf 'and %s\n' "$(date -d"$TARGET" '+%d %B')"
  
  printf '\nOn %s at %s, there were\n' \
          $(date -u -d"$CURRENT" +%F) $(date -u -d"$CURRENT" +%T)
  DAYS=$(( $(diff) / $MPHR / $MPHR / $HPD ))
  CURRENT=$(date -d"$CURRENT +$DAYS days" '+%F %T.%N %Z')
  HOURS=$(( $(diff) / $MPHR / $MPHR ))
  CURRENT=$(date -d"$CURRENT +$HOURS hours" '+%F %T.%N %Z')
  MINUTES=$(( $(diff) / $MPHR ))
  CURRENT=$(date -d"$CURRENT +$MINUTES minutes" '+%F %T.%N %Z')
  printf '%s days, %s hours, ' "$DAYS" "$HOURS"
  printf '%s minutes, and %s seconds ' "$MINUTES" "$(diff)"
  printf 'until Christmas Dinner!\n\n'
  
  #  Exercise:
  #  --------
  #  Rewrite the diff () function to accept passed parameters,
  #+ rather than using global variables.</pre></font></td></tr></tbody></table></div><p><a name="DATERANDREF"></a></p><p>The <i class="FIRSTTERM">date</i> command has quite a
      number of <i class="FIRSTTERM">output</i> options. For
      example <tt class="OPTION">%N</tt> gives the nanosecond portion
      of the current time. One interesting use for this is to
      generate random integers.
  
           <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">date +%N | sed -e 's/000$//' -e 's/^0//'
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  #  Strip off leading and trailing zeroes, if present.
  #  Length of generated integer depends on
  #+ how many zeroes stripped off.
  
  # 115281032
  # 63408725
  # 394504284</pre></font></td></tr></tbody></table>
          </p><p>There are many more options (try <b class="COMMAND">man
            date</b>).</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">date +%j
  # Echoes day of the year (days elapsed since January 1).
  
  date +%k%M
  # Echoes hour and minute in 24-hour format, as a single digit string.
  
  
  
  # The 'TZ' parameter permits overriding the default time zone.
  date                 # Mon Mar 28 21:42:16 MST 2005
  TZ=EST date          # Mon Mar 28 23:42:16 EST 2005
  # Thanks, Frank Kannemann and Pete Sjoberg, for the tip.
  
  
  SixDaysAgo=$(date --date='6 days ago')
  OneMonthAgo=$(date --date='1 month ago')  # Four weeks back (not a month!)
  OneYearAgo=$(date --date='1 year ago')</pre></font></td></tr></tbody></table></p><p>See also <a href="#EX58">Example 3-4</a> and <a href="#STOPWATCH">Example A-43</a>.</p></dd><dt><a name="ZDUMPREF"></a><b class="COMMAND">zdump</b></dt><dd><p>Time zone dump: echoes the time in a specified time zone.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>zdump EST</b></tt>
  <tt class="COMPUTEROUTPUT">EST  Tue Sep 18 22:09:22 2001 EST</tt>
          </pre></font></td></tr></tbody></table>
          </p></dd><dt><a name="TIMREF"></a><b class="COMMAND">time</b></dt><dd><p>Outputs verbose timing statistics for executing a command.</p><p><tt class="USERINPUT"><b>time ls -l /</b></tt> gives something
        like this:</p><p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="COMPUTEROUTPUT">real    0m0.067s
   user    0m0.004s
   sys     0m0.005s</tt></pre></font></td></tr></tbody></table>
      </p><p>See also the very similar <a href="#TIMESREF">times</a> command in the previous
        section.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>As of <a href="#BASH2REF">version 2.0</a>
        of Bash, <b class="COMMAND">time</b> became a shell reserved word,
        with slightly altered behavior in a pipeline.</p></td></tr></tbody></table></div></dd><dt><a name="TOUCHREF"></a><b class="COMMAND">touch</b></dt><dd><p>Utility for updating access/modification times of a
          file to current system time or other specified time,
          but also useful for creating a new file. The command
          <tt class="USERINPUT"><b>touch zzz</b></tt> will create a new file
          of zero length, named <tt class="FILENAME">zzz</tt>, assuming
          that <tt class="FILENAME">zzz</tt> did not previously exist.
          Time-stamping empty files in this way is useful for
          storing date information, for example in keeping track of
          modification times on a project.
          </p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">touch</b> command is
          equivalent to <tt class="USERINPUT"><b>: &gt;&gt; newfile</b></tt>
          or <tt class="USERINPUT"><b>&gt;&gt; newfile</b></tt> (for ordinary
          files).</p></td></tr></tbody></table></div><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>Before doing a <a href="#CPREF">cp -u</a>
          (<i class="FIRSTTERM">copy/update</i>), use
          <b class="COMMAND">touch</b> to update the time stamp of files
          you don't wish overwritten.</p><p>As an example, if the directory <tt class="FILENAME">/home/bozo/tax_audit</tt> contains the
          files <tt class="FILENAME">spreadsheet-051606.data</tt>,
          <tt class="FILENAME">spreadsheet-051706.data</tt>, and
          <tt class="FILENAME">spreadsheet-051806.data</tt>, then
          doing a <b class="COMMAND">touch spreadsheet*.data</b>
          will protect these files from being overwritten
          by files with the same names during a
          <b class="COMMAND">cp -u /home/bozo/financial_info/spreadsheet*data
          /home/bozo/tax_audit</b>.</p></td></tr></tbody></table></div></dd><dt><a name="ATREF"></a><b class="COMMAND">at</b></dt><dd><p>The <b class="COMMAND">at</b> job control command executes
          a given set of commands at a specified time. Superficially,
          it resembles <a href="#CRONREF">cron</a>, however,
          <b class="COMMAND">at</b> is chiefly useful for one-time execution
          of a command set.</p><p><tt class="USERINPUT"><b>at 2pm January 15</b></tt> prompts for a set of
          commands to execute at that time. These commands should be
          shell-script compatible, since, for all practical
          purposes, the user is typing in an executable shell
          script a line at a time.	Input terminates with a <a href="#CTLDREF">Ctl-D</a>.</p><p>Using either the <tt class="OPTION">-f</tt> option or input
          redirection (<span class="TOKEN">&lt;</span>), <b class="COMMAND">at</b>
          reads a command list from a file. This file is an
          executable shell script, though it should, of course,
          be non-interactive. Particularly clever is including the
          <a href="#RUNPARTSREF">run-parts</a> command in
          the file to execute a different set of scripts.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>at 2:30 am Friday &lt; at-jobs.list</b></tt>
  <tt class="COMPUTEROUTPUT">job 2 at 2000-10-27 02:30</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="BATCHREF"></a><b class="COMMAND">batch</b></dt><dd><p>The <b class="COMMAND">batch</b> job control command is similar to
          <b class="COMMAND">at</b>, but it runs a command list when the system
          load drops below <tt class="LITERAL">.8</tt>. Like
          <b class="COMMAND">at</b>, it can read commands from a file with the
          <tt class="OPTION">-f</tt> option.</p><p><a name="BATCHPROCREF"></a></p><table class="SIDEBAR" border="1" cellpadding="5"><tbody><tr><td><div class="SIDEBAR"><a name="AEN10811"></a><p></p><p>The concept of <i class="FIRSTTERM">batch processing</i>
                dates back to the era of mainframe computers. It means
                running a set of commands without user intervention.</p><p></p></div></td></tr></tbody></table></dd><dt><a name="CALREF"></a><b class="COMMAND">cal</b></dt><dd><p>Prints a neatly formatted monthly calendar to
          <tt class="FILENAME">stdout</tt>. Will do current year or a large
          range of past and future years.</p></dd><dt><a name="SLEEPREF"></a><b class="COMMAND">sleep</b></dt><dd><p>This is the shell equivalent of a <i class="FIRSTTERM">wait
          loop</i>. It pauses for a specified number of
          seconds, doing nothing. It can be useful for timing or
          in processes running in the background, checking for
          a specific event every so often (polling), as in <a href="#ONLINE">Example 32-6</a>.  <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">sleep 3     # Pauses 3 seconds.</pre></font></td></tr></tbody></table>
        </p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">sleep</b> command defaults to
          seconds, but minute, hours, or days may also be specified.
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">sleep 3 h   # Pauses 3 hours!</pre></font></td></tr></tbody></table>
              </p></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <a href="#WATCHREF">watch</a> command may
          be a better choice than <b class="COMMAND">sleep</b> for running
          commands at timed intervals.</p></td></tr></tbody></table></div></dd><dt><a name="USLEEPREF"></a><b class="COMMAND">usleep</b></dt><dd><p><i class="FIRSTTERM">Microsleep</i> (the
          <i class="FIRSTTERM">u</i> may be read as the Greek
          <i class="FIRSTTERM">mu</i>, or <i class="FIRSTTERM">micro-</i>
          prefix). This is the same as <b class="COMMAND">sleep</b>,
          above, but <span class="QUOTE">"sleeps"</span> in microsecond
          intervals. It can be used for fine-grained timing,
          or for polling an ongoing process at very frequent
          intervals.</p><p>  
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">usleep 30     # Pauses 30 microseconds.</pre></font></td></tr></tbody></table>
        </p><p>This command is part of the Red Hat
        <i class="FIRSTTERM">initscripts / rc-scripts</i> package.</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">usleep</b> command does not
          provide particularly accurate timing, and is therefore
          unsuitable for critical timing loops.</p></td></tr></tbody></table></div></dd><dt><a name="HWCLOCKREF"></a><b class="COMMAND">hwclock</b>, <a name="CLOCKREF"></a><b class="COMMAND">clock</b></dt><dd><p>The <b class="COMMAND">hwclock</b> command accesses or
          adjusts the machine's hardware clock. Some options
          require <i class="FIRSTTERM">root</i> privileges. The
          <tt class="FILENAME">/etc/rc.d/rc.sysinit</tt> startup file
          uses <b class="COMMAND">hwclock</b> to set the system time
          from the hardware clock at bootup.</p><p>The <b class="COMMAND">clock</b> command is a synonym for
          <b class="COMMAND">hwclock</b>.</p></dd></dl></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="TEXTPROC"></a>16.4. Text Processing Commands</h1><p></p><div class="VARIABLELIST"><p><b><a name="TPCOMMANDLISTING1"></a>Commands affecting text and
       text files</b></p><dl><dt><a name="SORTREF"></a><b class="COMMAND">sort</b></dt><dd><p>File sort utility, often used as a filter in a pipe. This
          command sorts a <i class="FIRSTTERM">text stream</i>
          or file forwards or backwards, or according to various
          keys or character positions. Using the <tt class="OPTION">-m</tt>
          option, it merges presorted input files.	The <i class="FIRSTTERM">info
          page</i> lists its many capabilities and options. See
          <a href="#FINDSTRING">Example 11-10</a>, <a href="#SYMLINKS">Example 11-11</a>,
          and <a href="#MAKEDICT">Example A-8</a>.</p></dd><dt><a name="TSORTREF"></a><b class="COMMAND">tsort</b></dt><dd><p><i class="FIRSTTERM">Topological sort</i>, reading in
          pairs of whitespace-separated strings and sorting
          according to input patterns. The original purpose of
          <b class="COMMAND">tsort</b> was to sort a list of dependencies
          for an obsolete version of the <i class="FIRSTTERM">ld</i>
          linker in an <span class="QUOTE">"ancient"</span> version of UNIX.</p><p>The results of a <i class="FIRSTTERM">tsort</i> will usually
          differ markedly from those of the standard
          <b class="COMMAND">sort</b> command, above.</p></dd><dt><a name="UNIQREF"></a><b class="COMMAND">uniq</b></dt><dd><p>This filter removes duplicate lines from a sorted
          file. It is often seen in a pipe coupled with
          <a href="#SORTREF">sort</a>.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">cat list-1 list-2 list-3 | sort | uniq &gt; final.list
  # Concatenates the list files,
  # sorts them,
  # removes duplicate lines,
  # and finally writes the result to an output file.</pre></font></td></tr></tbody></table></p><p>The useful <tt class="OPTION">-c</tt> option prefixes each line of
           the input file with its number of occurrences.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cat testfile</b></tt>
  <tt class="COMPUTEROUTPUT">This line occurs only once.
   This line occurs twice.
   This line occurs twice.
   This line occurs three times.
   This line occurs three times.
   This line occurs three times.</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>uniq -c testfile</b></tt>
  <tt class="COMPUTEROUTPUT">      1 This line occurs only once.
         2 This line occurs twice.
         3 This line occurs three times.</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>sort testfile | uniq -c | sort -nr</b></tt>
  <tt class="COMPUTEROUTPUT">      3 This line occurs three times.
         2 This line occurs twice.
         1 This line occurs only once.</tt>
          </pre></font></td></tr></tbody></table>
         </p><p>The <tt class="USERINPUT"><b>sort INPUTFILE | uniq -c | sort -nr</b></tt>
           command string produces a <i class="FIRSTTERM">frequency
           of occurrence</i> listing on the
           <tt class="FILENAME">INPUTFILE</tt> file (the
           <tt class="OPTION">-nr</tt> options to <b class="COMMAND">sort</b>
           cause a reverse numerical sort). This template finds
           use in analysis of log files and dictionary lists, and
           wherever the lexical structure of a document needs to
           be examined.</p><div class="EXAMPLE"><a name="WF"></a><p><b>Example 16-12. Word Frequency Analysis</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # wf.sh: Crude word frequency analysis on a text file.
  # This is a more efficient version of the "wf2.sh" script.
  
  
  # Check for input file on command-line.
  ARGS=1
  E_BADARGS=85
  E_NOFILE=86
  
  if [ $# -ne "$ARGS" ]  # Correct number of arguments passed to script?
  then
    echo "Usage: `basename $0` filename"
    exit $E_BADARGS
  fi
  
  if [ ! -f "$1" ]       # Check if file exists.
  then
    echo "File \"$1\" does not exist."
    exit $E_NOFILE
  fi
  
  
  
  ########################################################
  # main ()
  sed -e 's/\.//g'  -e 's/\,//g' -e 's/ /\
  /g' "$1" | tr 'A-Z' 'a-z' | sort | uniq -c | sort -nr
  #                           =========================
  #                            Frequency of occurrence
  
  #  Filter out periods and commas, and
  #+ change space between words to linefeed,
  #+ then shift characters to lowercase, and
  #+ finally prefix occurrence count and sort numerically.
  
  #  Arun Giridhar suggests modifying the above to:
  #  . . . | sort | uniq -c | sort +1 [-f] | sort +0 -nr
  #  This adds a secondary sort key, so instances of
  #+ equal occurrence are sorted alphabetically.
  #  As he explains it:
  #  "This is effectively a radix sort, first on the
  #+ least significant column
  #+ (word or string, optionally case-insensitive)
  #+ and last on the most significant column (frequency)."
  #
  #  As Frank Wang explains, the above is equivalent to
  #+       . . . | sort | uniq -c | sort +0 -nr
  #+ and the following also works:
  #+       . . . | sort | uniq -c | sort -k1nr -k
  ########################################################
  
  exit 0
  
  # Exercises:
  # ---------
  # 1) Add 'sed' commands to filter out other punctuation,
  #+   such as semicolons.
  # 2) Modify the script to also filter out multiple spaces and
  #+   other whitespace.</pre></font></td></tr></tbody></table></div><p>	       <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cat testfile</b></tt>
  <tt class="COMPUTEROUTPUT">This line occurs only once.
   This line occurs twice.
   This line occurs twice.
   This line occurs three times.
   This line occurs three times.
   This line occurs three times.</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>./wf.sh testfile</b></tt>
  <tt class="COMPUTEROUTPUT">      6 this
         6 occurs
         6 line
         3 times
         3 three
         2 twice
         1 only
         1 once</tt>
           </pre></font></td></tr></tbody></table>
         </p></dd><dt><a name="EXPANDREF"></a><b class="COMMAND">expand</b>, <b class="COMMAND">unexpand</b></dt><dd><p>The <b class="COMMAND">expand</b> filter converts tabs to
          spaces. It is often used in a <a href="#PIPEREF">pipe</a>.</p><p>The <b class="COMMAND">unexpand</b> filter
          converts spaces to tabs. This reverses the effect of
          <b class="COMMAND">expand</b>.</p></dd><dt><a name="CUTREF"></a><b class="COMMAND">cut</b></dt><dd><p>A tool for extracting <a href="#FIELDREF">fields</a> from files. It is similar
          to the <tt class="USERINPUT"><b>print $N</b></tt> command set in <a href="#AWKREF">awk</a>, but more limited. It may be
          simpler to use <i class="FIRSTTERM">cut</i> in a script than
          <i class="FIRSTTERM">awk</i>. Particularly important are the
          <tt class="OPTION">-d</tt> (delimiter) and <tt class="OPTION">-f</tt>
          (field specifier) options.</p><p>Using <b class="COMMAND">cut</b> to obtain a listing of the
          mounted filesystems: 
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">cut -d ' ' -f1,2 /etc/mtab</pre></font></td></tr></tbody></table></p><p>Using <b class="COMMAND">cut</b> to list the OS and kernel version:
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">uname -a | cut -d" " -f1,3,11,12</pre></font></td></tr></tbody></table></p><p>Using <b class="COMMAND">cut</b> to extract message headers from
          an e-mail folder:
  
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>grep '^Subject:' read-messages | cut -c10-80</b></tt>
  <tt class="COMPUTEROUTPUT">Re: Linux suitable for mission-critical apps?
   MAKE MILLIONS WORKING AT HOME!!!
   Spam complaint
   Re: Spam complaint</tt></pre></font></td></tr></tbody></table>
        </p><p>Using <b class="COMMAND">cut</b> to parse a file:
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># List all the users in /etc/passwd.
  
  FILENAME=/etc/passwd
  
  for user in $(cut -d: -f1 $FILENAME)
  do
    echo $user
  done
  
  # Thanks, Oleg Philon for suggesting this.</pre></font></td></tr></tbody></table></p><p><tt class="USERINPUT"><b>cut -d ' ' -f2,3 filename</b></tt> is equivalent to
          <tt class="USERINPUT"><b>awk -F'[ ]' '{ print $2, $3 }' filename</b></tt></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>It is even possible to specify a linefeed as a
          delimiter. The trick is to actually embed a linefeed
          (<b class="KEYCAP">RETURN</b>) in the command sequence.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cut -d'
   ' -f3,7,19 testfile</b></tt>
  <tt class="COMPUTEROUTPUT">This is line 3 of testfile.
   This is line 7 of testfile.
   This is line 19 of testfile.</tt>
          </pre></font></td></tr></tbody></table>
      </p><p>Thank you, Jaka Kranjc, for pointing this out.</p></td></tr></tbody></table></div><p>See also <a href="#BASE">Example 16-48</a>.</p></dd><dt><a name="PASTEREF"></a><b class="COMMAND">paste</b></dt><dd><p>Tool for merging together different files into a single,
          multi-column file.  In combination with
          <a href="#CUTREF">cut</a>, useful for creating system log
          files.
        </p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cat items</b></tt>
  <tt class="COMPUTEROUTPUT">alphabet blocks
   building blocks
   cables</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cat prices</b></tt>
  <tt class="COMPUTEROUTPUT">$1.00/dozen
   $2.50 ea.
   $3.75</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>paste items prices</b></tt>
  <tt class="COMPUTEROUTPUT">alphabet blocks $1.00/dozen
   building blocks $2.50 ea.
   cables  $3.75</tt></pre></font></td></tr></tbody></table>
      </p></dd><dt><a name="JOINREF"></a><b class="COMMAND">join</b></dt><dd><p>Consider this a special-purpose cousin of
          <b class="COMMAND">paste</b>. This powerful utility allows
          merging two files in a meaningful fashion, which essentially
          creates a simple version of a relational database.</p><p>The <b class="COMMAND">join</b> command operates on
          exactly two files, but pastes together only those lines
          with a common tagged <a href="#FIELDREF">field</a>
          (usually a numerical label), and writes the result to
          <tt class="FILENAME">stdout</tt>.  The files to be joined should
          be sorted according to the tagged field for the matchups
          to work properly.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">File: 1.data
  
  100 Shoes
  200 Laces
  300 Socks</pre></font></td></tr></tbody></table></p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">File: 2.data
  
  100 $40.00
  200 $1.00
  300 $2.00</pre></font></td></tr></tbody></table></p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>join 1.data 2.data</b></tt>
  <tt class="COMPUTEROUTPUT">File: 1.data 2.data
  
   100 Shoes $40.00
   200 Laces $1.00
   300 Socks $2.00</tt>
          </pre></font></td></tr></tbody></table>
        </p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The tagged field appears only once in the
          output.</p></td></tr></tbody></table></div></dd><dt><a name="HEADREF"></a><b class="COMMAND">head</b></dt><dd><p>lists the beginning of a file to <tt class="FILENAME">stdout</tt>.
          The default is <tt class="LITERAL">10</tt> lines, but a different
          number can be specified. The command has a number of
          interesting options.
  
        </p><div class="EXAMPLE"><a name="SCRIPTDETECTOR"></a><p><b>Example 16-13. Which files are scripts?</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # script-detector.sh: Detects scripts within a directory.
  
  TESTCHARS=2    # Test first 2 characters.
  SHABANG='#!'   # Scripts begin with a "sha-bang."
  
  for file in *  # Traverse all the files in current directory.
  do
    if [[ `head -c$TESTCHARS "$file"` = "$SHABANG" ]]
    #      head -c2                      #!
    #  The '-c' option to "head" outputs a specified
    #+ number of characters, rather than lines (the default).
    then
      echo "File \"$file\" is a script."
    else
      echo "File \"$file\" is *not* a script."
    fi
  done
    
  exit 0
  
  #  Exercises:
  #  ---------
  #  1) Modify this script to take as an optional argument
  #+    the directory to scan for scripts
  #+    (rather than just the current working directory).
  #
  #  2) As it stands, this script gives "false positives" for
  #+    Perl, awk, and other scripting language scripts.
  #     Correct this.</pre></font></td></tr></tbody></table></div>	    
  
        <div class="EXAMPLE"><a name="RND"></a><p><b>Example 16-14. Generating 10-digit random numbers</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # rnd.sh: Outputs a 10-digit random number
  
  # Script by Stephane Chazelas.
  
  head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
  
  
  # =================================================================== #
  
  # Analysis
  # --------
  
  # head:
  # -c4 option takes first 4 bytes.
  
  # od:
  # -N4 option limits output to 4 bytes.
  # -tu4 option selects unsigned decimal format for output.
  
  # sed: 
  # -n option, in combination with "p" flag to the "s" command,
  # outputs only matched lines.
  
  
  
  # The author of this script explains the action of 'sed', as follows.
  
  # head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
  # ----------------------------------&gt; |
  
  # Assume output up to "sed" --------&gt; |
  # is 0000000 1198195154\n
  
  #  sed begins reading characters: 0000000 1198195154\n.
  #  Here it finds a newline character,
  #+ so it is ready to process the first line (0000000 1198195154).
  #  It looks at its &lt;range&gt;&lt;action&gt;s. The first and only one is
  
  #   range     action
  #   1         s/.* //p
  
  #  The line number is in the range, so it executes the action:
  #+ tries to substitute the longest string ending with a space in the line
  #  ("0000000 ") with nothing (//), and if it succeeds, prints the result
  #  ("p" is a flag to the "s" command here, this is different
  #+ from the "p" command).
  
  #  sed is now ready to continue reading its input. (Note that before
  #+ continuing, if -n option had not been passed, sed would have printed
  #+ the line once again).
  
  #  Now, sed reads the remainder of the characters, and finds the
  #+ end of the file.
  #  It is now ready to process its 2nd line (which is also numbered '$' as
  #+ it's the last one).
  #  It sees it is not matched by any &lt;range&gt;, so its job is done.
  
  #  In few word this sed commmand means:
  #  "On the first line only, remove any character up to the right-most space,
  #+ then print it."
  
  # A better way to do this would have been:
  #           sed -e 's/.* //;q'
  
  # Here, two &lt;range&gt;&lt;action&gt;s (could have been written
  #           sed -e 's/.* //' -e q):
  
  #   range                    action
  #   nothing (matches line)   s/.* //
  #   nothing (matches line)   q (quit)
  
  #  Here, sed only reads its first line of input.
  #  It performs both actions, and prints the line (substituted) before
  #+ quitting (because of the "q" action) since the "-n" option is not passed.
  
  # =================================================================== #
  
  # An even simpler altenative to the above one-line script would be:
  #           head -c4 /dev/urandom| od -An -tu4
  
  exit</pre></font></td></tr></tbody></table></div>	    
  
          See also <a href="#EX52">Example 16-39</a>.<p></p></dd><dt><a name="TAILREF"></a><b class="COMMAND">tail</b></dt><dd><p>lists the (tail) end of a file to <tt class="FILENAME">stdout</tt>.
          The default is <tt class="LITERAL">10</tt> lines, but this can
          be changed with the <tt class="OPTION">-n</tt> option.
          Commonly used to keep track of
          changes to a system logfile, using the <tt class="OPTION">-f</tt>
          option, which outputs lines appended to the file.</p><div class="EXAMPLE"><a name="EX12"></a><p><b>Example 16-15. Using <i class="FIRSTTERM">tail</i> to monitor the system log</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  filename=sys.log
  
  cat /dev/null &gt; $filename; echo "Creating / cleaning out file."
  #  Creates the file if it does not already exist,
  #+ and truncates it to zero length if it does.
  #  : &gt; filename   and   &gt; filename also work.
  
  tail /var/log/messages &gt; $filename  
  # /var/log/messages must have world read permission for this to work.
  
  echo "$filename contains tail end of system log."
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>To list a specific line of a text file,
            <a href="#PIPEREF">pipe</a> the output of
            <b class="COMMAND">head</b> to <b class="COMMAND">tail -n 1</b>.
      For example <tt class="USERINPUT"><b>head -n 8 database.txt | tail
      -n 1</b></tt> lists the 8th line of the file
      <tt class="FILENAME">database.txt</tt>.</p><p>To set a variable to a given block of a text file:
            <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">var=$(head -n $m $filename | tail -n $n)
  
  # filename = name of file
  # m = from beginning of file, number of lines to end of block
  # n = number of lines to set variable to (trim from end of block)</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>Newer implementations of <b class="COMMAND">tail</b>
            deprecate the older <b class="COMMAND">tail -$LINES
            filename</b> usage. The standard <b class="COMMAND">tail -n $LINES
            filename</b> is correct.</p></td></tr></tbody></table></div><p>See also <a href="#EX41">Example 16-5</a>, <a href="#EX52">Example 16-39</a> and
      <a href="#ONLINE">Example 32-6</a>.</p></dd><dt><a name="GREPREF"></a><b class="COMMAND">grep</b></dt><dd><p>A multi-purpose file search tool that uses
          <a href="#REGEXREF">Regular Expressions</a>.
          It was originally a command/filter in the
          venerable <b class="COMMAND">ed</b> line editor:
          <tt class="USERINPUT"><b>g/re/p</b></tt> -- <i class="FIRSTTERM">global -
          regular expression - print</i>.</p><p></p><p><b class="COMMAND">grep</b>   <tt class="REPLACEABLE"><i>pattern</i></tt>  [<tt class="REPLACEABLE"><i>file</i></tt>...]</p>Search the target file(s) for
          occurrences of <tt class="REPLACEABLE"><i>pattern</i></tt>, where
          <tt class="REPLACEABLE"><i>pattern</i></tt> may be literal text
          or a Regular Expression.<p></p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>grep '[rst]ystem.$' osinfo.txt</b></tt>
  <tt class="COMPUTEROUTPUT">The GPL governs the distribution of the Linux operating system.</tt>
          </pre></font></td></tr></tbody></table>
          </p><p>If no target file(s) specified, <b class="COMMAND">grep</b>
          works as a filter on <tt class="FILENAME">stdout</tt>, as in
          a <a href="#PIPEREF">pipe</a>.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ps ax | grep clock</b></tt>
  <tt class="COMPUTEROUTPUT">765 tty1     S      0:00 xclock
   901 pts/1    S      0:00 grep clock</tt>
          </pre></font></td></tr></tbody></table>
          </p><p>The <tt class="OPTION">-i</tt> option causes a case-insensitive
          search.</p><p>The <tt class="OPTION">-w</tt> option matches only whole
          words.</p><p>The <tt class="OPTION">-l</tt> option lists only the files in which
          matches were found, but not the matching lines.</p><p>The <tt class="OPTION">-r</tt> (recursive) option searches files in
          the current working directory and all subdirectories below
          it.</p><p>The <tt class="OPTION">-n</tt> option lists the matching lines,
          together with line numbers.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>grep -n Linux osinfo.txt</b></tt>
  <tt class="COMPUTEROUTPUT">2:This is a file containing information about Linux.
   6:The GPL governs the distribution of the Linux operating system.</tt>
          </pre></font></td></tr></tbody></table>
          </p><p>The <tt class="OPTION">-v</tt> (or <tt class="OPTION">--invert-match</tt>)
          option <i class="FIRSTTERM">filters out</i> matches.
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">grep pattern1 *.txt | grep -v pattern2
  
  # Matches all lines in "*.txt" files containing "pattern1",
  # but ***not*** "pattern2".	      </pre></font></td></tr></tbody></table></p><p>The <tt class="OPTION">-c</tt> (<tt class="OPTION">--count</tt>)
          option gives a numerical count of matches, rather than
          actually listing the matches.
  
            <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">grep -c txt *.sgml   # (number of occurrences of "txt" in "*.sgml" files)
  
  
  #   grep -cz .
  #            ^ dot
  # means count (-c) zero-separated (-z) items matching "."
  # that is, non-empty ones (containing at least 1 character).
  # 
  printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz .     # 3
  printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '$'   # 5
  printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '^'   # 5
  #
  printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -c '$'    # 9
  # By default, newline chars (\n) separate items to match. 
  
  # Note that the -z option is GNU "grep" specific.
  
  
  # Thanks, S.C.</pre></font></td></tr></tbody></table>
              </p><p>The <tt class="OPTION">--color</tt> (or <tt class="OPTION">--colour</tt>)
          option marks the matching string in color (on the console
          or in an <i class="FIRSTTERM">xterm</i> window). Since
          <i class="FIRSTTERM">grep</i> prints out each entire line
          containing the matching pattern, this lets you see exactly
          <em>what</em> is being matched. See also
          the <tt class="OPTION">-o</tt> option, which shows only the
          matching portion of the line(s).</p><div class="EXAMPLE"><a name="FROMSH"></a><p><b>Example 16-16. Printing out the <i class="FIRSTTERM">From</i> lines in
            stored e-mail messages</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # from.sh
  
  #  Emulates the useful 'from' utility in Solaris, BSD, etc.
  #  Echoes the "From" header line in all messages
  #+ in your e-mail directory.
  
  
  MAILDIR=~/mail/*               #  No quoting of variable. Why?
  # Maybe check if-exists $MAILDIR:   if [ -d $MAILDIR ] . . .
  GREP_OPTS="-H -A 5 --color"    #  Show file, plus extra context lines
                                 #+ and display "From" in color.
  TARGETSTR="^From"              # "From" at beginning of line.
  
  for file in $MAILDIR           #  No quoting of variable.
  do
    grep $GREP_OPTS "$TARGETSTR" "$file"
    #    ^^^^^^^^^^              #  Again, do not quote this variable.
    echo
  done
  
  exit $?
  
  #  You might wish to pipe the output of this script to 'more'
  #+ or redirect it to a file . . .</pre></font></td></tr></tbody></table></div><p>When invoked with more than one target file given,
          <b class="COMMAND">grep</b> specifies which file contains
          matches.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>grep Linux osinfo.txt misc.txt</b></tt>
  <tt class="COMPUTEROUTPUT">osinfo.txt:This is a file containing information about Linux.
   osinfo.txt:The GPL governs the distribution of the Linux operating system.
   misc.txt:The Linux operating system is steadily gaining in popularity.</tt>
          </pre></font></td></tr></tbody></table>
        </p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>To force <b class="COMMAND">grep</b> to show the filename
          when searching only one target file, simply give
          <tt class="FILENAME">/dev/null</tt> as the second file.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>grep Linux osinfo.txt /dev/null</b></tt>
  <tt class="COMPUTEROUTPUT">osinfo.txt:This is a file containing information about Linux.
   osinfo.txt:The GPL governs the distribution of the Linux operating system.</tt>
          </pre></font></td></tr></tbody></table>
        </p></td></tr></tbody></table></div><p>If there is a successful match, <b class="COMMAND">grep</b>
          returns an <a href="#EXITSTATUSREF">exit status</a>
          of 0, which makes it useful in a condition test in a
          script, especially in combination with the <tt class="OPTION">-q</tt>
          option to suppress output.
            <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">SUCCESS=0                      # if grep lookup succeeds
  word=Linux
  filename=data.file
  
  grep -q "$word" "$filename"    #  The "-q" option
                                 #+ causes nothing to echo to stdout.
  if [ $? -eq $SUCCESS ]
  # if grep -q "$word" "$filename"   can replace lines 5 - 7.
  then
    echo "$word found in $filename"
  else
    echo "$word not found in $filename"
  fi</pre></font></td></tr></tbody></table>
              </p><p><a href="#ONLINE">Example 32-6</a> demonstrates how to use
          <b class="COMMAND">grep</b> to search for a word pattern in
          a system logfile.</p><div class="EXAMPLE"><a name="GRP"></a><p><b>Example 16-17. Emulating <i class="FIRSTTERM">grep</i> in a script</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # grp.sh: Rudimentary reimplementation of grep.
  
  E_BADARGS=85
  
  if [ -z "$1" ]    # Check for argument to script.
  then
    echo "Usage: `basename $0` pattern"
    exit $E_BADARGS
  fi  
  
  echo
  
  for file in *     # Traverse all files in $PWD.
  do
    output=$(sed -n /"$1"/p $file)  # Command substitution.
  
    if [ ! -z "$output" ]           # What happens if "$output" is not quoted?
    then
      echo -n "$file: "
      echo "$output"
    fi              #  sed -ne "/$1/s|^|${file}: |p"  is equivalent to above.
  
    echo
  done  
  
  echo
  
  exit 0
  
  # Exercises:
  # ---------
  # 1) Add newlines to output, if more than one match in any given file.
  # 2) Add features.</pre></font></td></tr></tbody></table></div><p>How can <b class="COMMAND">grep</b> search for two (or
          more) separate patterns? What if you want
          <b class="COMMAND">grep</b> to display all lines in a file
          or files that contain both <span class="QUOTE">"pattern1"</span>
          <em>and</em> <span class="QUOTE">"pattern2"</span>?</p><p>One method is to <a href="#PIPEREF">pipe</a> the result of <b class="COMMAND">grep
          pattern1</b> to <b class="COMMAND">grep pattern2</b>.</p><p>For example, given the following file:</p><p>	    <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Filename: tstfile
  
  This is a sample file.
  This is an ordinary text file.
  This file does not contain any unusual text.
  This file is not unusual.
  Here is some text.</pre></font></td></tr></tbody></table>
              </p><p>Now, let's search this file for lines containing
          <em>both</em> <span class="QUOTE">"file"</span> and
          <span class="QUOTE">"text"</span> . . . </p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>grep file tstfile</b></tt>
  <tt class="COMPUTEROUTPUT"># Filename: tstfile
   This is a sample file.
   This is an ordinary text file.
   This file does not contain any unusual text.
   This file is not unusual.</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>grep file tstfile | grep text</b></tt>
  <tt class="COMPUTEROUTPUT">This is an ordinary text file.
   This file does not contain any unusual text.</tt></pre></font></td></tr></tbody></table><p>Now, for an interesting recreational use
          of <i class="FIRSTTERM">grep</i> . . .</p><div class="EXAMPLE"><a name="CWSOLVER"></a><p><b>Example 16-18. Crossword puzzle solver</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # cw-solver.sh
  # This is actually a wrapper around a one-liner (line 46).
  
  #  Crossword puzzle and anagramming word game solver.
  #  You know *some* of the letters in the word you're looking for,
  #+ so you need a list of all valid words
  #+ with the known letters in given positions.
  #  For example: w...i....n
  #               1???5????10
  # w in position 1, 3 unknowns, i in the 5th, 4 unknowns, n at the end.
  # (See comments at end of script.)
  
  
  E_NOPATT=71
  DICT=/usr/share/dict/word.lst
  #                    ^^^^^^^^   Looks for word list here.
  #  ASCII word list, one word per line.
  #  If you happen to need an appropriate list,
  #+ download the author's "yawl" word list package.
  #  http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz
  #  or
  #  http://bash.deta.in/yawl-0.3.2.tar.gz
  
  
  if [ -z "$1" ]   #  If no word pattern specified
  then             #+ as a command-line argument . . .
    echo           #+ . . . then . . .
    echo "Usage:"  #+ Usage message.
    echo
    echo ""$0" \"pattern,\""
    echo "where \"pattern\" is in the form"
    echo "xxx..x.x..."
    echo
    echo "The x's represent known letters,"
    echo "and the periods are unknown letters (blanks)."
    echo "Letters and periods can be in any position."
    echo "For example, try:   sh cw-solver.sh w...i....n"
    echo
    exit $E_NOPATT
  fi
  
  echo
  # ===============================================
  # This is where all the work gets done.
  grep ^"$1"$ "$DICT"   # Yes, only one line!
  #    |    |
  # ^ is start-of-word regex anchor.
  # $ is end-of-word regex anchor.
  
  #  From _Stupid Grep Tricks_, vol. 1,
  #+ a book the ABS Guide author may yet get around
  #+ to writing . . . one of these days . . .
  # ===============================================
  echo
  
  
  exit $?  # Script terminates here.
  #  If there are too many words generated,
  #+ redirect the output to a file.
  
  $ sh cw-solver.sh w...i....n
  
  wellington
  workingman
  workingmen</pre></font></td></tr></tbody></table></div><p><a name="EGREPREF"></a><b class="COMMAND">egrep</b>
          -- <i class="FIRSTTERM">extended grep</i> -- is the same
          as <b class="COMMAND">grep -E</b>. This uses a somewhat
          different, extended set of <a href="#REGEXREF">Regular
          Expressions</a>, which can make the search a bit more
          flexible. It also allows the boolean |
          (<i class="FIRSTTERM">or</i>) operator.
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash $ </tt><tt class="USERINPUT"><b>egrep 'matches|Matches' file.txt</b></tt>
  <tt class="COMPUTEROUTPUT">Line 1 matches.
   Line 3 Matches.
   Line 4 contains matches, but also Matches</tt>
                </pre></font></td></tr></tbody></table>
          </p><p><a name="FGREPREF"></a><b class="COMMAND">fgrep</b> --
          <i class="FIRSTTERM">fast grep</i> -- is the same as
          <b class="COMMAND">grep -F</b>. It does a literal string search
          (no <a href="#REGEXREF">Regular Expressions</a>),
          which generally speeds things up a bit.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>On some Linux distros, <b class="COMMAND">egrep</b> and
          <b class="COMMAND">fgrep</b> are symbolic links to, or aliases for
          <b class="COMMAND">grep</b>, but invoked with the
          <tt class="OPTION">-E</tt> and <tt class="OPTION">-F</tt> options,
          respectively.</p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="DICTLOOKUP"></a><p><b>Example 16-19. Looking up definitions in <i class="CITETITLE">Webster's 1913 Dictionary</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # dict-lookup.sh
  
  #  This script looks up definitions in the 1913 Webster's Dictionary.
  #  This Public Domain dictionary is available for download
  #+ from various sites, including
  #+ Project Gutenberg (http://www.gutenberg.org/etext/247).
  #
  #  Convert it from DOS to UNIX format (with only LF at end of line)
  #+ before using it with this script.
  #  Store the file in plain, uncompressed ASCII text.
  #  Set DEFAULT_DICTFILE variable below to path/filename.
  
  
  E_BADARGS=85
  MAXCONTEXTLINES=50                        # Maximum number of lines to show.
  DEFAULT_DICTFILE="/usr/share/dict/webster1913-dict.txt"
                                            # Default dictionary file pathname.
                                            # Change this as necessary.
  #  Note:
  #  ----
  #  This particular edition of the 1913 Webster's
  #+ begins each entry with an uppercase letter
  #+ (lowercase for the remaining characters).
  #  Only the *very first line* of an entry begins this way,
  #+ and that's why the search algorithm below works.
  
  
  
  if [[ -z $(echo "$1" | sed -n '/^[A-Z]/p') ]]
  #  Must at least specify word to look up, and
  #+ it must start with an uppercase letter.
  then
    echo "Usage: `basename $0` Word-to-define [dictionary-file]"
    echo
    echo "Note: Word to look up must start with capital letter,"
    echo "with the rest of the word in lowercase."
    echo "--------------------------------------------"
    echo "Examples: Abandon, Dictionary, Marking, etc."
    exit $E_BADARGS
  fi
  
  
  if [ -z "$2" ]                            #  May specify different dictionary
                                            #+ as an argument to this script.
  then
    dictfile=$DEFAULT_DICTFILE
  else
    dictfile="$2"
  fi
  
  # ---------------------------------------------------------
  Definition=$(fgrep -A $MAXCONTEXTLINES "$1 \\" "$dictfile")
  #                  Definitions in form "Word \..."
  #
  #  And, yes, "fgrep" is fast enough
  #+ to search even a very large text file.
  
  
  # Now, snip out just the definition block.
  
  echo "$Definition" |
  sed -n '1,/^[A-Z]/p' |
  #  Print from first line of output
  #+ to the first line of the next entry.
  sed '$d' | sed '$d'
  #  Delete last two lines of output
  #+ (blank line and first line of next entry).
  # ---------------------------------------------------------
  
  exit $?
  
  # Exercises:
  # ---------
  # 1)  Modify the script to accept any type of alphabetic input
  #   + (uppercase, lowercase, mixed case), and convert it
  #   + to an acceptable format for processing.
  #
  # 2)  Convert the script to a GUI application,
  #   + using something like 'gdialog' or 'zenity' . . .
  #     The script will then no longer take its argument(s)
  #   + from the command-line.
  #
  # 3)  Modify the script to parse one of the other available
  #   + Public Domain Dictionaries, such as the U.S. Census Bureau Gazetteer.</pre></font></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>See also <a href="#QKY">Example A-41</a> for an example
          of speedy <i class="FIRSTTERM">fgrep</i> lookup on a large
          text file.</p></td></tr></tbody></table></div><p><a name="AGREPREF"></a></p><p><b class="COMMAND">agrep</b> (<i class="FIRSTTERM">approximate
          grep</i>) extends the capabilities of
          <b class="COMMAND">grep</b> to approximate matching. The search
          string may differ by a specified number of characters
          from the resulting matches. This utility is not part of
          the core Linux distribution.</p><p><a name="ZEGREPREF"></a></p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>To search compressed files, use
          <b class="COMMAND">zgrep</b>, <b class="COMMAND">zegrep</b>, or
          <b class="COMMAND">zfgrep</b>. These also work on non-compressed
          files, though slower than plain <b class="COMMAND">grep</b>,
          <b class="COMMAND">egrep</b>, <b class="COMMAND">fgrep</b>.
          They are handy for searching through a mixed set of files,
          some compressed, some not.</p><p><a name="BZGREPREF"></a></p><p>To search <a href="#BZIPREF">bzipped</a>
          files, use <b class="COMMAND">bzgrep</b>.</p></td></tr></tbody></table></div></dd><dt><a name="LOOKREF"></a><b class="COMMAND">look</b></dt><dd><p>The command <b class="COMMAND">look</b> works like
          <b class="COMMAND">grep</b>, but does a lookup on
          a <span class="QUOTE">"dictionary,"</span> a sorted word list.
          By default, <b class="COMMAND">look</b> searches for a match
          in <tt class="FILENAME">/usr/dict/words</tt>, but a different
          dictionary file may be specified.</p><div class="EXAMPLE"><a name="LOOKUP"></a><p><b>Example 16-20. Checking words in a list for validity</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # lookup: Does a dictionary lookup on each word in a data file.
  
  file=words.data  # Data file from which to read words to test.
  
  echo
  echo "Testing file $file"
  echo
  
  while [ "$word" != end ]  # Last word in data file.
  do               # ^^^
    read word      # From data file, because of redirection at end of loop.
    look $word &gt; /dev/null  # Don't want to display lines in dictionary file.
    #  Searches for words in the file /usr/share/dict/words
    #+ (usually a link to linux.words).
    lookup=$?      # Exit status of 'look' command.
  
    if [ "$lookup" -eq 0 ]
    then
      echo "\"$word\" is valid."
    else
      echo "\"$word\" is invalid."
    fi  
  
  done &lt;"$file"    # Redirects stdin to $file, so "reads" come from there.
  
  echo
  
  exit 0
  
  # ----------------------------------------------------------------
  # Code below line will not execute because of "exit" command above.
  
  
  # Stephane Chazelas proposes the following, more concise alternative:
  
  while read word &amp;&amp; [[ $word != end ]]
  do if look "$word" &gt; /dev/null
     then echo "\"$word\" is valid."
     else echo "\"$word\" is invalid."
     fi
  done &lt;"$file"
  
  exit 0</pre></font></td></tr></tbody></table></div></dd><dt><b class="COMMAND">sed</b>, <b class="COMMAND">awk</b></dt><dd><p>Scripting languages especially suited for parsing text
          files and command output. May be embedded singly or in
          combination in pipes and shell scripts.</p></dd><dt><b class="COMMAND"><a href="#SEDREF">sed</a></b></dt><dd><p>Non-interactive <span class="QUOTE">"stream editor"</span>, permits using
          many <b class="COMMAND">ex</b> commands in <a href="#BATCHPROCREF">batch</a> mode. It finds many
          uses in shell scripts.</p></dd><dt><b class="COMMAND"><a href="#AWKREF">awk</a></b></dt><dd><p>Programmable file extractor and formatter, good for
          manipulating and/or extracting <a href="#FIELDREF">fields</a> (columns) in structured
          text files. Its syntax is similar to C.</p></dd><dt><a name="WCREF"></a><b class="COMMAND">wc</b></dt><dd><p><i class="FIRSTTERM">wc</i> gives a <span class="QUOTE">"word
          count"</span> on a file or I/O stream:
  
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash $ </tt><tt class="USERINPUT"><b>wc /usr/share/doc/sed-4.1.2/README</b></tt>
  <tt class="COMPUTEROUTPUT">13  70  447 README</tt>
  [13 lines  70 words  447 characters]</pre></font></td></tr></tbody></table></p><p><tt class="USERINPUT"><b>wc -w</b></tt> gives only the word count.</p><p><tt class="USERINPUT"><b>wc -l</b></tt> gives only the line count.</p><p><tt class="USERINPUT"><b>wc -c</b></tt> gives only the byte count.</p><p><tt class="USERINPUT"><b>wc -m</b></tt> gives only the character count.</p><p><tt class="USERINPUT"><b>wc -L</b></tt> gives only the length of the longest line.</p><p>Using <b class="COMMAND">wc</b> to count how many
        <tt class="FILENAME">.txt</tt> files are in current working directory:
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">$ ls *.txt | wc -l
  #  Will work as long as none of the "*.txt" files
  #+ have a linefeed embedded in their name.
  
  #  Alternative ways of doing this are:
  #      find . -maxdepth 1 -name \*.txt -print0 | grep -cz .
  #      (shopt -s nullglob; set -- *.txt; echo $#)
  
  #  Thanks, S.C.</pre></font></td></tr></tbody></table>
        </p><p>Using <b class="COMMAND">wc</b> to total up the size of all the
          files whose names begin with letters in the range d - h
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>wc [d-h]* | grep total | awk '{print $3}'</b></tt>
  <tt class="COMPUTEROUTPUT">71832</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>Using <b class="COMMAND">wc</b> to count the instances of the
          word <span class="QUOTE">"Linux"</span> in the main source file for
          this book.
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>grep Linux abs-book.sgml | wc -l</b></tt>
  <tt class="COMPUTEROUTPUT">138</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>See also <a href="#EX52">Example 16-39</a> and <a href="#REDIR4">Example 20-8</a>.</p><p>Certain commands include some of the
          functionality of <b class="COMMAND">wc</b> as options.
          
        <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">... | grep foo | wc -l
  # This frequently used construct can be more concisely rendered.
  
  ... | grep -c foo
  # Just use the "-c" (or "--count") option of grep.
  
  # Thanks, S.C.</pre></font></td></tr></tbody></table></p></dd><dt><a name="TRREF"></a><b class="COMMAND">tr</b></dt><dd><p>character translation filter.</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p><a href="#UCREF">Must use quoting and/or
          brackets</a>, as appropriate. Quotes prevent the
          shell from reinterpreting the special characters in
          <b class="COMMAND">tr</b> command sequences. Brackets should be
          quoted to prevent expansion by the shell.  </p></td></tr></tbody></table></div><p>Either <tt class="USERINPUT"><b>tr "A-Z" "*" &lt;filename</b></tt>
          or <tt class="USERINPUT"><b>tr A-Z \* &lt;filename</b></tt> changes
          all the uppercase letters in <tt class="FILENAME">filename</tt>
          to asterisks (writes to <tt class="FILENAME">stdout</tt>).
          On some systems this may not work, but <tt class="USERINPUT"><b>tr A-Z
          '[**]'</b></tt> will.</p><p><a name="TROPTIONS"></a></p><p>The <tt class="OPTION">-d</tt> option deletes a range of
          characters.
        <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo "abcdef"                 # abcdef
  echo "abcdef" | tr -d b-d     # aef
  
  
  tr -d 0-9 &lt;filename
  # Deletes all digits from the file "filename".</pre></font></td></tr></tbody></table></p><p>The <tt class="OPTION">--squeeze-repeats</tt> (or
                <tt class="OPTION">-s</tt>) option deletes all but the
                first instance of a string of consecutive characters.
                This option is useful for removing excess <a href="#WHITESPACEREF">whitespace</a>.
  
  
  
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo "XXXXX" | tr --squeeze-repeats 'X'</b></tt>
  <tt class="COMPUTEROUTPUT">X</tt></pre></font></td></tr></tbody></table></p><p>The <tt class="OPTION">-c</tt> <span class="QUOTE">"complement"</span>
          option <i class="FIRSTTERM">inverts</i> the character set to
          match. With this option, <b class="COMMAND">tr</b> acts only
          upon those characters <em>not</em> matching
          the specified set.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo "acfdeb123" | tr -c b-d +</b></tt>
  <tt class="COMPUTEROUTPUT">+c+d+b++++</tt></pre></font></td></tr></tbody></table>
              </p><p>Note that <b class="COMMAND">tr</b> recognizes <a href="#POSIXREF">POSIX character classes</a>.
             <a name="AEN11502" href="#FTN.AEN11502"><span class="footnote">[74]</span></a>
          </p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo "abcd2ef1" | tr '[:alpha:]' -</b></tt>
  <tt class="COMPUTEROUTPUT">----2--1</tt>
          </pre></font></td></tr></tbody></table>
        </p><div class="EXAMPLE"><a name="EX49"></a><p><b>Example 16-21. <i class="FIRSTTERM">toupper</i>: Transforms a file
          to all uppercase.</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Changes a file to all uppercase.
  
  E_BADARGS=85
  
  if [ -z "$1" ]  # Standard check for command-line arg.
  then
    echo "Usage: `basename $0` filename"
    exit $E_BADARGS
  fi  
  
  tr a-z A-Z &lt;"$1"
  
  # Same effect as above, but using POSIX character set notation:
  #        tr '[:lower:]' '[:upper:]' &lt;"$1"
  # Thanks, S.C.
  
  #     Or even . . .
  #     cat "$1" | tr a-z A-Z
  #     Or dozens of other ways . . .
  
  exit 0
  
  #  Exercise:
  #  Rewrite this script to give the option of changing a file
  #+ to *either* upper or lowercase.
  #  Hint: Use either the "case" or "select" command.</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="LOWERCASE"></a><p><b>Example 16-22. <i class="FIRSTTERM">lowercase</i>: Changes all
          filenames in working directory to lowercase.</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  #
  #  Changes every filename in working directory to all lowercase.
  #
  #  Inspired by a script of John Dubois,
  #+ which was translated into Bash by Chet Ramey,
  #+ and considerably simplified by the author of the ABS Guide.
  
  
  for filename in *                # Traverse all files in directory.
  do
     fname=`basename $filename`
     n=`echo $fname | tr A-Z a-z`  # Change name to lowercase.
     if [ "$fname" != "$n" ]       # Rename only files not already lowercase.
     then
       mv $fname $n
     fi  
  done   
  
  exit $?
  
  
  # Code below this line will not execute because of "exit".
  #--------------------------------------------------------#
  # To run it, delete script above line.
  
  # The above script will not work on filenames containing blanks or newlines.
  # Stephane Chazelas therefore suggests the following alternative:
  
  
  for filename in *    # Not necessary to use basename,
                       # since "*" won't return any file containing "/".
  do n=`echo "$filename/" | tr '[:upper:]' '[:lower:]'`
  #                             POSIX char set notation.
  #                    Slash added so that trailing newlines are not
  #                    removed by command substitution.
     # Variable substitution:
     n=${n%/}          # Removes trailing slash, added above, from filename.
     [[ $filename == $n ]] || mv "$filename" "$n"
                       # Checks if filename already lowercase.
  done
  
  exit $?</pre></font></td></tr></tbody></table></div><p><a name="TRD2U"></a></p><div class="EXAMPLE"><a name="DU"></a><p><b>Example 16-23. <i class="FIRSTTERM">du</i>: DOS to UNIX text file conversion.</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Du.sh: DOS to UNIX text file converter.
  
  E_WRONGARGS=85
  
  if [ -z "$1" ]
  then
    echo "Usage: `basename $0` filename-to-convert"
    exit $E_WRONGARGS
  fi
  
  NEWFILENAME=$1.unx
  
  CR='\015'  # Carriage return.
             # 015 is octal ASCII code for CR.
             # Lines in a DOS text file end in CR-LF.
             # Lines in a UNIX text file end in LF only.
  
  tr -d $CR &lt; $1 &gt; $NEWFILENAME
  # Delete CR's and write to new file.
  
  echo "Original DOS text file is \"$1\"."
  echo "Converted UNIX text file is \"$NEWFILENAME\"."
  
  exit 0
  
  # Exercise:
  # --------
  # Change the above script to convert from UNIX to DOS.</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="ROT13"></a><p><b>Example 16-24. <i class="FIRSTTERM">rot13</i>: ultra-weak encryption.</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # rot13.sh: Classic rot13 algorithm,
  #           encryption that might fool a 3-year old
  #           for about 10 minutes.
  
  # Usage: ./rot13.sh filename
  # or     ./rot13.sh &lt;filename
  # or     ./rot13.sh and supply keyboard input (stdin)
  
  cat "$@" | tr 'a-zA-Z' 'n-za-mN-ZA-M'   # "a" goes to "n", "b" to "o" ...
  #  The   cat "$@"   construct
  #+ permits input either from stdin or from files.
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="CRYPTOQUOTE"></a><p><b>Example 16-25. Generating <span class="QUOTE">"Crypto-Quote"</span> Puzzles</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # crypto-quote.sh: Encrypt quotes
  
  #  Will encrypt famous quotes in a simple monoalphabetic substitution.
  #  The result is similar to the "Crypto Quote" puzzles
  #+ seen in the Op Ed pages of the Sunday paper.
  
  
  key=ETAOINSHRDLUBCFGJMQPVWZYXK
  # The "key" is nothing more than a scrambled alphabet.
  # Changing the "key" changes the encryption.
  
  # The 'cat "$@"' construction gets input either from stdin or from files.
  # If using stdin, terminate input with a Control-D.
  # Otherwise, specify filename as command-line parameter.
  
  cat "$@" | tr "a-z" "A-Z" | tr "A-Z" "$key"
  #        |  to uppercase  |     encrypt       
  # Will work on lowercase, uppercase, or mixed-case quotes.
  # Passes non-alphabetic characters through unchanged.
  
  
  # Try this script with something like:
  # "Nothing so needs reforming as other people's habits."
  # --Mark Twain
  #
  # Output is:
  # "CFPHRCS QF CIIOQ MINFMBRCS EQ FPHIM GIFGUI'Q HETRPQ."
  # --BEML PZERC
  
  # To reverse the encryption:
  # cat "$@" | tr "$key" "A-Z"
  
  
  #  This simple-minded cipher can be broken by an average 12-year old
  #+ using only pencil and paper.
  
  exit 0
  
  #  Exercise:
  #  --------
  #  Modify the script so that it will either encrypt or decrypt,
  #+ depending on command-line argument(s).</pre></font></td></tr></tbody></table></div><p><a name="JABH"></a>Of course, <i class="FIRSTTERM">tr</i>
                lends itself to <i class="FIRSTTERM">code
                obfuscation</i>.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # jabh.sh
  
  x="wftedskaebjgdBstbdbsmnjgz"
  echo $x | tr "a-z" 'oh, turtleneck Phrase Jar!'
  
  # Based on the Wikipedia "Just another Perl hacker" article.</pre></font></td></tr></tbody></table></p><p><a name="TRVARIANTS"></a></p><table class="SIDEBAR" border="1" cellpadding="5"><tbody><tr><td><div class="SIDEBAR"><a name="AEN11540"></a><p><b><i class="FIRSTTERM">tr</i> variants</b></p><p>	    The <b class="COMMAND">tr</b> utility has two historic
        variants. The BSD version does not use brackets
        (<tt class="USERINPUT"><b>tr a-z A-Z</b></tt>), but the SysV one does
        (<tt class="USERINPUT"><b>tr '[a-z]' '[A-Z]'</b></tt>). The GNU version
        of <b class="COMMAND">tr</b> resembles the BSD one.
        </p></div></td></tr></tbody></table></dd><dt><a name="FOLDREF"></a><b class="COMMAND">fold</b></dt><dd><p>A filter that wraps lines of input to a specified width.
          This is especially useful with the <tt class="OPTION">-s</tt>
          option, which breaks lines at word spaces (see <a href="#EX50">Example 16-26</a> and <a href="#MAILFORMAT">Example A-1</a>).</p></dd><dt><a name="FMTREF"></a><b class="COMMAND">fmt</b></dt><dd><p>Simple-minded file formatter, used as a filter in a
          pipe to <span class="QUOTE">"wrap"</span> long lines of text
          output.</p><div class="EXAMPLE"><a name="EX50"></a><p><b>Example 16-26. Formatted file listing.</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  WIDTH=40                    # 40 columns wide.
  
  b=`ls /usr/local/bin`       # Get a file listing...
  
  echo $b | fmt -w $WIDTH
  
  # Could also have been done by
  #    echo $b | fold - -s -w $WIDTH
   
  exit 0</pre></font></td></tr></tbody></table></div><p>See also <a href="#EX41">Example 16-5</a>.</p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>A powerful alternative to <b class="COMMAND">fmt</b> is
          Kamil Toman's <b class="COMMAND">par</b>
          utility, available from <a href="http://www.cs.berkeley.edu/~amc/Par/" target="_top">http://www.cs.berkeley.edu/~amc/Par/</a>.
          </p></td></tr></tbody></table></div></dd><dt><a name="COLREF"></a><b class="COMMAND">col</b></dt><dd><p>This deceptively named filter removes reverse line feeds
          from an input stream. It also attempts to replace
          whitespace with equivalent tabs. The chief use of
          <b class="COMMAND">col</b> is in filtering the output
          from certain text processing utilities, such as
          <b class="COMMAND">groff</b> and <b class="COMMAND">tbl</b>.</p></dd><dt><a name="COLUMNREF"></a><b class="COMMAND">column</b></dt><dd><p>Column formatter. This filter transforms list-type
          text output into a <span class="QUOTE">"pretty-printed"</span> table
          by inserting tabs at appropriate places.</p><div class="EXAMPLE"><a name="COL"></a><p><b>Example 16-27. Using <i class="FIRSTTERM">column</i> to format a directory
            listing</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # colms.sh
  # A minor modification of the example file in the "column" man page.
  
  
  (printf "PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n" \
  ; ls -l | sed 1d) | column -t
  #         ^^^^^^           ^^
  
  #  The "sed 1d" in the pipe deletes the first line of output,
  #+ which would be "total        N",
  #+ where "N" is the total number of files found by "ls -l".
  
  # The -t option to "column" pretty-prints a table.
  
  exit 0</pre></font></td></tr></tbody></table></div></dd><dt><a name="COLRMREF"></a><b class="COMMAND">colrm</b></dt><dd><p>Column removal filter. This removes columns (characters)
          from a file and writes the file, lacking the range of
          specified columns, back to <tt class="FILENAME">stdout</tt>.
          <tt class="USERINPUT"><b>colrm 2 4 &lt;filename</b></tt> removes the
          second through fourth characters from each line of the
          text file <tt class="FILENAME">filename</tt>.</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>If the file contains tabs or nonprintable
          characters, this may cause unpredictable
          behavior. In such cases, consider using
          <a href="#EXPANDREF">expand</a> and
          <b class="COMMAND">unexpand</b> in a pipe preceding
          <b class="COMMAND">colrm</b>.</p></td></tr></tbody></table></div></dd><dt><a name="NLREF"></a><b class="COMMAND">nl</b></dt><dd><p>Line numbering filter: <tt class="USERINPUT"><b>nl filename</b></tt>
        lists <tt class="FILENAME">filename</tt> to
        <tt class="FILENAME">stdout</tt>, but inserts consecutive
        numbers at the beginning of each non-blank line. If
        <tt class="FILENAME">filename</tt> omitted, operates on
        <tt class="FILENAME">stdin.</tt></p><p>The output of <b class="COMMAND">nl</b> is very similar to
          <tt class="USERINPUT"><b>cat -b</b></tt>, since, by default
          <b class="COMMAND">nl</b> does not list blank lines.</p><div class="EXAMPLE"><a name="LNUM"></a><p><b>Example 16-28. <i class="FIRSTTERM">nl</i>: A self-numbering script.</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # line-number.sh
  
  # This script echoes itself twice to stdout with its lines numbered.
  
  echo "     line number = $LINENO" # 'nl' sees this as line 4
  #                                   (nl does not number blank lines).
  #                                   'cat -n' sees it correctly as line #6.
  
  nl `basename $0`
  
  echo; echo  # Now, let's try it with 'cat -n'
  
  cat -n `basename $0`
  # The difference is that 'cat -n' numbers the blank lines.
  # Note that 'nl -ba' will also do so.
  
  exit 0
  # -----------------------------------------------------------------</pre></font></td></tr></tbody></table></div></dd><dt><a name="PRREF"></a><b class="COMMAND">pr</b></dt><dd><p>Print formatting filter. This will paginate files
          (or <tt class="FILENAME">stdout</tt>) into sections suitable for
          hard copy printing or viewing on screen.	Various options
          permit row and column manipulation, joining lines, setting
          margins, numbering lines, adding page headers, and merging
          files, among other things. The <b class="COMMAND">pr</b>
          command combines much of the functionality of
          <b class="COMMAND">nl</b>, <b class="COMMAND">paste</b>,
          <b class="COMMAND">fold</b>, <b class="COMMAND">column</b>, and
          <b class="COMMAND">expand</b>.</p><p><tt class="USERINPUT"><b>pr -o 5 --width=65 fileZZZ | more</b></tt>
         gives a nice paginated listing to screen of
         <tt class="FILENAME">fileZZZ</tt> with margins set at 5 and
         65.</p><p>A particularly useful option is <tt class="OPTION">-d</tt>,
          forcing double-spacing (same effect as <b class="COMMAND">sed
          -G</b>).</p></dd><dt><a name="GETTEXTREF"></a><b class="COMMAND">gettext</b></dt><dd><p>The GNU <b class="COMMAND">gettext</b> package is a set of
          utilities for <a href="#LOCALIZATION">localizing</a>
          and translating the text output of programs into foreign
          languages. While originally intended for C programs, it
          now supports quite a number of programming and scripting
          languages.</p><p>The  <b class="COMMAND">gettext</b>
          <em>program</em> works on shell scripts. See
          the <tt class="REPLACEABLE"><i>info page</i></tt>.</p></dd><dt><a name="MSGFMTREF"></a><b class="COMMAND">msgfmt</b></dt><dd><p>A program for generating binary
          message catalogs. It is used for <a href="#LOCALIZATION">localization</a>.</p></dd><dt><a name="ICONVREF"></a><b class="COMMAND">iconv</b></dt><dd><p>A utility for converting file(s) to a different encoding
          (character set). Its chief use is for <a href="#LOCALIZATION">localization</a>.</p><p>	    <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Convert a string from UTF-8 to UTF-16 and print to the BookList
  function write_utf8_string {
      STRING=$1
      BOOKLIST=$2
      echo -n "$STRING" | iconv -f UTF8 -t UTF16 | \
      cut -b 3- | tr -d \\n &gt;&gt; "$BOOKLIST"
  }
  
  #  From Peter Knowles' "booklistgen.sh" script
  #+ for converting files to Sony Librie/PRS-50X format.
  #  (http://booklistgensh.peterknowles.com)</pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="RECODEREF"></a><b class="COMMAND">recode</b></dt><dd><p>Consider this a fancier version of
          <b class="COMMAND">iconv</b>, above. This very versatile utility
          for converting a file to a different encoding scheme.
          Note that <i class="FIRSTTERM">recode</i> is not part of the
          standard Linux installation.</p></dd><dt><a name="TEXREF"></a><b class="COMMAND">TeX</b>, <a name="GSREF"></a><b class="COMMAND">gs</b></dt><dd><p><b class="COMMAND">TeX</b> and <b class="COMMAND">Postscript</b>
          are text markup languages used for preparing copy for
          printing or formatted video display.</p><p><b class="COMMAND">TeX</b> is Donald Knuth's elaborate
      typsetting system. It is often convenient to write a
      shell script encapsulating all the options and arguments
      passed to one of these markup languages.</p><p><i class="FIRSTTERM">Ghostscript</i>
      (<b class="COMMAND">gs</b>) is a GPL-ed Postscript
      interpreter.</p></dd><dt><a name="TEXEXECREF"></a><b class="COMMAND">texexec</b></dt><dd><p>Utility for processing <i class="FIRSTTERM">TeX</i> and
          <i class="FIRSTTERM">pdf</i> files. Found in
          <tt class="FILENAME">/usr/bin</tt>
          on many Linux distros, it is actually a <a href="#SHWRAPPER">shell wrapper</a> that
          calls <a href="#PERLREF">Perl</a> to invoke
          <i class="FIRSTTERM">Tex</i>.</p><p>	    <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">texexec --pdfarrange --result=Concatenated.pdf *pdf
  
  #  Concatenates all the pdf files in the current working directory
  #+ into the merged file, Concatenated.pdf . . .
  #  (The --pdfarrange option repaginates a pdf file. See also --pdfcombine.)
  #  The above command-line could be parameterized and put into a shell script.</pre></font></td></tr></tbody></table> 
              </p></dd><dt><a name="ENSCRIPTREF"></a><b class="COMMAND">enscript</b></dt><dd><p>Utility for converting plain text file to PostScript</p><p>For example, <b class="COMMAND">enscript filename.txt -p filename.ps</b>
          produces the PostScript output file
          <tt class="FILENAME">filename.ps</tt>.</p></dd><dt><a name="GROFFREF"></a><b class="COMMAND">groff</b>, <a name="TBLREF"></a><b class="COMMAND">tbl</b>, <a name="EQNREF"></a><b class="COMMAND">eqn</b></dt><dd><p>Yet another text markup and display formatting language
          is <b class="COMMAND">groff</b>. This is the enhanced GNU version
          of the venerable UNIX <b class="COMMAND">roff/troff</b> display
          and typesetting package. <a href="#MANREF">Manpages</a>
          use <b class="COMMAND">groff</b>.</p><p>The <b class="COMMAND">tbl</b> table processing utility
          is considered part of <b class="COMMAND">groff</b>, as its
          function is to convert table markup into
          <b class="COMMAND">groff</b> commands.</p><p>The <b class="COMMAND">eqn</b> equation processing utility
          is likewise part of <b class="COMMAND">groff</b>, and
          its function is to convert equation markup into
          <b class="COMMAND">groff</b> commands.</p><div class="EXAMPLE"><a name="MANVIEW"></a><p><b>Example 16-29. <i class="FIRSTTERM">manview</i>: Viewing formatted manpages</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # manview.sh: Formats the source of a man page for viewing.
  
  #  This script is useful when writing man page source.
  #  It lets you look at the intermediate results on the fly
  #+ while working on it.
  
  E_WRONGARGS=85
  
  if [ -z "$1" ]
  then
    echo "Usage: `basename $0` filename"
    exit $E_WRONGARGS
  fi
  
  # ---------------------------
  groff -Tascii -man $1 | less
  # From the man page for groff.
  # ---------------------------
  
  #  If the man page includes tables and/or equations,
  #+ then the above code will barf.
  #  The following line can handle such cases.
  #
  #   gtbl &lt; "$1" | geqn -Tlatin1 | groff -Tlatin1 -mtty-char -man
  #
  #   Thanks, S.C.
  
  exit $?   # See also the "maned.sh" script.</pre></font></td></tr></tbody></table></div><p>See also <a href="#MANED">Example A-39</a>.</p></dd><dt><a name="LEXREF"></a><b class="COMMAND">lex</b>, <a name="YACCREF"></a><b class="COMMAND">yacc</b></dt><dd><p><a name="FLEXREF"></a></p><p>The <b class="COMMAND">lex</b> lexical analyzer produces
          programs for pattern matching. This has been replaced
          by the nonproprietary <b class="COMMAND">flex</b> on Linux
          systems.</p><p><a name="BISONREF"></a></p><p>The <b class="COMMAND">yacc</b> utility creates a
          parser based on a set of specifications. This has been
          replaced by the nonproprietary <b class="COMMAND">bison</b>
          on Linux systems.</p></dd></dl></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="FILEARCHIV"></a>16.5. File and Archiving Commands</h1><p></p><div class="VARIABLELIST"><p><b><a name="FAARCHIVING1"></a>Archiving</b></p><dl><dt><a name="TARREF"></a><b class="COMMAND">tar</b></dt><dd><p>The standard UNIX archiving utility.
  
            <a name="AEN11885" href="#FTN.AEN11885"><span class="footnote">[75]</span></a>
  
          Originally a
          <i class="WORDASWORD">Tape ARchiving</i> program, it has
          developed into a general purpose package that can handle
          all manner of archiving with all types of destination
          devices, ranging from tape drives to regular files to even
          <tt class="FILENAME">stdout</tt> (see <a href="#EX58">Example 3-4</a>). GNU
          <i class="FIRSTTERM">tar</i> has been patched to accept
          various compression filters, for example: <b class="COMMAND">tar
          czvf archive_name.tar.gz *</b>, which recursively
          archives and <a href="#GZIPREF">gzips</a>
          all files in a directory tree except <a href="#DOTFILESREF">dotfiles</a> in the current
          working directory (<a href="#PWDREF">$PWD</a>).
  
      <a name="AEN11896" href="#FTN.AEN11896"><span class="footnote">[76]</span></a>
              </p><p>Some useful <b class="COMMAND">tar</b> options:  
          </p><p></p><ol type="1"><li><p><tt class="OPTION">-c</tt> create (a new
        archive)</p></li><li><p><tt class="OPTION">-x</tt> extract (files from
        existing archive)</p></li><li><p><tt class="OPTION">--delete</tt> delete (files
        from existing archive)</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>This option will not work on magnetic tape
        devices.</p></td></tr></tbody></table></div></li><li><p><tt class="OPTION">-r</tt> append (files to
        existing archive)</p></li><li><p><tt class="OPTION">-A</tt> append
        (<i class="FIRSTTERM">tar</i> files to
        existing archive)</p></li><li><p><tt class="OPTION">-t</tt> list (contents of
                    existing archive)</p></li><li><p><tt class="OPTION">-u</tt> update archive</p></li><li><p><tt class="OPTION">-d</tt> compare archive with
        specified filesystem</p></li><li><p><tt class="OPTION">--after-date</tt> only process
        files with a date stamp <em>after</em>
        specified date</p></li><li><p><tt class="OPTION">-z</tt> <a href="#GZIPREF">gzip</a> the archive</p><p>(compress or uncompress, depending on whether
      combined with the <tt class="OPTION">-c</tt> or
      <tt class="OPTION">-x</tt>) option</p></li><li><p><tt class="OPTION">-j</tt>
        <a href="#BZIPREF">bzip2</a> the
        archive</p></li></ol>
          <p></p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>It may be difficult to recover data from a
          corrupted <i class="FIRSTTERM">gzipped</i> tar
          archive. When archiving important files, make multiple
          backups.</p></td></tr></tbody></table></div></dd><dt><a name="SHARREF"></a><b class="COMMAND">shar</b></dt><dd><p><i class="FIRSTTERM">Shell archiving</i> utility.
                The text and/or binary files in a shell archive are
                concatenated without compression, and the resultant
                archive is essentially a shell script, complete with
                <span class="TOKEN">#!/bin/sh</span> header, containing all the
                necessary unarchiving commands, as well as the files
                themselves. Unprintable binary characters in the target
                file(s) are converted to printable ASCII characters in the
                output <i class="FIRSTTERM">shar</i> file. <i class="FIRSTTERM">Shar
                archives</i> still show up in Usenet newsgroups,
                but otherwise <b class="COMMAND">shar</b> has been replaced
                by <b class="COMMAND">tar</b>/<b class="COMMAND">gzip</b>.
                The <b class="COMMAND">unshar</b> command unpacks
                <i class="FIRSTTERM">shar</i> archives.</p><p>The
                <b class="COMMAND">mailshar</b> command is a Bash script that
                uses <b class="COMMAND">shar</b> to concatenate multiple files
                into a single one for e-mailing.
                This script supports compression and <a href="#UUENCODEREF">uuencoding</a>.</p></dd><dt><a name="ARREF"></a><b class="COMMAND">ar</b></dt><dd><p>Creation and manipulation utility for archives, mainly
          used for binary object file libraries.</p></dd><dt><a name="RPMREF"></a><b class="COMMAND">rpm</b></dt><dd><p>The <i class="FIRSTTERM">Red Hat Package Manager</i>, or
          <b class="COMMAND">rpm</b> utility provides a wrapper for
          source or binary archives. It includes commands for
          installing and checking the integrity of packages, among
          other things.</p><p>A simple <b class="COMMAND">rpm -i package_name.rpm</b>
          usually suffices to install a package, though there are many
          more options available.</p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p><tt class="USERINPUT"><b>rpm -qf</b></tt> identifies which package a
          file originates from.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>rpm -qf /bin/ls</b></tt>
  <tt class="COMPUTEROUTPUT">coreutils-5.2.1-31</tt>
          </pre></font></td></tr></tbody></table>
        </p></td></tr></tbody></table></div><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p><tt class="USERINPUT"><b>rpm -qa</b></tt> gives a
          complete list of all installed <i class="FIRSTTERM">rpm</i> packages
          on a given system. An <tt class="USERINPUT"><b>rpm -qa package_name</b></tt>
          lists only the package(s) corresponding to
          <tt class="FILENAME">package_name</tt>.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>rpm -qa</b></tt>
  <tt class="COMPUTEROUTPUT">redhat-logos-1.1.3-1
   glibc-2.2.4-13
   cracklib-2.7-12
   dosfstools-2.7-1
   gdbm-1.8.0-10
   ksymoops-2.4.1-1
   mktemp-1.5-11
   perl-5.6.0-17
   reiserfs-utils-3.x.0j-2
   ...</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>rpm -qa docbook-utils</b></tt>
  <tt class="COMPUTEROUTPUT">docbook-utils-0.6.9-2</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>rpm -qa docbook | grep docbook</b></tt>
  <tt class="COMPUTEROUTPUT">docbook-dtd31-sgml-1.0-10
   docbook-style-dsssl-1.64-3
   docbook-dtd30-sgml-1.0-10
   docbook-dtd40-sgml-1.0-11
   docbook-utils-pdf-0.6.9-2
   docbook-dtd41-sgml-1.0-10
   docbook-utils-0.6.9-2</tt>
          </pre></font></td></tr></tbody></table>
        </p></td></tr></tbody></table></div></dd><dt><a name="CPIOREF"></a><b class="COMMAND">cpio</b></dt><dd><p>This specialized archiving copy command
          (<b class="COMMAND">c</b>o<b class="COMMAND">p</b>y
          <b class="COMMAND">i</b>nput and <b class="COMMAND">o</b>utput)
          is rarely seen any more, having been supplanted by
          <b class="COMMAND">tar</b>/<b class="COMMAND">gzip</b>. It still
          has its uses, such as moving a directory tree. With an
          appropriate block size (for copying) specified, it
          can be appreciably faster than <b class="COMMAND">tar</b>.</p><div class="EXAMPLE"><a name="EX48"></a><p><b>Example 16-30. Using <i class="FIRSTTERM">cpio</i> to move a directory tree</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  # Copying a directory tree using cpio.
  
  # Advantages of using 'cpio':
  #   Speed of copying. It's faster than 'tar' with pipes.
  #   Well suited for copying special files (named pipes, etc.)
  #+  that 'cp' may choke on.
  
  ARGS=2
  E_BADARGS=65
  
  if [ $# -ne "$ARGS" ]
  then
    echo "Usage: `basename $0` source destination"
    exit $E_BADARGS
  fi  
  
  source="$1"
  destination="$2"
  
  ###################################################################
  find "$source" -depth | cpio -admvp "$destination"
  #               ^^^^^         ^^^^^
  #  Read the 'find' and 'cpio' info pages to decipher these options.
  #  The above works only relative to $PWD (current directory) . . .
  #+ full pathnames are specified.
  ###################################################################
  
  
  # Exercise:
  # --------
  
  #  Add code to check the exit status ($?) of the 'find | cpio' pipe
  #+ and output appropriate error messages if anything went wrong.
  
  exit $?</pre></font></td></tr></tbody></table></div></dd><dt><a name="RPM2CPIOREF"></a><b class="COMMAND">rpm2cpio</b></dt><dd><p>This command extracts a
          <b class="COMMAND">cpio</b> archive from an <a href="#RPMREF">rpm</a> one.</p><div class="EXAMPLE"><a name="DERPM"></a><p><b>Example 16-31. Unpacking an <i class="FIRSTTERM">rpm</i> archive</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # de-rpm.sh: Unpack an 'rpm' archive
  
  : ${1?"Usage: `basename $0` target-file"}
  # Must specify 'rpm' archive name as an argument.
  
  
  TEMPFILE=$$.cpio                         #  Tempfile with "unique" name.
                                           #  $$ is process ID of script.
  
  rpm2cpio &lt; $1 &gt; $TEMPFILE                #  Converts rpm archive into
                                           #+ cpio archive.
  cpio --make-directories -F $TEMPFILE -i  #  Unpacks cpio archive.
  rm -f $TEMPFILE                          #  Deletes cpio archive.
  
  exit 0
  
  #  Exercise:
  #  Add check for whether 1) "target-file" exists and
  #+                       2) it is an rpm archive.
  #  Hint:                    Parse output of 'file' command.</pre></font></td></tr></tbody></table></div></dd><dt><a name="PAXREF"></a><b class="COMMAND">pax</b></dt><dd><p>The <i class="FIRSTTERM">pax</i>
              <b class="COMMAND">p</b>ortable <b class="COMMAND">a</b>rchive
              e<b class="COMMAND">x</b>change toolkit facilitates periodic
              file backups and is designed to be cross-compatible
              between various flavors of UNIX. It was designed
        to replace <a href="#TARREF">tar</a> and <a href="#CPIOREF">cpio</a>.</p><p>	  <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">pax -wf daily_backup.pax ~/linux-server/files 
  #  Creates a tar archive of all files in the target directory.
  #  Note that the options to pax must be in the correct order --
  #+ pax -fw     has an entirely different effect.
  
  pax -f daily_backup.pax
  #  Lists the files in the archive.
  
  pax -rf daily_backup.pax ~/bsd-server/files
  #  Restores the backed-up files from the Linux machine
  #+ onto a BSD one.</pre></font></td></tr></tbody></table>
      </p><p>Note that <i class="FIRSTTERM">pax</i> handles many of
              the standard archiving and compression commands.</p></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="FACOMPRESSION1"></a>Compression</b></p><dl><dt><a name="GZIPREF"></a><b class="COMMAND">gzip</b></dt><dd><p>The standard GNU/UNIX compression utility, replacing
          the inferior and proprietary
          <b class="COMMAND">compress</b>. The corresponding decompression
          command is <b class="COMMAND">gunzip</b>, which is the equivalent of
          <b class="COMMAND">gzip -d</b>.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <tt class="OPTION">-c</tt> option sends the output of
          <b class="COMMAND">gzip</b> to <tt class="FILENAME">stdout</tt>. This
          is useful when <a href="#PIPEREF">piping</a> to other
          commands.</p></td></tr></tbody></table></div><p><a name="ZCATREF"></a></p><p>The <b class="COMMAND">zcat</b> filter decompresses a
          <i class="FIRSTTERM">gzipped</i> file to
          <tt class="FILENAME">stdout</tt>, as possible input to a pipe or
          redirection. This is, in effect, a <b class="COMMAND">cat</b>
          command that works on compressed files (including files
          processed with the older <a href="#COMPRESSREF">compress</a>
          utility). The <b class="COMMAND">zcat</b> command is equivalent to
          <b class="COMMAND">gzip -dc</b>.</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>On some commercial UNIX systems, <b class="COMMAND">zcat</b>
          is a synonym for <b class="COMMAND">uncompress -c</b>,
          and will not work on <i class="FIRSTTERM">gzipped</i>
          files.</p></td></tr></tbody></table></div><p>See also <a href="#EX14">Example 7-7</a>.</p></dd><dt><a name="BZIPREF"></a><b class="COMMAND">bzip2</b></dt><dd><p>An alternate compression utility, usually more efficient
          (but slower) than <b class="COMMAND">gzip</b>, especially on
          large files. The corresponding decompression command is
          <b class="COMMAND">bunzip2</b>.</p><p>Similar to the <b class="COMMAND">zcat</b> command,
          <b class="COMMAND">bzcat</b> decompresses a
          <i class="FIRSTTERM">bzipped2-ed</i> file to
          <tt class="FILENAME">stdout</tt>.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>Newer versions of <a href="#TARREF">tar</a> have been patched with
          <b class="COMMAND">bzip2</b> support.</p></td></tr></tbody></table></div></dd><dt><a name="COMPRESSREF"></a><b class="COMMAND">compress</b>, <a name="UNCOMPRESSREF"></a><b class="COMMAND">uncompress</b></dt><dd><p>This is an older, proprietary compression
          utility found in commercial UNIX distributions. The
          more efficient <b class="COMMAND">gzip</b> has largely
          replaced it. Linux distributions generally include a
          <b class="COMMAND">compress</b> workalike for compatibility,
          although <b class="COMMAND">gunzip</b> can unarchive files
          treated with <b class="COMMAND">compress</b>.</p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">znew</b> command transforms
          <i class="FIRSTTERM">compressed</i> files into
          <i class="FIRSTTERM">gzipped</i> ones.</p></td></tr></tbody></table></div></dd><dt><a name="SQREF"></a><b class="COMMAND">sq</b></dt><dd><p>Yet another compression (<b class="COMMAND">sq</b>ueeze)
          utility, a filter that works only on sorted
          <a href="#ASCIIDEF">ASCII</a> word lists. It
          uses the standard invocation syntax for a filter,
          <b class="COMMAND">sq &lt; input-file &gt; output-file</b>.
          Fast, but not nearly as efficient as <a href="#GZIPREF">gzip</a>.  The corresponding
          uncompression filter is <b class="COMMAND">unsq</b>, invoked
          like <b class="COMMAND">sq</b>.</p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>The output of <b class="COMMAND">sq</b> may be
            piped to <b class="COMMAND">gzip</b> for further
      compression.</p></td></tr></tbody></table></div></dd><dt><a name="ZIPREF"></a><b class="COMMAND">zip</b>, <b class="COMMAND">unzip</b></dt><dd><p>Cross-platform file archiving and compression utility
          compatible with DOS <i class="FIRSTTERM">pkzip.exe</i>.
          <span class="QUOTE">"Zipped"</span> archives seem to be a more
          common medium of file exchange on the Internet than
          <span class="QUOTE">"tarballs."</span></p></dd><dt><a name="UNARCREF"></a><b class="COMMAND">unarc</b>, <b class="COMMAND">unarj</b>, <b class="COMMAND">unrar</b></dt><dd><p>These Linux utilities permit unpacking archives
          compressed with the DOS <i class="FIRSTTERM">arc.exe</i>,
          <i class="FIRSTTERM">arj.exe</i>, and
          <i class="FIRSTTERM">rar.exe</i> programs.</p></dd><dt><a name="LZMAREF"></a><b class="COMMAND">lzma</b>, <b class="COMMAND">unlzma</b>, <b class="COMMAND">lzcat</b></dt><dd><p>Highly efficient Lempel-Ziv-Markov compression.
          The syntax of <i class="FIRSTTERM">lzma</i> is similar to
                that of <i class="FIRSTTERM">gzip</i>. The <a href="http://www.7-zip.org/sdk.html" target="_top">7-zip Website</a>
                has more information.</p></dd><dt><a name="XZREF"></a><b class="COMMAND">xz</b>, <b class="COMMAND">unxz</b>, <b class="COMMAND">xzcat</b></dt><dd><p>A new high-efficiency compression tool, backward compatible
          with <i class="FIRSTTERM">lzma</i>, and with an invocation
          syntax similar to <i class="FIRSTTERM">gzip</i>. For
          more information, see the <a href="http://en.wikipedia.org/wiki/Xz" target="_top">Wikipedia
          entry</a>.</p></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="FAINFORMATION1"></a>File Information</b></p><dl><dt><a name="FILEREF"></a><b class="COMMAND">file</b></dt><dd><p>A utility for identifying file types. The command
          <tt class="USERINPUT"><b>file file-name</b></tt> will return a
          file specification for <tt class="FILENAME">file-name</tt>,
          such as <tt class="COMPUTEROUTPUT">ascii text</tt> or
          <tt class="COMPUTEROUTPUT">data</tt>. It references
          the <a href="#MAGNUMREF">magic numbers</a>
          found in <tt class="FILENAME">/usr/share/magic</tt>,
          <tt class="FILENAME">/etc/magic</tt>, or
          <tt class="FILENAME">/usr/lib/magic</tt>, depending on the
          Linux/UNIX distribution.</p><p>The <tt class="OPTION">-f</tt> option causes
          <b class="COMMAND">file</b> to run in <a href="#BATCHPROCREF">batch</a> mode, to read from
          a designated file a list of filenames to analyze. The
          <tt class="OPTION">-z</tt> option, when used on a compressed
          target file, forces an attempt to analyze the uncompressed
          file type.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>file test.tar.gz</b></tt>
  <tt class="COMPUTEROUTPUT">test.tar.gz: gzip compressed data, deflated,
   last modified: Sun Sep 16 13:34:51 2001, os: Unix</tt>
  
  <tt class="PROMPT">bash </tt><tt class="USERINPUT"><b>file -z test.tar.gz</b></tt>
  <tt class="COMPUTEROUTPUT">test.tar.gz: GNU tar archive (gzip compressed data, deflated,
   last modified: Sun Sep 16 13:34:51 2001, os: Unix)</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>	      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Find sh and Bash scripts in a given directory:
  
  DIRECTORY=/usr/local/bin
  KEYWORD=Bourne
  # Bourne and Bourne-Again shell scripts
  
  file $DIRECTORY/* | fgrep $KEYWORD
  
  # Output:
  
  # /usr/local/bin/burn-cd:          Bourne-Again shell script text executable
  # /usr/local/bin/burnit:           Bourne-Again shell script text executable
  # /usr/local/bin/cassette.sh:      Bourne shell script text executable
  # /usr/local/bin/copy-cd:          Bourne-Again shell script text executable
  # . . .</pre></font></td></tr></tbody></table>
        </p><div class="EXAMPLE"><a name="STRIPC"></a><p><b>Example 16-32. Stripping comments from C program files</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # strip-comment.sh: Strips out the comments (/* COMMENT */) in a C program.
  
  E_NOARGS=0
  E_ARGERROR=66
  E_WRONG_FILE_TYPE=67
  
  if [ $# -eq "$E_NOARGS" ]
  then
    echo "Usage: `basename $0` C-program-file" &gt;&amp;2 # Error message to stderr.
    exit $E_ARGERROR
  fi  
  
  # Test for correct file type.
  type=`file $1 | awk '{ print $2, $3, $4, $5 }'`
  # "file $1" echoes file type . . .
  # Then awk removes the first field, the filename . . .
  # Then the result is fed into the variable "type."
  correct_type="ASCII C program text"
  
  if [ "$type" != "$correct_type" ]
  then
    echo
    echo "This script works on C program files only."
    echo
    exit $E_WRONG_FILE_TYPE
  fi  
  
  
  # Rather cryptic sed script:
  #--------
  sed '
  /^\/\*/d
  /.*\*\//d
  ' $1
  #--------
  # Easy to understand if you take several hours to learn sed fundamentals.
  
  
  #  Need to add one more line to the sed script to deal with
  #+ case where line of code has a comment following it on same line.
  #  This is left as a non-trivial exercise.
  
  #  Also, the above code deletes non-comment lines with a "*/" . . .
  #+ not a desirable result.
  
  exit 0
  
  
  # ----------------------------------------------------------------
  # Code below this line will not execute because of 'exit 0' above.
  
  # Stephane Chazelas suggests the following alternative:
  
  usage() {
    echo "Usage: `basename $0` C-program-file" &gt;&amp;2
    exit 1
  }
  
  WEIRD=`echo -n -e '\377'`   # or WEIRD=$'\377'
  [[ $# -eq 1 ]] || usage
  case `file "$1"` in
    *"C program text"*) sed -e "s%/\*%${WEIRD}%g;s%\*/%${WEIRD}%g" "$1" \
       | tr '\377\n' '\n\377' \
       | sed -ne 'p;n' \
       | tr -d '\n' | tr '\377' '\n';;
    *) usage;;
  esac
  
  #  This is still fooled by things like:
  #  printf("/*");
  #  or
  #  /*  /* buggy embedded comment */
  #
  #  To handle all special cases (comments in strings, comments in string
  #+ where there is a \", \\" ...),
  #+ the only way is to write a C parser (using lex or yacc perhaps?).
  
  exit 0</pre></font></td></tr></tbody></table></div></dd><dt><a name="WHICHREF"></a><b class="COMMAND">which</b></dt><dd><p><b class="COMMAND">which command</b> gives the full path
          to <span class="QUOTE">"command."</span> This is useful for finding
          out whether a particular command or utility is installed
          on the system.</p><p><tt class="USERINPUT"><b>$bash which rm</b></tt>
  <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="COMPUTEROUTPUT">/usr/bin/rm</tt></pre></font></td></tr></tbody></table>
      </p><p>For an interesting use of this command, see <a href="#HORSERACE">Example 36-16</a>.</p></dd><dt><a name="WHEREISREF"></a><b class="COMMAND">whereis</b></dt><dd><p>Similar to <b class="COMMAND">which</b>, above,
          <b class="COMMAND">whereis command</b> gives the
          full path to <span class="QUOTE">"command,"</span> but also to its
          <a href="#MANREF">manpage</a>.</p><p><tt class="USERINPUT"><b>$bash whereis rm</b></tt>
  <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="COMPUTEROUTPUT">rm: /bin/rm /usr/share/man/man1/rm.1.bz2</tt></pre></font></td></tr></tbody></table>
      </p></dd><dt><a name="WHATISREF"></a><b class="COMMAND">whatis</b></dt><dd><p><b class="COMMAND">whatis command</b> looks up
          <span class="QUOTE">"command"</span> in the
          <tt class="REPLACEABLE"><i>whatis</i></tt> database. This is useful
          for identifying system commands and important configuration
          files. Consider it a simplified <b class="COMMAND">man</b>
          command.</p><p><tt class="USERINPUT"><b>$bash whatis whatis</b></tt>
  <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="COMPUTEROUTPUT">whatis               (1)  - search the whatis database for complete words</tt></pre></font></td></tr></tbody></table>
      </p><div class="EXAMPLE"><a name="WHAT"></a><p><b>Example 16-33. Exploring <tt class="FILENAME">/usr/X11R6/bin</tt></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  # What are all those mysterious binaries in /usr/X11R6/bin?
  
  DIRECTORY="/usr/X11R6/bin"
  # Try also "/bin", "/usr/bin", "/usr/local/bin", etc.
  
  for file in $DIRECTORY/*
  do
    whatis `basename $file`   # Echoes info about the binary.
  done
  
  exit 0
  
  #  Note: For this to work, you must create a "whatis" database
  #+ with /usr/sbin/makewhatis.
  #  You may wish to redirect output of this script, like so:
  #    ./what.sh &gt;&gt;whatis.db
  #  or view it a page at a time on stdout,
  #    ./what.sh | less</pre></font></td></tr></tbody></table></div><p>See also <a href="#FILEINFO">Example 11-3</a>.</p></dd><dt><a name="VDIRREF"></a><b class="COMMAND">vdir</b></dt><dd><p>Show a detailed directory listing. The effect is similar to
          <a href="#LSREF">ls -lb</a>.</p><p>This is one of the GNU
        <i class="FIRSTTERM">fileutils</i>.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>vdir</b></tt>
  <tt class="COMPUTEROUTPUT">total 10
   -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
   -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
   -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</tt>
  
  <tt class="PROMPT">bash </tt><tt class="USERINPUT"><b>ls -l</b></tt>
  <tt class="COMPUTEROUTPUT">total 10
   -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
   -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
   -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</tt>
          </pre></font></td></tr></tbody></table>
          </p></dd><dt><a name="LOCATEREF"></a><b class="COMMAND">locate</b>, <a name="SLOCATEREF"></a><b class="COMMAND">slocate</b></dt><dd><p>The <b class="COMMAND">locate</b> command searches for
          files using a database stored for just that purpose. The
          <b class="COMMAND">slocate</b> command is the secure version of
          <b class="COMMAND">locate</b> (which may be aliased to
          <b class="COMMAND">slocate</b>).</p><p><tt class="USERINPUT"><b>$bash locate hickson</b></tt>
  <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="COMPUTEROUTPUT">/usr/lib/xephem/catalogs/hickson.edb</tt></pre></font></td></tr></tbody></table></p></dd><dt><a name="GETFACLREF"></a><b class="COMMAND">getfacl</b>, <a name="SETFACLREF"></a><b class="COMMAND">setfacl</b></dt><dd><p>These commands <i class="FIRSTTERM">retrieve</i> or
                <i class="FIRSTTERM">set</i> the <b class="COMMAND">f</b>ile
                <b class="COMMAND">a</b>ccess <b class="COMMAND">c</b>ontrol
                <b class="COMMAND">l</b>ist -- the <i class="FIRSTTERM">owner</i>,
          <i class="FIRSTTERM">group</i>, and file permissions.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>getfacl *</b></tt>
  <tt class="COMPUTEROUTPUT"># file: test1.txt
   # owner: bozo
   # group: bozgrp
   user::rw-
   group::rw-
   other::r--
  
   # file: test2.txt
   # owner: bozo
   # group: bozgrp
   user::rw-
   group::rw-
   other::r--</tt>
   
  
   
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>setfacl -m u:bozo:rw yearly_budget.csv</b></tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>getfacl yearly_budget.csv</b></tt>
  <tt class="COMPUTEROUTPUT"># file: yearly_budget.csv
   # owner: accountant
   # group: budgetgrp
   user::rw-
   user:bozo:rw-
   user:accountant:rw-
   group::rw-
   mask::rw-
   other::r--</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="READLINKREF"></a><b class="COMMAND">readlink</b></dt><dd><p>Disclose the file that a symbolic link points to.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>readlink /usr/bin/awk</b></tt>
  <tt class="COMPUTEROUTPUT">../../bin/gawk</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="STRINGSREF"></a><b class="COMMAND">strings</b></dt><dd><p>Use the <b class="COMMAND">strings</b> command to find
          printable strings in a binary or data file. It will list
          sequences of printable characters found in the target
          file. This might be handy for a quick 'n dirty examination
          of a core dump or for looking at an unknown graphic image
          file (<tt class="USERINPUT"><b>strings image-file | more</b></tt> might
          show something like <i class="FIRSTTERM">JFIF</i>,
          which would identify the file as a <i class="FIRSTTERM">jpeg</i>
          graphic). In a script, you would probably
          parse the output of <b class="COMMAND">strings</b>
          with <a href="#GREPREF">grep</a> or <a href="#SEDREF">sed</a>. See <a href="#BINGREP">Example 11-8</a>
          and <a href="#FINDSTRING">Example 11-10</a>.</p><div class="EXAMPLE"><a name="WSTRINGS"></a><p><b>Example 16-34. An <span class="QUOTE">"improved"</span>
          <i class="FIRSTTERM">strings</i> command</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # wstrings.sh: "word-strings" (enhanced "strings" command)
  #
  #  This script filters the output of "strings" by checking it
  #+ against a standard word list file.
  #  This effectively eliminates gibberish and noise,
  #+ and outputs only recognized words.
  
  # ===========================================================
  #                 Standard Check for Script Argument(s)
  ARGS=1
  E_BADARGS=85
  E_NOFILE=86
  
  if [ $# -ne $ARGS ]
  then
    echo "Usage: `basename $0` filename"
    exit $E_BADARGS
  fi
  
  if [ ! -f "$1" ]                      # Check if file exists.
  then
      echo "File \"$1\" does not exist."
      exit $E_NOFILE
  fi
  # ===========================================================
  
  
  MINSTRLEN=3                           #  Minimum string length.
  WORDFILE=/usr/share/dict/linux.words  #  Dictionary file.
  #  May specify a different word list file
  #+ of one-word-per-line format.
  #  For example, the "yawl" word-list package,
  #  http://bash.deta.in/yawl-0.3.2.tar.gz
  
  
  wlist=`strings "$1" | tr A-Z a-z | tr '[:space:]' Z | \
         tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '`
  
  # Translate output of 'strings' command with multiple passes of 'tr'.
  #  "tr A-Z a-z"  converts to lowercase.
  #  "tr '[:space:]'"  converts whitespace characters to Z's.
  #  "tr -cs '[:alpha:]' Z"  converts non-alphabetic characters to Z's,
  #+ and squeezes multiple consecutive Z's.
  #  "tr -s '\173-\377' Z"  converts all characters past 'z' to Z's
  #+ and squeezes multiple consecutive Z's,
  #+ which gets rid of all the weird characters that the previous
  #+ translation failed to deal with.
  #  Finally, "tr Z ' '" converts all those Z's to whitespace,
  #+ which will be seen as word separators in the loop below.
  
  #  ***********************************************************************
  #  Note the technique of feeding/piping the output of 'tr' back to itself,
  #+ but with different arguments and/or options on each successive pass.
  #  ***********************************************************************
  
  
  for word in $wlist                    #  Important:
                                        #  $wlist must not be quoted here.
                                        # "$wlist" does not work.
                                        #  Why not?
  do
    strlen=${#word}                     #  String length.
    if [ "$strlen" -lt "$MINSTRLEN" ]   #  Skip over short strings.
    then
      continue
    fi
  
    grep -Fw $word "$WORDFILE"          #   Match whole words only.
  #      ^^^                            #  "Fixed strings" and
                                        #+ "whole words" options. 
  done  
  
  exit $?</pre></font></td></tr></tbody></table></div></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="COMPARISONN1"></a>Comparison</b></p><dl><dt><a name="DIFFREF"></a><b class="COMMAND">diff</b>, <b class="COMMAND">patch</b></dt><dd><p><b class="COMMAND">diff</b>: flexible file comparison
          utility. It compares the target files line-by-line
          sequentially.  In some applications, such as comparing
          word dictionaries, it may be helpful to filter the
          files through <a href="#SORTREF">sort</a>
          and <b class="COMMAND">uniq</b> before piping them
          to <b class="COMMAND">diff</b>. <tt class="USERINPUT"><b>diff file-1
          file-2</b></tt> outputs the lines in the files that
          differ, with carets showing which file each particular
          line belongs to.</p><p>The <tt class="OPTION">--side-by-side</tt> option to
        <b class="COMMAND">diff</b> outputs each compared file, line by
        line, in separate columns, with non-matching lines marked. The
        <tt class="OPTION">-c</tt> and <tt class="OPTION">-u</tt> options likewise
        make the output of the command easier to interpret.</p><p>There are available various fancy frontends for
        <b class="COMMAND">diff</b>, such as <b class="COMMAND">sdiff</b>,
        <b class="COMMAND">wdiff</b>, <b class="COMMAND">xdiff</b>, and
        <b class="COMMAND">mgdiff</b>. </p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p><a name="DIFFERR2"></a>The <b class="COMMAND">diff</b>
                command returns an exit status of <span class="ERRORCODE">0</span>
                if the compared files are identical, and
                <span class="ERRORCODE">1</span> if they differ (or
                <span class="ERRORCODE">2</span> when <i class="FIRSTTERM">binary</i>
                files are being compared).  This permits use of
                <b class="COMMAND">diff</b> in a test construct within a shell
                script (see below).</p></td></tr></tbody></table></div><p>A common use for <b class="COMMAND">diff</b> is generating
          difference files to be used with <b class="COMMAND">patch</b>
          The <tt class="OPTION">-e</tt> option outputs files suitable
          for <b class="COMMAND">ed</b> or <b class="COMMAND">ex</b>
          scripts.</p><p><a name="PATCHREF"></a></p><p><b class="COMMAND">patch</b>: flexible versioning
          utility. Given a difference file generated by
          <b class="COMMAND">diff</b>, <b class="COMMAND">patch</b> can
          upgrade a previous version of a package to a newer version.
          It is much more convenient to distribute a relatively
          small <span class="QUOTE">"diff"</span> file than the entire body of a
          newly revised package. Kernel <span class="QUOTE">"patches"</span> have
          become the preferred method of distributing the frequent
          releases of the Linux kernel.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">patch -p1 &lt;patch-file
  # Takes all the changes listed in 'patch-file'
  # and applies them to the files referenced therein.
  # This upgrades to a newer version of the package.</pre></font></td></tr></tbody></table></p><p>Patching the kernel:</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">cd /usr/src
  gzip -cd patchXX.gz | patch -p0
  # Upgrading kernel source using 'patch'.
  # From the Linux kernel docs "README",
  # by anonymous author (Alan Cox?).</pre></font></td></tr></tbody></table></p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">diff</b> command can also
          recursively compare directories (for the filenames
          present).</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>diff -r ~/notes1 ~/notes2</b></tt>
  <tt class="COMPUTEROUTPUT">Only in /home/bozo/notes1: file02
   Only in /home/bozo/notes1: file03
   Only in /home/bozo/notes2: file04</tt>
          </pre></font></td></tr></tbody></table>
        </p></td></tr></tbody></table></div><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p><a name="ZDIFFREF"></a></p><p>Use <b class="COMMAND">zdiff</b> to compare
           <i class="FIRSTTERM">gzipped</i> files.</p></td></tr></tbody></table></div><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p><a name="DIFFSTATREF"></a></p><p>Use <b class="COMMAND">diffstat</b> to create
           a histogram (point-distribution graph) of output from
           <b class="COMMAND">diff</b>.</p></td></tr></tbody></table></div></dd><dt><a name="DIFF3REF"></a><b class="COMMAND">diff3</b>, <b class="COMMAND">merge</b></dt><dd><p>An extended version of <b class="COMMAND">diff</b> that compares
          three files at a time. This command returns an exit value
          of 0 upon successful execution, but unfortunately this gives
          no information about the results of the comparison.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>diff3 file-1 file-2 file-3</b></tt>
  <tt class="COMPUTEROUTPUT">====
   1:1c
     This is line 1 of "file-1".
   2:1c
     This is line 1 of "file-2".
   3:1c
     This is line 1 of "file-3"</tt>
          </pre></font></td></tr></tbody></table>
          </p><p><a name="MERGEREF"></a>The <b class="COMMAND">merge</b>
          (3-way file merge) command is an interesting adjunct to
          <i class="FIRSTTERM">diff3</i>. Its syntax is
          <tt class="USERINPUT"><b>merge Mergefile file1 file2</b></tt>.
          The result is to output to <tt class="FILENAME">Mergefile</tt>
          the changes that lead from <tt class="FILENAME">file1</tt>
          to <tt class="FILENAME">file2</tt>. Consider this command
          a stripped-down version of <i class="FIRSTTERM">patch</i>.</p></dd><dt><a name="SDIFFREF"></a><b class="COMMAND">sdiff</b></dt><dd><p>Compare and/or edit two files in order to merge
          them into an output file. Because of its interactive nature,
          this command would find little use in a script.</p></dd><dt><a name="CMPREF"></a><b class="COMMAND">cmp</b></dt><dd><p>The <b class="COMMAND">cmp</b> command is a simpler version of
          <b class="COMMAND">diff</b>, above. Whereas <b class="COMMAND">diff</b>
          reports the differences between two files,
          <b class="COMMAND">cmp</b> merely shows at what point they
          differ.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>Like <b class="COMMAND">diff</b>, <b class="COMMAND">cmp</b>
        returns an exit status of 0 if the compared files are
        identical, and 1 if they differ. This permits use in a test
        construct within a shell script.</p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="FILECOMP"></a><p><b>Example 16-35. Using <i class="FIRSTTERM">cmp</i> to compare two files
            within a script.</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # file-comparison.sh
  
  ARGS=2  # Two args to script expected.
  E_BADARGS=85
  E_UNREADABLE=86
  
  if [ $# -ne "$ARGS" ]
  then
    echo "Usage: `basename $0` file1 file2"
    exit $E_BADARGS
  fi
  
  if [[ ! -r "$1" || ! -r "$2" ]]
  then
    echo "Both files to be compared must exist and be readable."
    exit $E_UNREADABLE
  fi
  
  cmp $1 $2 &amp;&gt; /dev/null
  #   Redirection to /dev/null buries the output of the "cmp" command.
  #   cmp -s $1 $2  has same result ("-s" silent flag to "cmp")
  #   Thank you  Anders Gustavsson for pointing this out.
  #
  #  Also works with 'diff', i.e.,
  #+ diff $1 $2 &amp;&gt; /dev/null
  
  if [ $? -eq 0 ]         # Test exit status of "cmp" command.
  then
    echo "File \"$1\" is identical to file \"$2\"."
  else  
    echo "File \"$1\" differs from file \"$2\"."
  fi
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>Use <b class="COMMAND">zcmp</b> on
          <i class="FIRSTTERM">gzipped</i> files.</p></td></tr></tbody></table></div></dd><dt><a name="COMMREF"></a><b class="COMMAND">comm</b></dt><dd><p>Versatile file comparison utility. The files must be
          sorted for this to be useful.</p><p><b class="COMMAND">comm
      <tt class="REPLACEABLE"><i>-options</i></tt>
      <tt class="REPLACEABLE"><i>first-file</i></tt>
      <tt class="REPLACEABLE"><i>second-file</i></tt></b></p><p><tt class="USERINPUT"><b>comm file-1 file-2</b></tt> outputs three columns:
          </p><p></p><ul><li><p>column 1 = lines unique to <tt class="FILENAME">file-1</tt></p></li><li><p>column 2 = lines unique to <tt class="FILENAME">file-2</tt></p></li><li><p>column 3 = lines common to both.</p></li></ul><p></p><p>The options allow suppressing output of one or more columns.
          </p><p></p><ul><li><p><tt class="OPTION">-1</tt> suppresses column
          <tt class="LITERAL">1</tt></p></li><li><p><tt class="OPTION">-2</tt> suppresses column
          <tt class="LITERAL">2</tt></p></li><li><p><tt class="OPTION">-3</tt> suppresses column
          <tt class="LITERAL">3</tt></p></li><li><p><tt class="OPTION">-12</tt> suppresses both columns
          <tt class="LITERAL">1</tt> and <tt class="LITERAL">2</tt>, etc.</p></li></ul>
        <p></p><p>This command is useful for comparing
          <span class="QUOTE">"dictionaries"</span> or <i class="FIRSTTERM">word
          lists</i> -- sorted text files with one word per
          line.</p></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="FAUTILS1"></a>Utilities</b></p><dl><dt><a name="BASENAMEREF"></a><b class="COMMAND">basename</b></dt><dd><p>Strips the path information from a file name, printing
          only the file name. The construction  <tt class="USERINPUT"><b>basename
      $0</b></tt> lets the script know its name, that is, the name it
          was invoked by. This can be used for <span class="QUOTE">"usage"</span> messages if, 
          for example a script is called with missing arguments:
                <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo "Usage: `basename $0` arg1 arg2 ... argn"</pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="DIRNAMEREF"></a><b class="COMMAND">dirname</b></dt><dd><p>Strips the <b class="COMMAND">basename</b> from
        a filename, printing only the path information.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p><b class="COMMAND">basename</b> and <b class="COMMAND">dirname</b>
      can operate on any arbitrary string. The argument
      does not need to refer to an existing file, or
      even be a filename for that matter (see <a href="#DAYSBETWEEN">Example A-7</a>).</p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="EX35"></a><p><b>Example 16-36. <i class="FIRSTTERM">basename</i> and
          <i class="FIRSTTERM">dirname</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  address=/home/bozo/daily-journal.txt
  
  echo "Basename of /home/bozo/daily-journal.txt = `basename $address`"
  echo "Dirname of /home/bozo/daily-journal.txt = `dirname $address`"
  echo
  echo "My own home is `basename ~/`."         # `basename ~` also works.
  echo "The home of my home is `dirname ~/`."  # `dirname ~`  also works.
  
  exit 0</pre></font></td></tr></tbody></table></div></dd><dt><a name="SPLITREF"></a><b class="COMMAND">split</b>, <a name="CSPLITREF"></a><b class="COMMAND">csplit</b></dt><dd><p>These are utilities for splitting a file into smaller
          chunks. Their usual use is for splitting up large files
          in order to back them up on floppies or preparatory to
          e-mailing or uploading them.</p><p>The <b class="COMMAND">csplit</b> command splits a file
          according to <i class="FIRSTTERM">context</i>, the split occuring
          where patterns are matched.</p><div class="EXAMPLE"><a name="SPLITCOPY"></a><p><b>Example 16-37. A script that copies itself in sections</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # splitcopy.sh
  
  #  A script that splits itself into chunks,
  #+ then reassembles the chunks into an exact copy
  #+ of the original script.
  
  CHUNKSIZE=4    #  Size of first chunk of split files.
  OUTPREFIX=xx   #  csplit prefixes, by default,
                 #+ files with "xx" ...
  
  csplit "$0" "$CHUNKSIZE"
  
  # Some comment lines for padding . . .
  # Line 15
  # Line 16
  # Line 17
  # Line 18
  # Line 19
  # Line 20
  
  cat "$OUTPREFIX"* &gt; "$0.copy"  # Concatenate the chunks.
  rm "$OUTPREFIX"*               # Get rid of the chunks.
  
  exit $?</pre></font></td></tr></tbody></table></div></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="FAENCENCR1"></a>Encoding and Encryption</b></p><dl><dt><a name="SUMREF"></a><b class="COMMAND">sum</b>, <a name="CKSUMREF"></a><b class="COMMAND">cksum</b>, <a name="MD5SUMREF"></a><b class="COMMAND">md5sum</b>, <a name="SHA1SUMREF"></a><b class="COMMAND">sha1sum</b></dt><dd><p><a name="CHECKSUMREF"></a>These are utilities for
                generating <i class="FIRSTTERM">checksums</i>. A
          <i class="FIRSTTERM">checksum</i> is a number
  
      <a name="AEN12840" href="#FTN.AEN12840"><span class="footnote">[77]</span></a>
  
                mathematically calculated from the contents of a file,
                for the purpose of checking its integrity. A script might
                refer to a list of checksums for security purposes, such
                as ensuring that the contents of key system files have not
                been altered or corrupted. For security applications, use
                the <b class="COMMAND">md5sum</b> (<b class="COMMAND">m</b>essage
                <b class="COMMAND">d</b>igest <b class="COMMAND">5</b>
                check<b class="COMMAND">sum</b>) command, or better yet, the
                newer <b class="COMMAND">sha1sum</b> (Secure Hash Algorithm).
  
            <a name="AEN12849" href="#FTN.AEN12849"><span class="footnote">[78]</span></a>
              </p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cksum /boot/vmlinuz</b></tt>
  <tt class="COMPUTEROUTPUT">1670054224 804083 /boot/vmlinuz</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo -n "Top Secret" | cksum</b></tt>
  <tt class="COMPUTEROUTPUT">3391003827 10</tt>
  
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>md5sum /boot/vmlinuz</b></tt>
  <tt class="COMPUTEROUTPUT">0f43eccea8f09e0a0b2b5cf1dcf333ba  /boot/vmlinuz</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo -n "Top Secret" | md5sum</b></tt>
  <tt class="COMPUTEROUTPUT">8babc97a6f62a4649716f4df8d61728f  -</tt>
          </pre></font></td></tr></tbody></table>
      </p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">cksum</b> command shows the size,
        in bytes, of its target, whether file or
        <tt class="FILENAME">stdout</tt>.</p><p>The <b class="COMMAND">md5sum</b> and
        <b class="COMMAND">sha1sum</b> commands display a
        <a href="#DASHREF2">dash</a> when they receive their input from
        <tt class="FILENAME">stdout</tt>.</p></td></tr></tbody></table></div><div class="EXAMPLE"><a name="FILEINTEGRITY"></a><p><b>Example 16-38. Checking file integrity</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # file-integrity.sh: Checking whether files in a given directory
  #                    have been tampered with.
  
  E_DIR_NOMATCH=80
  E_BAD_DBFILE=81
  
  dbfile=File_record.md5
  # Filename for storing records (database file).
  
  
  set_up_database ()
  {
    echo ""$directory"" &gt; "$dbfile"
    # Write directory name to first line of file.
    md5sum "$directory"/* &gt;&gt; "$dbfile"
    # Append md5 checksums and filenames.
  }
  
  check_database ()
  {
    local n=0
    local filename
    local checksum
  
    # ------------------------------------------- #
    #  This file check should be unnecessary,
    #+ but better safe than sorry.
  
    if [ ! -r "$dbfile" ]
    then
      echo "Unable to read checksum database file!"
      exit $E_BAD_DBFILE
    fi
    # ------------------------------------------- #
  
    while read record[n]
    do
  
      directory_checked="${record[0]}"
      if [ "$directory_checked" != "$directory" ]
      then
        echo "Directories do not match up!"
        # Tried to use file for a different directory.
        exit $E_DIR_NOMATCH
      fi
  
      if [ "$n" -gt 0 ]   # Not directory name.
      then
        filename[n]=$( echo ${record[$n]} | awk '{ print $2 }' )
        #  md5sum writes records backwards,
        #+ checksum first, then filename.
        checksum[n]=$( md5sum "${filename[n]}" )
  
  
        if [ "${record[n]}" = "${checksum[n]}" ]
        then
          echo "${filename[n]} unchanged."
  
          elif [ "`basename ${filename[n]}`" != "$dbfile" ]
                 #  Skip over checksum database file,
                 #+ as it will change with each invocation of script.
                 #  ---
                 #  This unfortunately means that when running
                 #+ this script on $PWD, tampering with the
                 #+ checksum database file will not be detected.
                 #  Exercise: Fix this.
          then
            echo "${filename[n]} : CHECKSUM ERROR!"
          # File has been changed since last checked.
          fi
  
        fi
  
  
  
      let "n+=1"
    done &lt;"$dbfile"       # Read from checksum database file. 
  
  }  
  
  # =================================================== #
  # main ()
  
  if [ -z  "$1" ]
  then
    directory="$PWD"      #  If not specified,
  else                    #+ use current working directory.
    directory="$1"
  fi  
  
  clear                   # Clear screen.
  echo " Running file integrity check on $directory"
  echo
  
  # ------------------------------------------------------------------ #
    if [ ! -r "$dbfile" ] # Need to create database file?
    then
      echo "Setting up database file, \""$directory"/"$dbfile"\"."; echo
      set_up_database
    fi  
  # ------------------------------------------------------------------ #
  
  check_database          # Do the actual work.
  
  echo 
  
  #  You may wish to redirect the stdout of this script to a file,
  #+ especially if the directory checked has many files in it.
  
  exit 0
  
  #  For a much more thorough file integrity check,
  #+ consider the "Tripwire" package,
  #+ http://sourceforge.net/projects/tripwire/.</pre></font></td></tr></tbody></table></div><p>Also see <a href="#DIRECTORYINFO">Example A-19</a>, <a href="#HORSERACE">Example 36-16</a>, and <a href="#RANDSTRING">Example 10-2</a> for
        creative uses of the <b class="COMMAND">md5sum</b> command.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>	    There have been reports that the 128-bit
        <b class="COMMAND">md5sum</b> can be cracked, so the more secure
        160-bit <b class="COMMAND">sha1sum</b> is a welcome new addition
        to the checksum toolkit.
            </p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>md5sum testfile</b></tt>
  <tt class="COMPUTEROUTPUT">e181e2c8720c60522c4c4c981108e367  testfile</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>sha1sum testfile</b></tt>
  <tt class="COMPUTEROUTPUT">5d7425a9c08a66c3177f1e31286fa40986ffc996  testfile</tt>
          </pre></font></td></tr></tbody></table></td></tr></tbody></table></div><p>Security consultants have demonstrated that even
          <b class="COMMAND">sha1sum</b> can be compromised. Fortunately,
          newer Linux distros include longer bit-length
          <b class="COMMAND">sha224sum</b>,
          <b class="COMMAND">sha256sum</b>,
          <b class="COMMAND">sha384sum</b>, and
          <b class="COMMAND">sha512sum</b> commands.</p></dd><dt><a name="UUENCODEREF"></a><b class="COMMAND">uuencode</b></dt><dd><p>This utility encodes binary files (images, sound files,
          compressed files, etc.) into <a href="#ASCIIDEF">ASCII</a> characters, making
          them suitable for transmission in the body of an
          e-mail message or in a newsgroup posting. This is
          especially useful where MIME (multimedia) encoding
          is not available.</p></dd><dt><a name="UUDECODEREF"></a><b class="COMMAND">uudecode</b></dt><dd><p>This reverses the encoding, decoding
          <i class="FIRSTTERM">uuencoded</i> files back into the
          original binaries.</p><div class="EXAMPLE"><a name="EX52"></a><p><b>Example 16-39. Uudecoding encoded files</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Uudecodes all uuencoded files in current working directory.
  
  lines=35        # Allow 35 lines for the header (very generous).
  
  for File in *   # Test all the files in $PWD.
  do
    search1=`head -n $lines $File | grep begin | wc -w`
    search2=`tail -n $lines $File | grep end | wc -w`
    #  Uuencoded files have a "begin" near the beginning,
    #+ and an "end" near the end.
    if [ "$search1" -gt 0 ]
    then
      if [ "$search2" -gt 0 ]
      then
        echo "uudecoding - $File -"
        uudecode $File
      fi  
    fi
  done  
  
  #  Note that running this script upon itself fools it
  #+ into thinking it is a uuencoded file,
  #+ because it contains both "begin" and "end".
  
  #  Exercise:
  #  --------
  #  Modify this script to check each file for a newsgroup header,
  #+ and skip to next if not found.
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>The <a href="#FOLDREF">fold -s</a> command
        may be useful (possibly in a pipe) to process long uudecoded
        text messages downloaded from Usenet newsgroups.</p></td></tr></tbody></table></div></dd><dt><a name="MIMENCODEREF"></a><b class="COMMAND">mimencode</b>, <a name="MMENCODEREF"></a><b class="COMMAND">mmencode</b></dt><dd><p>The <b class="COMMAND">mimencode</b> and
          <b class="COMMAND">mmencode</b> commands process
          multimedia-encoded e-mail attachments. Although
          <i class="FIRSTTERM">mail user agents</i> (such as
          <i class="FIRSTTERM">pine</i> or <i class="FIRSTTERM">kmail</i>)
          normally handle this automatically, these particular
          utilities permit manipulating such attachments manually from
          the command-line or in <a href="#BATCHPROCREF">batch
          processing mode</a> by means of a shell script.</p></dd><dt><a name="CRYPTREF"></a><b class="COMMAND">crypt</b></dt><dd><p>At one time, this was the standard UNIX file encryption
          utility.
  
                <a name="AEN12969" href="#FTN.AEN12969"><span class="footnote">[79]</span></a>
  
          Politically-motivated government regulations
          prohibiting the export of encryption software resulted
          in the disappearance of <b class="COMMAND">crypt</b>
          from much of the UNIX world, and it is still
          missing from most Linux distributions. Fortunately,
          programmers have come up with a number of decent
          alternatives to it, among them the author's very own <a href="ftp://metalab.unc.edu/pub/Linux/utils/file/cruft-0.2.tar.gz" target="_top">cruft</a>
          (see <a href="#ENCRYPTEDPW">Example A-4</a>).  </p></dd><dt><a name="OPENSSLREF"></a><b class="COMMAND">openssl</b></dt><dd><p>This is an Open Source implementation of
               <i class="FIRSTTERM">Secure Sockets Layer</i> encryption.
  
         <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># To encrypt a file:
  openssl aes-128-ecb -salt -in file.txt -out file.encrypted \
  -pass pass:my_password
  #          ^^^^^^^^^^^   User-selected password.
  #       aes-128-ecb      is the encryption method chosen.
  
  # To decrypt an openssl-encrypted file:
  openssl aes-128-ecb -d -salt -in file.encrypted -out file.txt \
  -pass pass:my_password
  #          ^^^^^^^^^^^   User-selected password.</pre></font></td></tr></tbody></table></p><p><a href="#PIPEREF">Piping</a>
               <i class="FIRSTTERM">openssl</i> to/from <a href="#TARREF">tar</a> makes it possible to encrypt
               an entire directory tree.
       
              <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># To encrypt a directory:
  
  sourcedir="/home/bozo/testfiles"
  encrfile="encr-dir.tar.gz"
  password=my_secret_password
  
  tar czvf - "$sourcedir" |
  openssl des3 -salt -out "$encrfile" -pass pass:"$password"
  #       ^^^^   Uses des3 encryption.
  # Writes encrypted file "encr-dir.tar.gz" in current working directory.
  
  # To decrypt the resulting tarball:
  openssl des3 -d -salt -in "$encrfile" -pass pass:"$password" |
  tar -xzv
  # Decrypts and unpacks into current working directory.</pre></font></td></tr></tbody></table>
  
             </p><p>Of course, <i class="FIRSTTERM">openssl</i> has many other uses,
               such as obtaining signed <i class="FIRSTTERM">certificates</i>
         for Web sites. See the <a href="#INFOREF">info</a>
         page.</p></dd><dt><a name="SHREDREF"></a><b class="COMMAND">shred</b></dt><dd><p>Securely erase a file by overwriting it multiple times with
          random bit patterns before deleting it. This command has
          the same effect as <a href="#BLOTOUT">Example 16-61</a>, but does it
          in a more thorough and elegant manner.</p><p>This is one of the GNU
        <i class="FIRSTTERM">fileutils</i>.</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>Advanced forensic technology may still be able to
          recover the contents of a file, even after application of
          <b class="COMMAND">shred</b>.</p></td></tr></tbody></table></div></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="FAMISC1"></a>Miscellaneous</b></p><dl><dt><a name="MKTEMPREF"></a><b class="COMMAND">mktemp</b></dt><dd><p>Create a <i class="FIRSTTERM">temporary file</i>
  
           <a name="AEN13030" href="#FTN.AEN13030"><span class="footnote">[80]</span></a>
  
          with a <span class="QUOTE">"unique"</span> filename. When invoked
          from the command-line without additional arguments,
          it creates a zero-length file in the <tt class="FILENAME">/tmp</tt> directory.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>mktemp</b></tt>
  <tt class="COMPUTEROUTPUT">/tmp/tmp.zzsvql3154</tt>
          </pre></font></td></tr></tbody></table>
        </p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">PREFIX=filename
  tempfile=`mktemp $PREFIX.XXXXXX`
  #                        ^^^^^^ Need at least 6 placeholders
  #+                              in the filename template.
  #   If no filename template supplied,
  #+ "tmp.XXXXXXXXXX" is the default.
  
  echo "tempfile name = $tempfile"
  # tempfile name = filename.QA2ZpY
  #                 or something similar...
  
  #  Creates a file of that name in the current working directory
  #+ with 600 file permissions.
  #  A "umask 177" is therefore unnecessary,
  #+ but it's good programming practice nevertheless.</pre></font></td></tr></tbody></table></p></dd><dt><a name="MAKEREF"></a><b class="COMMAND">make</b></dt><dd><p><a name="MAKEFILEREF"></a></p><p>Utility for building and compiling binary packages. 
          This can also be used for any set of operations triggered
          by incremental changes in source files.</p><p>The <i class="FIRSTTERM">make</i> command checks a
        <tt class="FILENAME">Makefile</tt>, a list of file dependencies and
          operations to be carried out.</p><p>The <i class="FIRSTTERM">make</i> utility is, in effect,
          a powerful scripting language similar in many ways to
          <i class="FIRSTTERM">Bash</i>, but with the capability of
          recognizing <i class="FIRSTTERM">dependencies</i>. For in-depth
          coverage of this useful tool set, see the <a href="http://www.gnu.org/manual/manual.html" target="_top">GNU software
          documentation site</a>.</p></dd><dt><a name="INSTALLREF"></a><b class="COMMAND">install</b></dt><dd><p>Special purpose file copying command, similar to
          <a href="#CPREF">cp</a>, but capable of
          setting permissions and attributes of the copied
          files. This command seems tailormade for installing
          software packages, and as such it shows up frequently in
          <tt class="FILENAME">Makefiles</tt> (in the <tt class="REPLACEABLE"><i>make
          install :</i></tt> section). It could likewise prove
          useful in installation scripts.</p></dd><dt><a name="DOS2UNIXREF"></a><b class="COMMAND">dos2unix</b></dt><dd><p>This utility, written by Benjamin Lin and collaborators,
          converts DOS-formatted text files (lines terminated by
          CR-LF) to UNIX format (lines terminated by LF only),
          and <a href="#DOSNEWLINES">vice-versa</a>.</p></dd><dt><a name="PTXREF"></a><b class="COMMAND">ptx</b></dt><dd><p>The <b class="COMMAND">ptx [targetfile]</b> command
          outputs a permuted index (cross-reference list) of the
          targetfile. This may be further filtered and formatted in a
          pipe, if necessary.</p></dd><dt><a name="MOREREF"></a><b class="COMMAND">more</b>, <a name="LESSREF"></a><b class="COMMAND">less</b></dt><dd><p>Pagers that display a text file or stream to
          <tt class="FILENAME">stdout</tt>, one screenful at a time.
          These may be used to filter the output of
          <tt class="FILENAME">stdout</tt> . . . or of a script.</p><p>	       An interesting application of <i class="FIRSTTERM">more</i>
           is to <span class="QUOTE">"test drive"</span> a command sequence,
           to forestall potentially unpleasant consequences.
                   <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">ls /home/bozo | awk '{print "rm -rf " $1}' | more
  #                                            ^^^^
       
  # Testing the effect of the following (disastrous) command-line:
  #      ls /home/bozo | awk '{print "rm -rf " $1}' | sh
  #      Hand off to the shell to execute . . .       ^^</pre></font></td></tr></tbody></table>
              </p><p>The <i class="FIRSTTERM">less</i> pager has the
          interesting property of doing a formatted display of
          <i class="FIRSTTERM">man page</i> source. See <a href="#MANED">Example A-39</a>.</p></dd></dl></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="COMMUNICATIONS"></a>16.6. Communications Commands</h1><p>Certain of the following commands find use in
      network data transfer and analysis, as well as in
      <a href="#CSPAMMERS">chasing spammers</a>.</p><p></p><div class="VARIABLELIST"><p><b><a name="COMMUNINFO1"></a>Information and Statistics</b></p><dl><dt><a name="HOSTREF"></a><b class="COMMAND">host</b></dt><dd><p>Searches for information about an Internet host by name or
          IP address, using DNS.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>host surfacemail.com</b></tt>
  <tt class="COMPUTEROUTPUT">surfacemail.com. has address 202.92.42.236</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="IPCALCREF"></a><b class="COMMAND">ipcalc</b></dt><dd><p>Displays IP information for a host.
          With the <tt class="OPTION">-h</tt> option,
          <b class="COMMAND">ipcalc</b> does a reverse DNS lookup, finding
          the name of the host (server) from the IP address.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ipcalc -h 202.92.42.236</b></tt>
  <tt class="COMPUTEROUTPUT">HOSTNAME=surfacemail.com</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="NSLOOKUPREF"></a><b class="COMMAND">nslookup</b></dt><dd><p>Do an Internet <span class="QUOTE">"name server lookup"</span>
          on a host by IP address. This is essentially equivalent
          to <b class="COMMAND">ipcalc -h</b> or <b class="COMMAND">dig -x
          </b>. The command may be run either interactively
          or noninteractively, i.e., from within a script.</p><p>The <b class="COMMAND">nslookup</b> command has allegedly
          been <span class="QUOTE">"deprecated,"</span> but it is still useful.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>nslookup -sil 66.97.104.180</b></tt>
  <tt class="COMPUTEROUTPUT">nslookup kuhleersparnis.ch
   Server:         135.116.137.2
   Address:        135.116.137.2#53
  
   Non-authoritative answer:
   Name:   kuhleersparnis.ch</tt>
          </pre></font></td></tr></tbody></table>
      </p></dd><dt><a name="DIGREF"></a><b class="COMMAND">dig</b></dt><dd><p><b class="COMMAND">D</b>omain <b class="COMMAND">I</b>nformation
          <b class="COMMAND">G</b>roper. Similar to
          <b class="COMMAND">nslookup</b>, <i class="FIRSTTERM">dig</i> does
          an Internet <i class="FIRSTTERM">name server lookup</i> on a host.
          May be run from the command-line or from within a script.</p><p>Some interesting options to <i class="FIRSTTERM">dig</i> are
          <tt class="OPTION">+time=N</tt> for setting a query timeout to
          <tt class="PARAMETER"><i>N</i></tt> seconds, <tt class="OPTION">+nofail</tt> for
          continuing to query servers until a reply is received, and
          <tt class="OPTION">-x</tt> for doing a reverse address lookup.</p><p>Compare the output of <b class="COMMAND">dig -x</b> with
          <b class="COMMAND">ipcalc -h</b> and
          <b class="COMMAND">nslookup</b>.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>dig -x 81.9.6.2</b></tt>
  <tt class="COMPUTEROUTPUT">;; Got answer:
   ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 11649
   ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0
  
   ;; QUESTION SECTION:
   ;2.6.9.81.in-addr.arpa.         IN      PTR
  
   ;; AUTHORITY SECTION:
   6.9.81.in-addr.arpa.    3600    IN      SOA     ns.eltel.net. noc.eltel.net.
   2002031705 900 600 86400 3600
  
   ;; Query time: 537 msec
   ;; SERVER: 135.116.137.2#53(135.116.137.2)
   ;; WHEN: Wed Jun 26 08:35:24 2002
   ;; MSG SIZE  rcvd: 91</tt>
          </pre></font></td></tr></tbody></table>
      </p><p><a name="SPAMLOOKUP_0"></a></p><div class="EXAMPLE"><a name="SPAMLOOKUP"></a><p><b>Example 16-40. Finding out where to report a spammer</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # spam-lookup.sh: Look up abuse contact to report a spammer.
  # Thanks, Michael Zick.
  
  # Check for command-line arg.
  ARGCOUNT=1
  E_WRONGARGS=85
  if [ $# -ne "$ARGCOUNT" ]
  then
    echo "Usage: `basename $0` domain-name"
    exit $E_WRONGARGS
  fi
  
  
  dig +short $1.contacts.abuse.net -c in -t txt
  # Also try:
  #     dig +nssearch $1
  #     Tries to find "authoritative name servers" and display SOA records.
  
  # The following also works:
  #     whois -h whois.abuse.net $1
  #           ^^ ^^^^^^^^^^^^^^^  Specify host.  
  #     Can even lookup multiple spammers with this, i.e."
  #     whois -h whois.abuse.net $spamdomain1 $spamdomain2 . . .
  
  
  #  Exercise:
  #  --------
  #  Expand the functionality of this script
  #+ so that it automatically e-mails a notification
  #+ to the responsible ISP's contact address(es).
  #  Hint: use the "mail" command.
  
  exit $?
  
  # spam-lookup.sh chinatietong.com
  #                A known spam domain.
  
  # "crnet_mgr@chinatietong.com"
  # "crnet_tec@chinatietong.com"
  # "postmaster@chinatietong.com"
  
  
  #  For a more elaborate version of this script,
  #+ see the SpamViz home page, http://www.spamviz.net/index.html.</pre></font></td></tr></tbody></table></div><p><a name="ISSPAMMER_0"></a></p><div class="EXAMPLE"><a name="ISSPAMMER"></a><p><b>Example 16-41. Analyzing a spam domain</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#! /bin/bash
  # is-spammer.sh: Identifying spam domains
  
  # $Id: is-spammer, v 1.4 2004/09/01 19:37:52 mszick Exp $
  # Above line is RCS ID info.
  #
  #  This is a simplified version of the "is_spammer.bash
  #+ script in the Contributed Scripts appendix.
  
  # is-spammer &lt;domain.name&gt;
  
  # Uses an external program: 'dig'
  # Tested with version: 9.2.4rc5
  
  # Uses functions.
  # Uses IFS to parse strings by assignment into arrays.
  # And even does something useful: checks e-mail blacklists.
  
  # Use the domain.name(s) from the text body:
  # http://www.good_stuff.spammer.biz/just_ignore_everything_else
  #                       ^^^^^^^^^^^
  # Or the domain.name(s) from any e-mail address:
  # Really_Good_Offer@spammer.biz
  #
  # as the only argument to this script.
  #(PS: have your Inet connection running)
  #
  # So, to invoke this script in the above two instances:
  #       is-spammer.sh spammer.biz
  
  
  # Whitespace == :Space:Tab:Line Feed:Carriage Return:
  WSP_IFS=$'\x20'$'\x09'$'\x0A'$'\x0D'
  
  # No Whitespace == Line Feed:Carriage Return
  No_WSP=$'\x0A'$'\x0D'
  
  # Field separator for dotted decimal ip addresses
  ADR_IFS=${No_WSP}'.'
  
  # Get the dns text resource record.
  # get_txt &lt;error_code&gt; &lt;list_query&gt;
  get_txt() {
  
      # Parse $1 by assignment at the dots.
      local -a dns
      IFS=$ADR_IFS
      dns=( $1 )
      IFS=$WSP_IFS
      if [ "${dns[0]}" == '127' ]
      then
          # See if there is a reason.
          echo $(dig +short $2 -t txt)
      fi
  }
  
  # Get the dns address resource record.
  # chk_adr &lt;rev_dns&gt; &lt;list_server&gt;
  chk_adr() {
      local reply
      local server
      local reason
  
      server=${1}${2}
      reply=$( dig +short ${server} )
  
      # If reply might be an error code . . .
      if [ ${#reply} -gt 6 ]
      then
          reason=$(get_txt ${reply} ${server} )
          reason=${reason:-${reply}}
      fi
      echo ${reason:-' not blacklisted.'}
  }
  
  # Need to get the IP address from the name.
  echo 'Get address of: '$1
  ip_adr=$(dig +short $1)
  dns_reply=${ip_adr:-' no answer '}
  echo ' Found address: '${dns_reply}
  
  # A valid reply is at least 4 digits plus 3 dots.
  if [ ${#ip_adr} -gt 6 ]
  then
      echo
      declare query
  
      # Parse by assignment at the dots.
      declare -a dns
      IFS=$ADR_IFS
      dns=( ${ip_adr} )
      IFS=$WSP_IFS
  
      # Reorder octets into dns query order.
      rev_dns="${dns[3]}"'.'"${dns[2]}"'.'"${dns[1]}"'.'"${dns[0]}"'.'
  
  # See: http://www.spamhaus.org (Conservative, well maintained)
      echo -n 'spamhaus.org says: '
      echo $(chk_adr ${rev_dns} 'sbl-xbl.spamhaus.org')
  
  # See: http://ordb.org (Open mail relays)
      echo -n '   ordb.org  says: '
      echo $(chk_adr ${rev_dns} 'relays.ordb.org')
  
  # See: http://www.spamcop.net/ (You can report spammers here)
      echo -n ' spamcop.net says: '
      echo $(chk_adr ${rev_dns} 'bl.spamcop.net')
  
  # # # other blacklist operations # # #
  
  # See: http://cbl.abuseat.org.
      echo -n ' abuseat.org says: '
      echo $(chk_adr ${rev_dns} 'cbl.abuseat.org')
  
  # See: http://dsbl.org/usage (Various mail relays)
      echo
      echo 'Distributed Server Listings'
      echo -n '       list.dsbl.org says: '
      echo $(chk_adr ${rev_dns} 'list.dsbl.org')
  
      echo -n '   multihop.dsbl.org says: '
      echo $(chk_adr ${rev_dns} 'multihop.dsbl.org')
  
      echo -n 'unconfirmed.dsbl.org says: '
      echo $(chk_adr ${rev_dns} 'unconfirmed.dsbl.org')
  
  else
      echo
      echo 'Could not use that address.'
  fi
  
  exit 0
  
  # Exercises:
  # --------
  
  # 1) Check arguments to script,
  #    and exit with appropriate error message if necessary.
  
  # 2) Check if on-line at invocation of script,
  #    and exit with appropriate error message if necessary.
  
  # 3) Substitute generic variables for "hard-coded" BHL domains.
  
  # 4) Set a time-out for the script using the "+time=" option
       to the 'dig' command.</pre></font></td></tr></tbody></table></div><p>For a much more elaborate version of the above script, see 
        <a href="#ISSPAMMER2">Example A-28</a>.</p></dd><dt><a name="TRACEROUTEREF"></a><b class="COMMAND">traceroute</b></dt><dd><p>Trace the route taken by packets sent to a remote host. This
          command works within a LAN, WAN, or over the
          Internet. The remote host may be specified by an IP
          address. The output of this command may be filtered
          by <a href="#GREPREF">grep</a> or <a href="#SEDREF">sed</a> in a pipe.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>traceroute 81.9.6.2</b></tt>
  <tt class="COMPUTEROUTPUT">traceroute to 81.9.6.2 (81.9.6.2), 30 hops max, 38 byte packets
   1  tc43.xjbnnbrb.com (136.30.178.8)  191.303 ms  179.400 ms  179.767 ms
   2  or0.xjbnnbrb.com (136.30.178.1)  179.536 ms  179.534 ms  169.685 ms
   3  192.168.11.101 (192.168.11.101)  189.471 ms  189.556 ms *
   ...</tt>
          </pre></font></td></tr></tbody></table>
      </p></dd><dt><a name="PINGREF"></a><b class="COMMAND">ping</b></dt><dd><p>Broadcast an <tt class="REPLACEABLE"><i>ICMP
          ECHO_REQUEST</i></tt> packet to another machine,
                either on a local or remote network. This is a
                diagnostic tool for testing network connections,
                and it should be used with caution.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ping localhost</b></tt>
  <tt class="COMPUTEROUTPUT">PING localhost.localdomain (127.0.0.1) from 127.0.0.1 : 56(84) bytes of data.
   64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=0 ttl=255 time=709 usec
   64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=1 ttl=255 time=286 usec
  
   --- localhost.localdomain ping statistics ---
   2 packets transmitted, 2 packets received, 0% packet loss
   round-trip min/avg/max/mdev = 0.286/0.497/0.709/0.212 ms</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>A successful <i class="FIRSTTERM">ping</i> returns
          an <a href="#EXITSTATUSREF">exit status</a> of
          <span class="ERRORCODE">0</span>. This can be tested for in a
          script.</p><p><a name="PING0"></a></p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">  HNAME=news-15.net  # Notorious spammer.
  # HNAME=$HOST     # Debug: test for localhost.
    count=2  # Send only two pings.
  
  if [[ `ping -c $count "$HNAME"` ]]
  then
    echo ""$HNAME" still up and broadcasting spam your way."
  else
    echo ""$HNAME" seems to be down. Pity."
  fi</pre></font></td></tr></tbody></table></p></dd><dt><a name="WHOISREF"></a><b class="COMMAND">whois</b></dt><dd><p>Perform a DNS (Domain Name System) lookup.
          The <tt class="OPTION">-h</tt> option permits specifying which
          particular <i class="FIRSTTERM">whois</i> server to query. See
          <a href="#EX18">Example 4-6</a> and <a href="#SPAMLOOKUP">Example 16-40</a>.</p></dd><dt><a name="FINGERREF"></a><b class="COMMAND">finger</b></dt><dd><p>Retrieve information about users on a
          network. Optionally, this command can display
          a user's <tt class="FILENAME">~/.plan</tt>,
          <tt class="FILENAME">~/.project</tt>, and
          <tt class="FILENAME">~/.forward</tt> files, if present.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>finger</b></tt>
  <tt class="COMPUTEROUTPUT">Login  Name           Tty      Idle  Login Time   Office     Office Phone
   bozo   Bozo Bozeman   tty1        8  Jun 25 16:59                (:0)
   bozo   Bozo Bozeman   ttyp0          Jun 25 16:59                (:0.0)
   bozo   Bozo Bozeman   ttyp1          Jun 25 17:07                (:0.0)</tt>
  
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>finger bozo</b></tt>
  <tt class="COMPUTEROUTPUT">Login: bozo                             Name: Bozo Bozeman
   Directory: /home/bozo                   Shell: /bin/bash
   Office: 2355 Clown St., 543-1234
   On since Fri Aug 31 20:13 (MST) on tty1    1 hour 38 minutes idle
   On since Fri Aug 31 20:13 (MST) on pts/0   12 seconds idle
   On since Fri Aug 31 20:13 (MST) on pts/1
   On since Fri Aug 31 20:31 (MST) on pts/2   1 hour 16 minutes idle
   Mail last read Tue Jul  3 10:08 2007 (MST) 
   No Plan.</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>Out of security considerations, many networks disable
          <b class="COMMAND">finger</b> and its associated daemon.
              <a name="AEN13320" href="#FTN.AEN13320"><span class="footnote">[81]</span></a>
          </p></dd><dt><a name="CHFNREF"></a><b class="COMMAND">chfn</b></dt><dd><p>Change information disclosed by the
          <b class="COMMAND">finger</b> command.</p></dd><dt><a name="VRFYREF"></a><b class="COMMAND">vrfy</b></dt><dd><p>Verify an Internet e-mail address.</p><p>This command seems to be missing from newer Linux
          distros.</p></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="COMMREMOTE1"></a>Remote Host Access</b></p><dl><dt><a name="RXREF"></a><b class="COMMAND">sx</b>, <b class="COMMAND">rx</b></dt><dd><p>The <b class="COMMAND">sx</b> and <b class="COMMAND">rx</b>
          command set serves to transfer files to and from a remote
          host using the <i class="FIRSTTERM">xmodem</i> protocol. These
          are generally part of a communications package, such as
          <b class="COMMAND">minicom</b>.</p></dd><dt><a name="RZREF"></a><b class="COMMAND">sz</b>, <b class="COMMAND">rz</b></dt><dd><p>The <b class="COMMAND">sz</b> and <b class="COMMAND">rz</b>
          command set serves to transfer files to and from a remote
          host using the <i class="FIRSTTERM">zmodem</i> protocol.
          <i class="FIRSTTERM">Zmodem</i> has certain advantages over
          <i class="FIRSTTERM">xmodem</i>, such as faster transmission
          rate and resumption of interrupted file transfers.
          Like <b class="COMMAND">sx</b> and <b class="COMMAND">rx</b>,
          these are generally part of a communications package.</p></dd><dt><a name="FTPREF"></a><b class="COMMAND">ftp</b></dt><dd><p>Utility and protocol for uploading / downloading
          files to or from a remote host. An ftp session can be automated
          in a script (see <a href="#EX72">Example 19-6</a> and <a href="#ENCRYPTEDPW">Example A-4</a>).</p></dd><dt><a name="UUCPREF"></a><b class="COMMAND">uucp</b>, <a name="UUXREF"></a><b class="COMMAND">uux</b>, <a name="CUREF"></a><b class="COMMAND">cu</b></dt><dd><p><b class="COMMAND">uucp</b>: <i class="FIRSTTERM">UNIX to UNIX
          copy</i>. This is a communications package for
          transferring files between UNIX servers. A shell script
          is an effective way to handle a <b class="COMMAND">uucp</b>
          command sequence.</p><p>Since the advent of the Internet and e-mail,
          <b class="COMMAND">uucp</b> seems to have faded into obscurity,
          but it still exists and remains perfectly workable in
          situations where an Internet connection is not available
          or appropriate. The advantage of <b class="COMMAND">uucp</b>
          is that it is fault-tolerant, so even if there is a service
          interruption the copy operation will resume where it left
          off when the connection is restored.</p><p>---</p><p><b class="COMMAND">uux</b>: <i class="FIRSTTERM">UNIX to UNIX
          execute</i>. Execute a command on a remote system.
          This command is part of the <b class="COMMAND">uucp</b>
          package.</p><p>---</p><p><b class="COMMAND">cu</b>: <b class="COMMAND">C</b>all
          <b class="COMMAND">U</b>p a remote system and connect as a
          simple terminal. It is a sort of dumbed-down version of
          <a href="#TELNETREF">telnet</a>. This command is
          part of the <b class="COMMAND">uucp</b> package.</p></dd><dt><a name="TELNETREF"></a><b class="COMMAND">telnet</b></dt><dd><p>Utility and protocol for connecting to a remote host.</p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>The <i class="FIRSTTERM">telnet</i> protocol
        contains security holes and should therefore probably be
        avoided. Its use within a shell script is
        <em>not</em> recommended.</p></td></tr></tbody></table></div></dd><dt><a name="WGETREF"></a><b class="COMMAND">wget</b></dt><dd><p>The <b class="COMMAND">wget</b> utility
          <i class="FIRSTTERM">noninteractively</i> retrieves or
          downloads files from a Web or ftp site. It works well in a
          script.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">wget -p http://www.xyz23.com/file01.html
  #  The -p or --page-requisite option causes wget to fetch all files
  #+ required to display the specified page.
  
  wget -r ftp://ftp.xyz24.net/~bozo/project_files/ -O $SAVEFILE
  #  The -r option recursively follows and retrieves all links
  #+ on the specified site.
  
  wget -c ftp://ftp.xyz25.net/bozofiles/filename.tar.bz2
  #  The -c option lets wget resume an interrupted download.
  #  This works with ftp servers and many HTTP sites.</pre></font></td></tr></tbody></table></p><div class="EXAMPLE"><a name="QUOTEFETCH"></a><p><b>Example 16-42. Getting a stock quote</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # quote-fetch.sh: Download a stock quote.
  
  
  E_NOPARAMS=86
  
  if [ -z "$1" ]  # Must specify a stock (symbol) to fetch.
    then echo "Usage: `basename $0` stock-symbol"
    exit $E_NOPARAMS
  fi
  
  stock_symbol=$1
  
  file_suffix=.html
  # Fetches an HTML file, so name it appropriately.
  URL='http://finance.yahoo.com/q?s='
  # Yahoo finance board, with stock query suffix.
  
  # -----------------------------------------------------------
  wget -O ${stock_symbol}${file_suffix} "${URL}${stock_symbol}"
  # -----------------------------------------------------------
  
  
  # To look up stuff on http://search.yahoo.com:
  # -----------------------------------------------------------
  # URL="http://search.yahoo.com/search?fr=ush-news&amp;p=${query}"
  # wget -O "$savefilename" "${URL}"
  # -----------------------------------------------------------
  # Saves a list of relevant URLs.
  
  exit $?
  
  # Exercises:
  # ---------
  #
  # 1) Add a test to ensure the user running the script is on-line.
  #    (Hint: parse the output of 'ps -ax' for "ppp" or "connect."
  #
  # 2) Modify this script to fetch the local weather report,
  #+   taking the user's zip code as an argument.</pre></font></td></tr></tbody></table></div><p>See also <a href="#WGETTER2">Example A-30</a> and <a href="#BASHPODDER">Example A-31</a>.</p></dd><dt><a name="LYNXREF"></a><b class="COMMAND">lynx</b></dt><dd><p>The <b class="COMMAND">lynx</b> Web and file browser
          can be used inside a script (with the
          <tt class="OPTION">-dump</tt> option) to retrieve a file from a Web or 
          ftp site noninteractively.</p><p>	   <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">lynx -dump http://www.xyz23.com/file01.html &gt;$SAVEFILE</pre></font></td></tr></tbody></table>
              </p><p>With the <tt class="OPTION">-traversal</tt> option,
          <b class="COMMAND">lynx</b> starts at the HTTP URL specified
          as an argument, then <span class="QUOTE">"crawls"</span> through all
          links located on that particular server. Used together
          with the <tt class="OPTION">-crawl</tt> option, outputs page text
          to a log file.</p></dd><dt><a name="RLOGINREF"></a><b class="COMMAND">rlogin</b></dt><dd><p><tt class="REPLACEABLE"><i>Remote login</i></tt>, initates a
          session on a remote host. This command has security issues,
          so use <a href="#SSHREF">ssh</a> instead.</p></dd><dt><a name="RSHREF"></a><b class="COMMAND">rsh</b></dt><dd><p><tt class="REPLACEABLE"><i>Remote shell</i></tt>, executes
          command(s) on a remote host. This has security issues,
          so use <b class="COMMAND">ssh</b> instead.</p></dd><dt><a name="RCPREF"></a><b class="COMMAND">rcp</b></dt><dd><p><tt class="REPLACEABLE"><i>Remote copy</i></tt>, copies files
          between two different networked machines.</p></dd><dt><a name="RSYNCREF"></a><b class="COMMAND">rsync</b></dt><dd><p><tt class="REPLACEABLE"><i>Remote synchronize</i></tt>, updates
        (synchronizes) files
          between two different networked machines.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>rsync -a ~/sourcedir/*txt /node1/subdirectory/</b></tt>
          </pre></font></td></tr></tbody></table>
        </p><div class="EXAMPLE"><a name="FC4UPD"></a><p><b>Example 16-43. Updating FC4</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # fc4upd.sh
  
  # Script author: Frank Wang.
  # Slight stylistic modifications by ABS Guide author.
  # Used in ABS Guide with permission.
  
  
  #  Download Fedora Core 4 update from mirror site using rsync. 
  #  Should also work for newer Fedora Cores -- 5, 6, . . .
  #  Only download latest package if multiple versions exist,
  #+ to save space.
  
  URL=rsync://distro.ibiblio.org/fedora-linux-core/updates/
  # URL=rsync://ftp.kddilabs.jp/fedora/core/updates/
  # URL=rsync://rsync.planetmirror.com/fedora-linux-core/updates/
  
  DEST=${1:-/var/www/html/fedora/updates/}
  LOG=/tmp/repo-update-$(/bin/date +%Y-%m-%d).txt
  PID_FILE=/var/run/${0##*/}.pid
  
  E_RETURN=85        # Something unexpected happened.
  
  
  # General rsync options
  # -r: recursive download
  # -t: reserve time
  # -v: verbose
  
  OPTS="-rtv --delete-excluded --delete-after --partial"
  
  # rsync include pattern
  # Leading slash causes absolute path name match.
  INCLUDE=(
      "/4/i386/kde-i18n-Chinese*" 
  #   ^                         ^
  # Quoting is necessary to prevent globbing.
  ) 
  
  
  # rsync exclude pattern
  # Temporarily comment out unwanted pkgs using "#" . . .
  EXCLUDE=(
      /1
      /2
      /3
      /testing
      /4/SRPMS
      /4/ppc
      /4/x86_64
      /4/i386/debug
     "/4/i386/kde-i18n-*"
     "/4/i386/openoffice.org-langpack-*"
     "/4/i386/*i586.rpm"
     "/4/i386/GFS-*"
     "/4/i386/cman-*"
     "/4/i386/dlm-*"
     "/4/i386/gnbd-*"
     "/4/i386/kernel-smp*"
  #  "/4/i386/kernel-xen*" 
  #  "/4/i386/xen-*" 
  )
  
  
  init () {
      # Let pipe command return possible rsync error, e.g., stalled network.
      set -o pipefail                  # Newly introduced in Bash, version 3.
  
      TMP=${TMPDIR:-/tmp}/${0##*/}.$$  # Store refined download list.
      trap "{
          rm -f $TMP 2&gt;/dev/null
      }" EXIT                          # Clear temporary file on exit.
  }
  
  
  check_pid () {
  # Check if process exists.
      if [ -s "$PID_FILE" ]; then
          echo "PID file exists. Checking ..."
          PID=$(/bin/egrep -o "^[[:digit:]]+" $PID_FILE)
          if /bin/ps --pid $PID &amp;&gt;/dev/null; then
              echo "Process $PID found. ${0##*/} seems to be running!"
             /usr/bin/logger -t ${0##*/} \
                   "Process $PID found. ${0##*/} seems to be running!"
              exit $E_RETURN
          fi
          echo "Process $PID not found. Start new process . . ."
      fi
  }
  
  
  #  Set overall file update range starting from root or $URL,
  #+ according to above patterns.
  set_range () {
      include=
      exclude=
      for p in "${INCLUDE[@]}"; do
          include="$include --include \"$p\""
      done
  
      for p in "${EXCLUDE[@]}"; do
          exclude="$exclude --exclude \"$p\""
      done
  }
  
  
  # Retrieve and refine rsync update list.
  get_list () {
      echo $$ &gt; $PID_FILE || {
          echo "Can't write to pid file $PID_FILE"
          exit $E_RETURN
      }
  
      echo -n "Retrieving and refining update list . . ."
  
      # Retrieve list -- 'eval' is needed to run rsync as a single command.
      # $3 and $4 is the date and time of file creation.
      # $5 is the full package name.
      previous=
      pre_file=
      pre_date=0
      eval /bin/nice /usr/bin/rsync \
          -r $include $exclude $URL | \
          egrep '^dr.x|^-r' | \
          awk '{print $3, $4, $5}' | \
          sort -k3 | \
          { while read line; do
              # Get seconds since epoch, to filter out obsolete pkgs.
              cur_date=$(date -d "$(echo $line | awk '{print $1, $2}')" +%s)
              #  echo $cur_date
  
              # Get file name.
              cur_file=$(echo $line | awk '{print $3}')
              #  echo $cur_file
  
              # Get rpm pkg name from file name, if possible.
              if [[ $cur_file == *rpm ]]; then
                  pkg_name=$(echo $cur_file | sed -r -e \
                      's/(^([^_-]+[_-])+)[[:digit:]]+\..*[_-].*$/\1/')
              else
                  pkg_name=
              fi
              # echo $pkg_name
  
              if [ -z "$pkg_name" ]; then   #  If not a rpm file,
                  echo $cur_file &gt;&gt; $TMP    #+ then append to download list.
              elif [ "$pkg_name" != "$previous" ]; then   # A new pkg found.
                  echo $pre_file &gt;&gt; $TMP                  # Output latest file.
                  previous=$pkg_name                      # Save current.
                  pre_date=$cur_date
                  pre_file=$cur_file
              elif [ "$cur_date" -gt "$pre_date" ]; then
                                                  #  If same pkg, but newer,
                  pre_date=$cur_date              #+ then update latest pointer.
                  pre_file=$cur_file
              fi
              done
              echo $pre_file &gt;&gt; $TMP              #  TMP contains ALL
                                                  #+ of refined list now.
              # echo "subshell=$BASH_SUBSHELL"
  
      }       # Bracket required here to let final "echo $pre_file &gt;&gt; $TMP" 
              # Remained in the same subshell ( 1 ) with the entire loop.
  
      RET=$?  # Get return code of the pipe command.
  
      [ "$RET" -ne 0 ] &amp;&amp; {
          echo "List retrieving failed with code $RET"
          exit $E_RETURN
      }
  
      echo "done"; echo
  }
  
  # Real rsync download part.
  get_file () {
  
      echo "Downloading..."
      /bin/nice /usr/bin/rsync \
          $OPTS \
          --filter "merge,+/ $TMP" \
          --exclude '*'  \
          $URL $DEST     \
          | /usr/bin/tee $LOG
  
      RET=$?
  
     #  --filter merge,+/ is crucial for the intention. 
     #  + modifier means include and / means absolute path.
     #  Then sorted list in $TMP will contain ascending dir name and 
     #+ prevent the following --exclude '*' from "shortcutting the circuit." 
  
      echo "Done"
  
      rm -f $PID_FILE 2&gt;/dev/null
  
      return $RET
  }
  
  # -------
  # Main
  init
  check_pid
  set_range
  get_list
  get_file
  RET=$?
  # -------
  
  if [ "$RET" -eq 0 ]; then
      /usr/bin/logger -t ${0##*/} "Fedora update mirrored successfully."
  else
      /usr/bin/logger -t ${0##*/} \
      "Fedora update mirrored with failure code: $RET"
  fi
  
  exit $RET</pre></font></td></tr></tbody></table></div><p>See also <a href="#NIGHTLYBACKUP">Example A-32</a>.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>Using <a href="#RCPREF">rcp</a>, <a href="#RSYNCREF">rsync</a>, and similar
          utilities with security implications in a shell
          script may not be advisable. Consider, instead, using
          <b class="COMMAND">ssh</b>, <a href="#SCPREF">scp</a>,
          or an <b class="COMMAND">expect</b> script.</p></td></tr></tbody></table></div></dd><dt><a name="SSHREF"></a><b class="COMMAND">ssh</b></dt><dd><p><tt class="REPLACEABLE"><i>Secure shell</i></tt>, logs onto
          a remote host and executes commands there. This
          secure replacement for <b class="COMMAND">telnet</b>,
          <b class="COMMAND">rlogin</b>, <b class="COMMAND">rcp</b>, and
          <b class="COMMAND">rsh</b> uses identity authentication
          and encryption. See its <a href="#MANREF">manpage</a>
          for details.</p><div class="EXAMPLE"><a name="REMOTE"></a><p><b>Example 16-44. Using <i class="FIRSTTERM">ssh</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # remote.bash: Using ssh.
  
  # This example by Michael Zick.
  # Used with permission.
  
  
  #   Presumptions:
  #   ------------
  #   fd-2 isn't being captured ( '2&gt;/dev/null' ).
  #   ssh/sshd presumes stderr ('2') will display to user.
  #
  #   sshd is running on your machine.
  #   For any 'standard' distribution, it probably is,
  #+  and without any funky ssh-keygen having been done.
  
  # Try ssh to your machine from the command-line:
  #
  # $ ssh $HOSTNAME
  # Without extra set-up you'll be asked for your password.
  #   enter password
  #   when done,  $ exit
  #
  # Did that work? If so, you're ready for more fun.
  
  # Try ssh to your machine as 'root':
  #
  #   $  ssh -l root $HOSTNAME
  #   When asked for password, enter root's, not yours.
  #          Last login: Tue Aug 10 20:25:49 2004 from localhost.localdomain
  #   Enter 'exit' when done.
  
  #  The above gives you an interactive shell.
  #  It is possible for sshd to be set up in a 'single command' mode,
  #+ but that is beyond the scope of this example.
  #  The only thing to note is that the following will work in
  #+ 'single command' mode.
  
  
  # A basic, write stdout (local) command.
  
  ls -l
  
  # Now the same basic command on a remote machine.
  # Pass a different 'USERNAME' 'HOSTNAME' if desired:
  USER=${USERNAME:-$(whoami)}
  HOST=${HOSTNAME:-$(hostname)}
  
  #  Now excute the above command-line on the remote host,
  #+ with all transmissions encrypted.
  
  ssh -l ${USER} ${HOST} " ls -l "
  
  #  The expected result is a listing of your username's home
  #+ directory on the remote machine.
  #  To see any difference, run this script from somewhere
  #+ other than your home directory.
  
  #  In other words, the Bash command is passed as a quoted line
  #+ to the remote shell, which executes it on the remote machine.
  #  In this case, sshd does  ' bash -c "ls -l" '   on your behalf.
  
  #  For information on topics such as not having to enter a
  #+ password/passphrase for every command-line, see
  #+    man ssh
  #+    man ssh-keygen
  #+    man sshd_config.
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>Within a loop, <b class="COMMAND">ssh</b> may cause
      unexpected behavior. According to a <a href="http://groups-beta.google.com/group/comp.unix.shell/msg/dcb446b5fff7d230" target="_top">		Usenet post</a> in the comp.unix shell archives,
      <b class="COMMAND">ssh</b> inherits the loop's
      <tt class="FILENAME">stdin</tt>. To remedy this, pass
      <b class="COMMAND">ssh</b> either the <tt class="OPTION">-n</tt>
      or <tt class="OPTION">-f</tt> option.</p><p>Thanks, Jason Bechtel, for pointing this out.</p></td></tr></tbody></table></div></dd><dt><a name="SCPREF"></a><b class="COMMAND">scp</b></dt><dd><p><tt class="REPLACEABLE"><i>Secure copy</i></tt>, similar in
          function to <b class="COMMAND">rcp</b>, copies files between
          two different networked machines, but does so using
          authentication, and with a security level similar to
          <b class="COMMAND">ssh</b>.</p></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="COMMLOCAL1"></a>Local Network</b></p><dl><dt><a name="WRITEREF"></a><b class="COMMAND">write</b></dt><dd><p>This is a utility for terminal-to-terminal communication.
          It allows sending lines from your terminal (console or
          <i class="FIRSTTERM">xterm</i>) to that of another user. The
          <a href="#MESGREF">mesg</a> command may, of course,
          be used to disable write access to a terminal</p><p>Since <b class="COMMAND">write</b> is interactive, it
          would not normally find use in a script.</p></dd><dt><a name="NETCONFIGREF"></a><b class="COMMAND">netconfig</b></dt><dd><p>A command-line utility for configuring a network adapter
          (using <i class="FIRSTTERM">DHCP</i>). This command is native
          to Red Hat centric Linux distros.</p></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="COMMMAIL1"></a>Mail</b></p><dl><dt><b class="COMMAND">mail</b></dt><dd><p>Send or read e-mail messages.</p><p>This stripped-down command-line mail client
          works fine as a command embedded in a script.</p><div class="EXAMPLE"><a name="SELFMAILER"></a><p><b>Example 16-45. A script that mails itself</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/sh
  # self-mailer.sh: Self-mailing script
  
  adr=${1:-`whoami`}     # Default to current user, if not specified.
  #  Typing 'self-mailer.sh wiseguy@superdupergenius.com'
  #+ sends this script to that addressee.
  #  Just 'self-mailer.sh' (no argument) sends the script
  #+ to the person invoking it, for example, bozo@localhost.localdomain.
  #
  #  For more on the ${parameter:-default} construct,
  #+ see the "Parameter Substitution" section
  #+ of the "Variables Revisited" chapter.
  
  # ============================================================================
    cat $0 | mail -s "Script \"`basename $0`\" has mailed itself to you." "$adr"
  # ============================================================================
  
  # --------------------------------------------
  #  Greetings from the self-mailing script.
  #  A mischievous person has run this script,
  #+ which has caused it to mail itself to you.
  #  Apparently, some people have nothing better
  #+ to do with their time.
  # --------------------------------------------
  
  echo "At `date`, script \"`basename $0`\" mailed to "$adr"."
  
  exit 0
  
  #  Note that the "mailx" command (in "send" mode) may be substituted
  #+ for "mail" ... but with somewhat different options.</pre></font></td></tr></tbody></table></div></dd><dt><a name="MAILTOREF"></a><b class="COMMAND">mailto</b></dt><dd><p>Similar to the <b class="COMMAND">mail</b> command,
          <b class="COMMAND">mailto</b> sends e-mail messages
          from the command-line or in a script. However,
          <b class="COMMAND">mailto</b> also permits sending MIME
          (multimedia) messages.</p></dd><dt><a name="MAILSTATSREF"></a><b class="COMMAND">mailstats</b></dt><dd><p>Show <i class="FIRSTTERM">mail statistics</i>. This command
          may be invoked only by <i class="FIRSTTERM">root</i>.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">root# </tt><tt class="USERINPUT"><b>mailstats</b></tt>
  <tt class="COMPUTEROUTPUT">Statistics from Tue Jan  1 20:32:08 2008
    M   msgsfr  bytes_from   msgsto    bytes_to  msgsrej msgsdis msgsqur  Mailer
    4     1682      24118K        0          0K        0       0       0  esmtp
    9      212        640K     1894      25131K        0       0       0  local
   =====================================================================
    T     1894      24758K     1894      25131K        0       0       0
    C      414                    0</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="VACATIONREF"></a><b class="COMMAND">vacation</b></dt><dd><p>This utility automatically replies to e-mails that
          the intended recipient is on vacation and temporarily
          unavailable. It runs on a network, in conjunction with
          <b class="COMMAND">sendmail</b>, and is not applicable to a
          dial-up POPmail account.</p></dd></dl></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="TERMINALCCMDS"></a>16.7. Terminal Control Commands</h1><p></p><div class="VARIABLELIST"><p><b><a name="TERMCOMMANDLISTING1"></a>Command affecting the console
       or terminal</b></p><dl><dt><a name="TPUTREF"></a><b class="COMMAND">tput</b></dt><dd><p>Initialize terminal and/or fetch information about it from
          <span class="DATABASE">terminfo</span> data. Various options permit
          certain terminal operations:  <b class="COMMAND">tput clear</b>
          is the equivalent of <a href="#CLEARREF">clear</a>;
          <b class="COMMAND">tput reset</b> is the equivalent
          of <a href="#RESETREF">reset</a>.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>tput longname</b></tt>
  <tt class="COMPUTEROUTPUT">xterm terminal emulator (X Window System)</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>Issuing a <b class="COMMAND">tput cup X Y</b> moves
          the cursor to the (X,Y) coordinates in the current
          terminal. A <b class="COMMAND">clear</b> to erase the terminal
          screen would normally precede this.</p><p>
          Some interesting options to <i class="FIRSTTERM">tput</i> are:
  
      </p><p></p><ul><li><p><tt class="OPTION">bold</tt>, for high-intensity
          text</p></li><li><p><tt class="OPTION">smul</tt>, to underline text
          in the terminal</p></li><li><p><tt class="OPTION">smso</tt>, to render text in
          reverse</p></li><li><p><tt class="OPTION">sgr0</tt>, to reset the terminal
          parameters (to normal), without clearing the
          screen</p></li></ul>
  
        <p></p><p>Example scripts using <i class="FIRSTTERM">tput</i>:
              </p><p></p><ol type="1"><li><p><a href="#COLORECHO">Example 36-15</a></p></li><li><p><a href="#EX30A">Example 36-13</a></p></li><li><p><a href="#HOMEWORK">Example A-44</a></p></li><li><p><a href="#NIM">Example A-42</a></p></li><li><p><a href="#POEM">Example 27-2</a></p></li></ol>
        <p></p><p>Note that <a href="#STTYREF">stty</a> offers
          a more powerful command set for controlling a terminal.</p></dd><dt><a name="INFOCMPREF"></a><b class="COMMAND">infocmp</b></dt><dd><p>This command prints out extensive information about the
          current terminal. It references the
          <i class="FIRSTTERM">terminfo</i> database.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>infocmp</b></tt>
  <tt class="COMPUTEROUTPUT">#       Reconstructed via infocmp from file:
   /usr/share/terminfo/r/rxvt
   rxvt|rxvt terminal emulator (X Window System), 
           am, bce, eo, km, mir, msgr, xenl, xon, 
           colors#8, cols#80, it#8, lines#24, pairs#64, 
           acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~, 
           bel=^G, blink=\E[5m, bold=\E[1m,
           civis=\E[?25l, 
           clear=\E[H\E[2J, cnorm=\E[?25h, cr=^M, 
           ...</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="RESETREF"></a><b class="COMMAND">reset</b></dt><dd><p>Reset terminal parameters and clear text screen. As with
        <b class="COMMAND">clear</b>, the cursor and prompt reappear in the
        upper lefthand corner of the terminal.</p></dd><dt><a name="CLEARREF"></a><b class="COMMAND">clear</b></dt><dd><p>The <b class="COMMAND">clear</b> command simply clears
          the text screen at the console or in an
          <i class="FIRSTTERM">xterm</i>. The prompt and cursor
          reappear at the upper lefthand corner of the screen or
          xterm window. This command may be used either at the command
          line or in a script. See <a href="#EX30">Example 11-26</a>.</p></dd><dt><a name="RESIZEREF"></a><b class="COMMAND">resize</b></dt><dd><p>Echoes commands necessary to set <tt class="VARNAME">$TERM</tt>
          and <tt class="VARNAME">$TERMCAP</tt> to duplicate the
          <i class="FIRSTTERM">size</i> (dimensions) of the current
          terminal.</p><p>	        <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>resize</b></tt>
  <tt class="COMPUTEROUTPUT">set noglob;
   setenv COLUMNS '80';
   setenv LINES '24';
   unset noglob;</tt>
            </pre></font></td></tr></tbody></table>
          </p></dd><dt><a name="SCRIPTREF"></a><b class="COMMAND">script</b></dt><dd><p>This utility records (saves to a file) all the user keystrokes at
          the command-line in a console or an xterm window. This, in effect,
          creates a record of a session.</p></dd></dl></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="MATHC"></a>16.8. Math Commands</h1><p></p><div class="VARIABLELIST"><p><b><a name="MATHCOMMANDLISTING1"></a><span class="QUOTE">"Doing the
       numbers"</span></b></p><dl><dt><a name="FACTORREF"></a><b class="COMMAND">factor</b></dt><dd><p>Decompose an integer into prime factors.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>factor 27417</b></tt>
  <tt class="COMPUTEROUTPUT">27417: 3 13 19 37</tt>
          </pre></font></td></tr></tbody></table>
        </p><div class="EXAMPLE"><a name="PRIMES2"></a><p><b>Example 16-46. Generating prime numbers</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # primes2.sh
  
  #  Generating prime numbers the quick-and-easy way,
  #+ without resorting to fancy algorithms.
  
  CEILING=10000   # 1 to 10000
  PRIME=0
  E_NOTPRIME=
  
  is_prime ()
  {
    local factors
    factors=( $(factor $1) )  # Load output of `factor` into array.
  
  if [ -z "${factors[2]}" ]
  #  Third element of "factors" array:
  #+ ${factors[2]} is 2nd factor of argument.
  #  If it is blank, then there is no 2nd factor,
  #+ and the argument is therefore prime.
  then
    return $PRIME             # 0
  else
    return $E_NOTPRIME        # null
  fi
  }
  
  echo
  for n in $(seq $CEILING)
  do
    if is_prime $n
    then
      printf %5d $n
    fi   #    ^  Five positions per number suffices.
  done   #       For a higher $CEILING, adjust upward, as necessary.
  
  echo
  
  exit</pre></font></td></tr></tbody></table></div></dd><dt><a name="BCREF"></a><b class="COMMAND">bc</b></dt><dd><p>Bash can't handle floating point calculations, and
          it lacks operators for certain important mathematical
          functions. Fortunately, <b class="COMMAND">bc</b> gallops to
          the rescue.</p><p>Not just a versatile, arbitrary precision calculation
          utility, <b class="COMMAND">bc</b> offers many of the facilities of
          a programming language. It has a syntax vaguely resembling
          <b class="COMMAND">C</b>.</p><p>Since it is a fairly well-behaved UNIX utility, and may
           therefore be used in a <a href="#PIPEREF">pipe</a>,
           <b class="COMMAND">bc</b> comes in handy in scripts.</p><p><a name="BCTEMPLATE"></a></p><p>Here is a simple template for using
          <b class="COMMAND">bc</b> to calculate a script
          variable. This uses <a href="#COMMANDSUBREF">command
          substitution</a>.</p><p>              <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN">	      <tt class="USERINPUT"><b>variable=$(echo "OPTIONS; OPERATIONS" | bc)</b></tt>
          </pre></font></td></tr></tbody></table>
          </p><p><a name="MONTHLYPMT0"></a></p><div class="EXAMPLE"><a name="MONTHLYPMT"></a><p><b>Example 16-47. Monthly Payment on a Mortgage</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # monthlypmt.sh: Calculates monthly payment on a mortgage.
  
  
  #  This is a modification of code in the
  #+ "mcalc" (mortgage calculator) package,
  #+ by Jeff Schmidt
  #+ and
  #+ Mendel Cooper (yours truly, the ABS Guide author).
  #   http://www.ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz
  
  echo
  echo "Given the principal, interest rate, and term of a mortgage,"
  echo "calculate the monthly payment."
  
  bottom=1.0
  
  echo
  echo -n "Enter principal (no commas) "
  read principal
  echo -n "Enter interest rate (percent) "  # If 12%, enter "12", not ".12".
  read interest_r
  echo -n "Enter term (months) "
  read term
  
  
   interest_r=$(echo "scale=9; $interest_r/100.0" | bc) # Convert to decimal.
                   #           ^^^^^^^^^^^^^^^^^  Divide by 100. 
                   # "scale" determines how many decimal places.
  
   interest_rate=$(echo "scale=9; $interest_r/12 + 1.0" | bc)
   
  
   top=$(echo "scale=9; $principal*$interest_rate^$term" | bc)
            #           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            #           Standard formula for figuring interest.
  
   echo; echo "Please be patient. This may take a while."
  
   let "months = $term - 1"
  # ==================================================================== 
   for ((x=$months; x &gt; 0; x--))
   do
     bot=$(echo "scale=9; $interest_rate^$x" | bc)
     bottom=$(echo "scale=9; $bottom+$bot" | bc)
  #  bottom = $(($bottom + $bot"))
   done
  # ==================================================================== 
  
  # -------------------------------------------------------------------- 
  #  Rick Boivie pointed out a more efficient implementation
  #+ of the above loop, which decreases computation time by 2/3.
  
  # for ((x=1; x &lt;= $months; x++))
  # do
  #   bottom=$(echo "scale=9; $bottom * $interest_rate + 1" | bc)
  # done
  
  
  #  And then he came up with an even more efficient alternative,
  #+ one that cuts down the run time by about 95%!
  
  # bottom=`{
  #     echo "scale=9; bottom=$bottom; interest_rate=$interest_rate"
  #     for ((x=1; x &lt;= $months; x++))
  #     do
  #          echo 'bottom = bottom * interest_rate + 1'
  #     done
  #     echo 'bottom'
  #     } | bc`       # Embeds a 'for loop' within command substitution.
  # --------------------------------------------------------------------------
  #  On the other hand, Frank Wang suggests:
  #  bottom=$(echo "scale=9; ($interest_rate^$term-1)/($interest_rate-1)" | bc)
  
  #  Because . . .
  #  The algorithm behind the loop
  #+ is actually a sum of geometric proportion series.
  #  The sum formula is e0(1-q^n)/(1-q),
  #+ where e0 is the first element and q=e(n+1)/e(n)
  #+ and n is the number of elements.
  # --------------------------------------------------------------------------
  
  
   # let "payment = $top/$bottom"
   payment=$(echo "scale=2; $top/$bottom" | bc)
   # Use two decimal places for dollars and cents.
   
   echo
   echo "monthly payment = \$$payment"  # Echo a dollar sign in front of amount.
   echo
  
  
   exit 0
  
  
   # Exercises:
   #   1) Filter input to permit commas in principal amount.
   #   2) Filter input to permit interest to be entered as percent or decimal.
   #   3) If you are really ambitious,
   #+     expand this script to print complete amortization tables.</pre></font></td></tr></tbody></table></div><p><a name="BASE0"></a></p><div class="EXAMPLE"><a name="BASE"></a><p><b>Example 16-48. Base Conversion</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  ###########################################################################
  # Shellscript:	base.sh - print number to different bases (Bourne Shell)
  # Author     :	Heiner Steven (heiner.steven@odn.de)
  # Date       :	07-03-95
  # Category   :	Desktop
  # $Id: base.sh,v 1.2 2000/02/06 19:55:35 heiner Exp $
  # ==&gt; Above line is RCS ID info.
  ###########################################################################
  # Description
  #
  # Changes
  # 21-03-95 stv	fixed error occuring with 0xb as input (0.2)
  ###########################################################################
  
  # ==&gt; Used in ABS Guide with the script author's permission.
  # ==&gt; Comments added by ABS Guide author.
  
  NOARGS=85
  PN=`basename "$0"`			       # Program name
  VER=`echo '$Revision: 1.2 $' | cut -d' ' -f2`  # ==&gt; VER=1.2
  
  Usage () {
      echo "$PN - print number to different bases, $VER (stv '95)
  usage: $PN [number ...]
  
  If no number is given, the numbers are read from standard input.
  A number may be
      binary (base 2)		starting with 0b (i.e. 0b1100)
      octal (base 8)		starting with 0  (i.e. 014)
      hexadecimal (base 16)	starting with 0x (i.e. 0xc)
      decimal			otherwise (i.e. 12)" &gt;&amp;2
      exit $NOARGS 
  }   # ==&gt; Prints usage message.
  
  Msg () {
      for i   # ==&gt; in [list] missing. Why?
      do echo "$PN: $i" &gt;&amp;2
      done
  }
  
  Fatal () { Msg "$@"; exit 66; }
  
  PrintBases () {
      # Determine base of the number
      for i      # ==&gt; in [list] missing...
      do         # ==&gt; so operates on command-line arg(s).
    case "$i" in
        0b*)		ibase=2;;	# binary
        0x*|[a-f]*|[A-F]*)	ibase=16;;	# hexadecimal
        0*)			ibase=8;;	# octal
        [1-9]*)		ibase=10;;	# decimal
        *)
      Msg "illegal number $i - ignored"
      continue;;
    esac
  
    # Remove prefix, convert hex digits to uppercase (bc needs this).
    number=`echo "$i" | sed -e 's:^0[bBxX]::' | tr '[a-f]' '[A-F]'`
    # ==&gt; Uses ":" as sed separator, rather than "/".
  
    # Convert number to decimal
    dec=`echo "ibase=$ibase; $number" | bc`  # ==&gt; 'bc' is calculator utility.
    case "$dec" in
        [0-9]*)	;;			 # number ok
        *)		continue;;		 # error: ignore
    esac
  
    # Print all conversions in one line.
    # ==&gt; 'here document' feeds command list to 'bc'.
    echo `bc &lt;&lt;!
        obase=16; "hex="; $dec
        obase=10; "dec="; $dec
        obase=8;  "oct="; $dec
        obase=2;  "bin="; $dec
  !
      ` | sed -e 's: :	:g'
  
      done
  }
  
  while [ $# -gt 0 ]
  # ==&gt;  Is a "while loop" really necessary here,
  # ==&gt;+ since all the cases either break out of the loop
  # ==&gt;+ or terminate the script.
  # ==&gt; (Above comment by Paulo Marcel Coelho Aragao.)
  do
      case "$1" in
    --)     shift; break;;
    -h)     Usage;;                 # ==&gt; Help message.
    -*)     Usage;;
           *)     break;;                 # First number
      esac   # ==&gt; Error checking for illegal input might be appropriate.
      shift
  done
  
  if [ $# -gt 0 ]
  then
      PrintBases "$@"
  else					# Read from stdin.
      while read line
      do
    PrintBases $line
      done
  fi
  
  
  exit</pre></font></td></tr></tbody></table></div><p><a name="BCHEREDOC"></a></p><p>An alternate method of invoking <b class="COMMAND">bc</b>
      involves using a <a href="#HEREDOCREF">here
      document</a> embedded within a <a href="#COMMANDSUBREF">command substitution</a>
      block. This is especially appropriate when a script
      needs to pass a list of options and commands to
      <b class="COMMAND">bc</b>.</p><p>	      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">variable=`bc &lt;&lt; LIMIT_STRING
  options
  statements
  operations
  LIMIT_STRING
  `
  
  ...or...
  
  
  variable=$(bc &lt;&lt; LIMIT_STRING
  options
  statements
  operations
  LIMIT_STRING
  )</pre></font></td></tr></tbody></table>
                </p><div class="EXAMPLE"><a name="ALTBC"></a><p><b>Example 16-49. Invoking <i class="FIRSTTERM">bc</i> using a <i class="FIRSTTERM">here
            document</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Invoking 'bc' using command substitution
  # in combination with a 'here document'.
  
  
  var1=`bc &lt;&lt; EOF
  18.33 * 19.78
  EOF
  `
  echo $var1       # 362.56
  
  
  #  $( ... ) notation also works.
  v1=23.53
  v2=17.881
  v3=83.501
  v4=171.63
  
  var2=$(bc &lt;&lt; EOF
  scale = 4
  a = ( $v1 + $v2 )
  b = ( $v3 * $v4 )
  a * b + 15.35
  EOF
  )
  echo $var2       # 593487.8452
  
  
  var3=$(bc -l &lt;&lt; EOF
  scale = 9
  s ( 1.7 )
  EOF
  )
  # Returns the sine of 1.7 radians.
  # The "-l" option calls the 'bc' math library.
  echo $var3       # .991664810
  
  
  # Now, try it in a function...
  hypotenuse ()    # Calculate hypotenuse of a right triangle.
  {                # c = sqrt( a^2 + b^2 )
  hyp=$(bc -l &lt;&lt; EOF
  scale = 9
  sqrt ( $1 * $1 + $2 * $2 )
  EOF
  )
  # Can't directly return floating point values from a Bash function.
  # But, can echo-and-capture:
  echo "$hyp"
  }
  
  hyp=$(hypotenuse 3.68 7.31)
  echo "hypotenuse = $hyp"    # 8.184039344
  
  
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="CANNONREF"></a></p><div class="EXAMPLE"><a name="CANNON"></a><p><b>Example 16-50. Calculating PI</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # cannon.sh: Approximating PI by firing cannonballs.
  
  # Author: Mendel Cooper
  # License: Public Domain
  # Version 2.2, reldate 13oct08.
  
  # This is a very simple instance of a "Monte Carlo" simulation:
  #+ a mathematical model of a real-life event,
  #+ using pseudorandom numbers to emulate random chance.
  
  #  Consider a perfectly square plot of land, 10000 units on a side.
  #  This land has a perfectly circular lake in its center,
  #+ with a diameter of 10000 units.
  #  The plot is actually mostly water, except for land in the four corners.
  #  (Think of it as a square with an inscribed circle.)
  #
  #  We will fire iron cannonballs from an old-style cannon
  #+ at the square.
  #  All the shots impact somewhere on the square,
  #+ either in the lake or on the dry corners.
  #  Since the lake takes up most of the area,
  #+ most of the shots will SPLASH! into the water.
  #  Just a few shots will THUD! into solid ground
  #+ in the four corners of the square.
  #
  #  If we take enough random, unaimed shots at the square,
  #+ Then the ratio of SPLASHES to total shots will approximate
  #+ the value of PI/4.
  #
  #  The simplified explanation is that the cannon is actually
  #+ shooting only at the upper right-hand quadrant of the square,
  #+ i.e., Quadrant I of the Cartesian coordinate plane.
  #
  #
  #  Theoretically, the more shots taken, the better the fit.
  #  However, a shell script, as opposed to a compiled language
  #+ with floating-point math built in, requires some compromises.
  #  This decreases the accuracy of the simulation.
  
  
  DIMENSION=10000  # Length of each side of the plot.
                   # Also sets ceiling for random integers generated.
  
  MAXSHOTS=1000    # Fire this many shots.
                   # 10000 or more would be better, but would take too long.
  PMULTIPLIER=4.0  # Scaling factor.
  
  declare -r M_PI=3.141592654
                   # Actual 9-place value of PI, for comparison purposes.
  
  get_random ()
  {
  SEED=$(head -n 1 /dev/urandom | od -N 1 | awk '{ print $2 }')
  RANDOM=$SEED                                  #  From "seeding-random.sh"
                                                #+ example script.
  let "rnum = $RANDOM % $DIMENSION"             #  Range less than 10000.
  echo $rnum
  }
  
  distance=        # Declare global variable.
  hypotenuse ()    # Calculate hypotenuse of a right triangle.
  {                # From "alt-bc.sh" example.
  distance=$(bc -l &lt;&lt; EOF
  scale = 0
  sqrt ( $1 * $1 + $2 * $2 )
  EOF
  )
  #  Setting "scale" to zero rounds down result to integer value,
  #+ a necessary compromise in this script.
  #  It decreases the accuracy of this simulation.
  }
  
  
  # ==========================================================
  # main() {
  # "Main" code block, mimicking a C-language main() function.
  
  # Initialize variables.
  shots=0
  splashes=0
  thuds=0
  Pi=0
  error=0
  
  while [ "$shots" -lt  "$MAXSHOTS" ]           # Main loop.
  do
  
    xCoord=$(get_random)                        # Get random X and Y coords.
    yCoord=$(get_random)
    hypotenuse $xCoord $yCoord                  #  Hypotenuse of
                                                #+ right-triangle = distance.
    ((shots++))
  
    printf "#%4d   " $shots
    printf "Xc = %4d  " $xCoord
    printf "Yc = %4d  " $yCoord
    printf "Distance = %5d  " $distance         #   Distance from
                                                #+  center of lake
                                                #+  -- the "origin" --
                                                #+  coordinate (0,0).
  
    if [ "$distance" -le "$DIMENSION" ]
    then
      echo -n "SPLASH!  "
      ((splashes++))
    else
      echo -n "THUD!    "
      ((thuds++))
    fi
  
    Pi=$(echo "scale=9; $PMULTIPLIER*$splashes/$shots" | bc)
    # Multiply ratio by 4.0.
    echo -n "PI ~ $Pi"
    echo
  
  done
  
  echo
  echo "After $shots shots, PI looks like approximately   $Pi"
  #  Tends to run a bit high,
  #+ possibly due to round-off error and imperfect randomness of $RANDOM.
  #  But still usually within plus-or-minus 5% . . .
  #+ a pretty fair rough approximation.
  error=$(echo "scale=9; $Pi - $M_PI" | bc)
  pct_error=$(echo "scale=2; 100.0 * $error / $M_PI" | bc)
  echo -n "Deviation from mathematical value of PI =        $error"
  echo " ($pct_error% error)"
  echo
  
  # End of "main" code block.
  # }
  # ==========================================================
  
  exit 0
  
  #  One might well wonder whether a shell script is appropriate for
  #+ an application as complex and computation-intensive as a simulation.
  #
  #  There are at least two justifications.
  #  1) As a proof of concept: to show it can be done.
  #  2) To prototype and test the algorithms before rewriting
  #+    it in a compiled high-level language.</pre></font></td></tr></tbody></table></div><p>See also <a href="#STDDEV">Example A-37</a>.</p></dd><dt><a name="DCREF"></a><b class="COMMAND">dc</b></dt><dd><p>The <b class="COMMAND">dc</b> (<b class="COMMAND">d</b>esk
                <b class="COMMAND">c</b>alculator) utility is <a href="#STACKDEFREF">stack-oriented</a>
                and uses RPN (<i class="FIRSTTERM">Reverse Polish Notation</i>).
                Like <b class="COMMAND">bc</b>, it has much of the power of
                a programming language.</p><p>Similar to the procedure with <b class="COMMAND">bc</b>,
          <a href="#ECHOREF">echo</a> a command-string
          to <b class="COMMAND">dc</b>.</p><p>		     <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo "[Printing a string ... ]P" | dc
  # The P command prints the string between the preceding brackets.
  
  # And now for some simple arithmetic.
  echo "7 8 * p" | dc     # 56
  #  Pushes 7, then 8 onto the stack,
  #+ multiplies ("*" operator), then prints the result ("p" operator).</pre></font></td></tr></tbody></table>
               </p><p>Most persons avoid <b class="COMMAND">dc</b>, because
                  of its non-intuitive input and rather cryptic
      operators. Yet, it has its uses.</p><div class="EXAMPLE"><a name="HEXCONVERT"></a><p><b>Example 16-51. Converting a decimal number to hexadecimal</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # hexconvert.sh: Convert a decimal number to hexadecimal.
  
  E_NOARGS=85 # Command-line arg missing.
  BASE=16     # Hexadecimal.
  
  if [ -z "$1" ]
  then        # Need a command-line argument.
    echo "Usage: $0 number"
    exit $E_NOARGS
  fi          # Exercise: add argument validity checking.
  
  
  hexcvt ()
  {
  if [ -z "$1" ]
  then
    echo 0
    return    # "Return" 0 if no arg passed to function.
  fi
  
  echo ""$1" "$BASE" o p" | dc
  #                  o    sets radix (numerical base) of output.
  #                    p  prints the top of stack.
  # For other options: 'man dc' ...
  return
  }
  
  hexcvt "$1"
  
  exit</pre></font></td></tr></tbody></table></div><p>Studying the <a href="#INFOREF">info</a> page for
      <b class="COMMAND">dc</b> is a painful path to understanding its
      intricacies. There seems to be a small, select group of
      <em>dc wizards</em> who delight in showing off
      their mastery of this powerful, but arcane utility.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo "16i[q]sa[ln0=aln100%Pln100/snlbx]sbA0D68736142snlbxq" | dc</b></tt>
  <tt class="COMPUTEROUTPUT">Bash</tt>
          </pre></font></td></tr></tbody></table>
      </p><p><a name="GOLDENRATIO"></a>
            <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">dc &lt;&lt;&lt; 10k5v1+2/p # 1.6180339887
  #  ^^^            Feed operations to dc using a Here String.
  #      ^^^        Pushes 10 and sets that as the precision (10k).
  #         ^^      Pushes 5 and takes its square root
  #                 (5v, v = square root).
  #           ^^    Pushes 1 and adds it to the running total (1+).
  #             ^^  Pushes 2 and divides the running total by that (2/).
  #               ^ Pops and prints the result (p)
  #  The result is  1.6180339887 ...
  #  ... which happens to be the Pythagorean Golden Ratio, to 10 places.</pre></font></td></tr></tbody></table>
      </p><div class="EXAMPLE"><a name="FACTR"></a><p><b>Example 16-52. Factoring</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # factr.sh: Factor a number
  
  MIN=2       # Will not work for number smaller than this.
  E_NOARGS=85
  E_TOOSMALL=86
  
  if [ -z $1 ]
  then
    echo "Usage: $0 number"
    exit $E_NOARGS
  fi
  
  if [ "$1" -lt "$MIN" ]
  then
    echo "Number to factor must be $MIN or greater."
    exit $E_TOOSMALL
  fi  
  
  # Exercise: Add type checking (to reject non-integer arg).
  
  echo "Factors of $1:"
  # -------------------------------------------------------
  echo  "$1[p]s2[lip/dli%0=1dvsr]s12sid2%0=13sidvsr[dli%0=\
  1lrli2+dsi!&gt;.]ds.xd1&lt;2" | dc
  # -------------------------------------------------------
  #  Above code written by Michel Charpentier &lt;charpov@cs.unh.edu&gt;
  #  (as a one-liner, here broken into two lines for display purposes).
  #  Used in ABS Guide with permission (thanks!).
  
   exit
  
   # $ sh factr.sh 270138
   # 2
   # 3
   # 11
   # 4093</pre></font></td></tr></tbody></table></div></dd><dt><a name="AWKMATH"></a><b class="COMMAND">awk</b></dt><dd><p>Yet another way of doing floating point math in
          a script is using <a href="#AWKREF">awk's</a>
          built-in math functions in a <a href="#SHWRAPPER">shell
          wrapper</a>.</p><div class="EXAMPLE"><a name="HYPOT"></a><p><b>Example 16-53. Calculating the hypotenuse of a triangle</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # hypotenuse.sh: Returns the "hypotenuse" of a right triangle.
  #                (square root of sum of squares of the "legs")
  
  ARGS=2                # Script needs sides of triangle passed.
  E_BADARGS=85          # Wrong number of arguments.
  
  if [ $# -ne "$ARGS" ] # Test number of arguments to script.
  then
    echo "Usage: `basename $0` side_1 side_2"
    exit $E_BADARGS
  fi
  
  
  AWKSCRIPT=' { printf( "%3.7f\n", sqrt($1*$1 + $2*$2) ) } '
  #             command(s) / parameters passed to awk
  
  
  # Now, pipe the parameters to awk.
      echo -n "Hypotenuse of $1 and $2 = "
      echo $1 $2 | awk "$AWKSCRIPT"
  #   ^^^^^^^^^^^^
  # An echo-and-pipe is an easy way of passing shell parameters to awk.
  
  exit
  
  # Exercise: Rewrite this script using 'bc' rather than awk.
  #           Which method is more intuitive?</pre></font></td></tr></tbody></table></div></dd></dl></div></div><div class="SECT1"><hr><h1 class="SECT1"><a name="EXTMISC"></a>16.9. Miscellaneous Commands</h1><p></p><div class="VARIABLELIST"><p><b><a name="MISCCOMMANDLISTING1"></a>Command that fit in no
       special category</b></p><dl><dt><a name="JOTREF"></a><b class="COMMAND">jot</b>, <a name="SEQREF"></a><b class="COMMAND">seq</b></dt><dd><p>These utilities emit a sequence of integers, with a
          user-selectable increment.</p><p>The default separator character between each integer is a
          newline, but this can be changed with the <tt class="OPTION">-s</tt>
          option.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>seq 5</b></tt>
  <tt class="COMPUTEROUTPUT">1
   2
   3
   4
   5</tt>
  
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>seq -s : 5</b></tt>
  <tt class="COMPUTEROUTPUT">1:2:3:4:5</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>Both <b class="COMMAND">jot</b> and <b class="COMMAND">seq</b>
          come in handy in a <a href="#FORLOOPREF1">for
          loop</a>.</p><div class="EXAMPLE"><a name="EX53"></a><p><b>Example 16-54. Using <i class="FIRSTTERM">seq</i> to generate loop
          arguments</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Using "seq"
  
  echo
  
  for a in `seq 80`  # or   for a in $( seq 80 )
  # Same as   for a in 1 2 3 4 5 ... 80   (saves much typing!).
  # May also use 'jot' (if present on system).
  do
    echo -n "$a "
  done      # 1 2 3 4 5 ... 80
  # Example of using the output of a command to generate 
  # the [list] in a "for" loop.
  
  echo; echo
  
  
  COUNT=80  # Yes, 'seq' also accepts a replaceable parameter.
  
  for a in `seq $COUNT`  # or   for a in $( seq $COUNT )
  do
    echo -n "$a "
  done      # 1 2 3 4 5 ... 80
  
  echo; echo
  
  BEGIN=75
  END=80
  
  for a in `seq $BEGIN $END`
  #  Giving "seq" two arguments starts the count at the first one,
  #+ and continues until it reaches the second.
  do
    echo -n "$a "
  done      # 75 76 77 78 79 80
  
  echo; echo
  
  BEGIN=45
  INTERVAL=5
  END=80
  
  for a in `seq $BEGIN $INTERVAL $END`
  #  Giving "seq" three arguments starts the count at the first one,
  #+ uses the second for a step interval,
  #+ and continues until it reaches the third.
  do
    echo -n "$a "
  done      # 45 50 55 60 65 70 75 80
  
  echo; echo
  
  exit 0</pre></font></td></tr></tbody></table></div><p>A simpler example:</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#  Create a set of 10 files,
  #+ named file.1, file.2 . . . file.10.
  COUNT=10
  PREFIX=file
  
  for filename in `seq $COUNT`
  do
    touch $PREFIX.$filename
    #  Or, can do other operations,
    #+ such as rm, grep, etc.
  done</pre></font></td></tr></tbody></table></p><div class="EXAMPLE"><a name="LETTERCOUNT"></a><p><b>Example 16-55. Letter Count"</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # letter-count.sh: Counting letter occurrences in a text file.
  # Written by Stefano Palmeri.
  # Used in ABS Guide with permission.
  # Slightly modified by document author.
  
  MINARGS=2          # Script requires at least two arguments.
  E_BADARGS=65
  FILE=$1
  
  let LETTERS=$#-1   # How many letters specified (as command-line args).
                     # (Subtract 1 from number of command-line args.)
  
  
  show_help(){
       echo
             echo Usage: `basename $0` file letters  
             echo Note: `basename $0` arguments are case sensitive.
             echo Example: `basename $0` foobar.txt G n U L i N U x.
       echo
  }
  
  # Checks number of arguments.
  if [ $# -lt $MINARGS ]; then
     echo
     echo "Not enough arguments."
     echo
     show_help
     exit $E_BADARGS
  fi  
  
  
  # Checks if file exists.
  if [ ! -f $FILE ]; then
      echo "File \"$FILE\" does not exist."
      exit $E_BADARGS
  fi
  
  
  
  # Counts letter occurrences .
  for n in `seq $LETTERS`; do
        shift
        if [[ `echo -n "$1" | wc -c` -eq 1 ]]; then             #  Checks arg.
               echo "$1" -\&gt; `cat $FILE | tr -cd  "$1" | wc -c` #  Counting.
        else
               echo "$1 is not a  single char."
        fi  
  done
  
  exit $?
  
  #  This script has exactly the same functionality as letter-count2.sh,
  #+ but executes faster.
  #  Why?</pre></font></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>Somewhat more capable than <i class="FIRSTTERM">seq</i>,
    <b class="COMMAND">jot</b> is a classic UNIX
    utility that is not normally included in a standard Linux
    distro. However, the source <i class="FIRSTTERM">rpm</i>
    is available for download from the <a href="http://www.mit.edu/afs/athena/system/rhlinux/athena-9.0/free/SRPMS/athena-jot-9.0-3.src.rpm" target="_top">	MIT repository</a>.</p><p><a name="JOTRANDOM"></a></p><p>Unlike <i class="FIRSTTERM">seq</i>, <b class="COMMAND">jot</b> can
          generate a sequence of random numbers, using the <tt class="OPTION">-r</tt>
    option.</p><p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>jot -r 3 999</b></tt>
  <tt class="COMPUTEROUTPUT">1069
   1272
   1428</tt></pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div></dd><dt><a name="GETOPTY"></a><b class="COMMAND">getopt</b></dt><dd><p>The <b class="COMMAND">getopt</b> command
          parses command-line options preceded by a <a href="#DASHREF">dash</a>. This external command
          corresponds to the <a href="#GETOPTSX">getopts</a>
          Bash builtin. Using <b class="COMMAND">getopt</b> permits
          handling long options by means of the <tt class="OPTION">-l</tt>
          flag, and this also allows parameter reshuffling.</p><div class="EXAMPLE"><a name="EX33A"></a><p><b>Example 16-56. Using <i class="FIRSTTERM">getopt</i> to parse command-line
            options</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # Using getopt
  
  # Try the following when invoking this script:
  #   sh ex33a.sh -a
  #   sh ex33a.sh -abc
  #   sh ex33a.sh -a -b -c
  #   sh ex33a.sh -d
  #   sh ex33a.sh -dXYZ
  #   sh ex33a.sh -d XYZ
  #   sh ex33a.sh -abcd
  #   sh ex33a.sh -abcdZ
  #   sh ex33a.sh -z
  #   sh ex33a.sh a
  # Explain the results of each of the above.
  
  E_OPTERR=65
  
  if [ "$#" -eq 0 ]
  then   # Script needs at least one command-line argument.
    echo "Usage $0 -[options a,b,c]"
    exit $E_OPTERR
  fi  
  
  set -- `getopt "abcd:" "$@"`
  # Sets positional parameters to command-line arguments.
  # What happens if you use "$*" instead of "$@"?
  
  while [ ! -z "$1" ]
  do
    case "$1" in
      -a) echo "Option \"a\"";;
      -b) echo "Option \"b\"";;
      -c) echo "Option \"c\"";;
      -d) echo "Option \"d\" $2";;
       *) break;;
    esac
  
    shift
  done
  
  #  It is usually better to use the 'getopts' builtin in a script.
  #  See "ex33.sh."
  
  exit 0</pre></font></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>As <em>Peggy Russell</em> points out:</p><p>It is often necessary to include an <a href="#EVALREF">eval</a> to correctly process
                <a href="#WHITESPACEREF">whitespace</a> and
          <i class="FIRSTTERM">quotes</i>.
            <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">args=$(getopt -o a:bc:d -- "$@")
  eval set -- "$args"</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div><p>See <a href="#GETOPTSIMPLE">Example 10-5</a> for a simplified emulation
          of <b class="COMMAND">getopt</b>.</p></dd><dt><a name="RUNPARTSREF"></a><b class="COMMAND">run-parts</b></dt><dd><p>The <b class="COMMAND">run-parts</b> command
  
      <a name="AEN14105" href="#FTN.AEN14105"><span class="footnote">[82]</span></a>
          
          executes all the scripts in a target directory, sequentially
          in ASCII-sorted filename order. Of course, the scripts
          need to have execute permission.</p><p>The <a href="#CRONREF">cron</a> <a href="#DAEMONREF">daemon</a> invokes
          <b class="COMMAND">run-parts</b> to run the scripts in
          the <tt class="FILENAME">/etc/cron.*</tt>
          directories.</p></dd><dt><a name="YESREF"></a><b class="COMMAND">yes</b></dt><dd><p>In its default behavior the <b class="COMMAND">yes</b>
          command feeds a continuous string of the character
          <tt class="COMPUTEROUTPUT">y</tt> followed
          by a line feed to <tt class="FILENAME">stdout</tt>. A
          <b class="KEYCAP">control</b>-<b class="KEYCAP">C</b>
          terminates the run. A different output string
          may be specified, as in <tt class="USERINPUT"><b>yes different
          string</b></tt>, which would continually output
          <tt class="COMPUTEROUTPUT">different string</tt> to
          <tt class="FILENAME">stdout</tt>.</p><p>One might well ask the purpose of this. From the
          command-line or in a script, the output of
          <b class="COMMAND">yes</b> can be redirected or piped into a
          program expecting user input. In effect, this becomes a sort
          of poor man's version of <i class="FIRSTTERM">expect</i>.</p><p><tt class="USERINPUT"><b>yes | fsck /dev/hda1</b></tt> runs
          <b class="COMMAND">fsck</b> non-interactively (careful!).</p><p><tt class="USERINPUT"><b>yes | rm -r dirname</b></tt> has same effect as
         <tt class="USERINPUT"><b>rm -rf dirname</b></tt> (careful!).</p><div class="WARNING"><p></p><table class="WARNING" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/warning.gif" hspace="5" alt="Warning"></td><td align="LEFT" valign="TOP"><p>Caution advised when piping
         <i class="FIRSTTERM">yes</i> to a potentially dangerous
         system command, such as <a href="#FSCKREF">fsck</a>
         or <a href="#FDISKREF">fdisk</a>. It might have
         unintended consequences.</p></td></tr></tbody></table></div><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <i class="FIRSTTERM">yes</i> command parses variables,
           or more accurately, it echoes parsed variables.
           For example:</p><p>	        <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>yes $BASH_VERSION</b></tt>
  <tt class="COMPUTEROUTPUT">3.1.17(1)-release
   3.1.17(1)-release
   3.1.17(1)-release
   3.1.17(1)-release
   3.1.17(1)-release
   . . .</tt>
          </pre></font></td></tr></tbody></table>
            </p><p>	       This particular <span class="QUOTE">"feature"</span> may be used
           to create a <em>very large</em> ASCII file on the fly:
          <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>yes $PATH &gt; huge_file.txt</b></tt>
  <tt class="USERINPUT"><b>Ctl-C</b></tt>	      
          </pre></font></td></tr></tbody></table>
          Hit <tt class="USERINPUT"><b>Ctl-C</b></tt> <em>very
          quickly</em>, or you just might get more than you
          bargained for. . . .
          </p></td></tr></tbody></table></div><p><a name="YESEMU"></a>The <i class="FIRSTTERM">yes</i>
         command may be emulated in a very simple script <a href="#FUNCTIONREF">function</a>.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">yes ()
  { # Trivial emulation of "yes" ...
    local DEFAULT_TEXT="y"
    while [ true ]   # Endless loop.
    do
      if [ -z "$1" ]
      then
        echo "$DEFAULT_TEXT"
      else           # If argument ...
        echo "$1"    # ... expand and echo it.
      fi
    done             #  The only things missing are the
  }                  #+ --help and --version options.</pre></font></td></tr></tbody></table></p></dd><dt><a name="BANNERREF"></a><b class="COMMAND">banner</b></dt><dd><p>Prints arguments as a large vertical banner to
          <tt class="FILENAME">stdout</tt>, using an <a href="#ASCIIDEF">ASCII</a> character (default
          '#'). This may be redirected to a printer for
          hardcopy.</p><p>Note that <i class="FIRSTTERM">banner</i> has been
                 dropped from many Linux distros, presumably because it
                 is no longer considered useful.</p></dd><dt><a name="PRINTENVREF"></a><b class="COMMAND">printenv</b></dt><dd><p>Show all the <a href="#ENVREF">environmental
          variables</a> set for a particular user.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>printenv | grep HOME</b></tt>
  <tt class="COMPUTEROUTPUT">HOME=/home/bozo</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="LPREF"></a><b class="COMMAND">lp</b></dt><dd><p>The <b class="COMMAND">lp</b> and <b class="COMMAND">lpr</b>
          commands send file(s) to the print queue, to be printed as
          hard copy.
  
          <a name="AEN14214" href="#FTN.AEN14214"><span class="footnote">[83]</span></a>
  
          These commands trace the origin of their names to the
          line printers of another era.
      <a name="AEN14218" href="#FTN.AEN14218"><span class="footnote">[84]</span></a>
        
        </p><p><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>lp file1.txt</b></tt>
            or <tt class="PROMPT">bash </tt><tt class="USERINPUT"><b>lp
      &lt;file1.txt</b></tt></p><p>It is often useful to pipe the formatted output from
            <b class="COMMAND">pr</b> to <b class="COMMAND">lp</b>.</p><p><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>pr -options file1.txt | lp</b></tt>
            </p><p>Formatting packages, such as <a href="#GROFFREF">groff</a> and
      <i class="FIRSTTERM">Ghostscript</i> may send their output
      directly to <b class="COMMAND">lp</b>.</p><p><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>groff -Tascii file.tr | lp</b></tt>
            </p><p><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>gs -options | lp file.ps</b></tt>
            </p><p>Related commands are <b class="COMMAND">lpq</b>, for viewing
            the print queue, and <b class="COMMAND">lprm</b>, for removing
      jobs from the print queue.</p></dd><dt><a name="TEEREF"></a><b class="COMMAND">tee</b></dt><dd><p>[UNIX borrows an idea from the plumbing trade.]</p><p>This is a redirection operator, but with a difference. Like the
          plumber's <i class="FIRSTTERM">tee,</i> it permits <span class="QUOTE">"siphoning
                off"</span> <em>to a file </em>the output of a command 
          or commands within a pipe, but without affecting the result. This is
          useful for printing an ongoing process to a file or paper, perhaps to
          keep track of it for debugging purposes.</p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN">                             (redirection)
                              |----&gt; to file
                              |
    ==========================|====================
    command ---&gt; command ---&gt; |tee ---&gt; command ---&gt; ---&gt; output of pipe
    ===============================================
          </pre></font></td></tr></tbody></table><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">cat listfile* | sort | tee check.file | uniq &gt; result.file
  #                      ^^^^^^^^^^^^^^   ^^^^    
  
  #  The file "check.file" contains the concatenated sorted "listfiles,"
  #+ before the duplicate lines are removed by 'uniq.'</pre></font></td></tr></tbody></table></p></dd><dt><a name="MKFIFOREF"></a><b class="COMMAND">mkfifo</b></dt><dd><p><a name="NAMEDPIPEREF"></a>This obscure command
          creates a <i class="FIRSTTERM">named pipe</i>, a temporary
          <i class="FIRSTTERM">first-in-first-out buffer</i> for
          transferring data between processes.
  
      <a name="AEN14280" href="#FTN.AEN14280"><span class="footnote">[85]</span></a>
  
          Typically, one process writes to the FIFO, and the other
          reads from it. See <a href="#FIFO">Example A-14</a>.</p><p>	      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # This short script by Omair Eshkenazi.
  # Used in ABS Guide with permission (thanks!).
  
  mkfifo pipe1   # Yes, pipes can be given names.
  mkfifo pipe2   # Hence the designation "named pipe."
  
  (cut -d' ' -f1 | tr "a-z" "A-Z") &gt;pipe2 &lt;pipe1 &amp;
  ls -l | tr -s ' ' | cut -d' ' -f3,9- | tee pipe1 |
  cut -d' ' -f2 | paste - pipe2
  
  rm -f pipe1
  rm -f pipe2
  
  # No need to kill background processes when script terminates (why not?).
  
  exit $?
  
  Now, invoke the script and explain the output:
  sh mkfifo-example.sh
  
  4830.tar.gz          BOZO
  pipe1   BOZO
  pipe2   BOZO
  mkfifo-example.sh    BOZO
  Mixed.msg BOZO</pre></font></td></tr></tbody></table>
              </p></dd><dt><a name="PATHCHKREF"></a><b class="COMMAND">pathchk</b></dt><dd><p>This command checks the validity of a filename. If the
          filename exceeds the maximum allowable length (255
          characters) or one or more of the directories in
          its path is not searchable, then an error message
          results.</p><p>Unfortunately, <b class="COMMAND">pathchk</b> does
          not return a recognizable error code, and it is therefore
          pretty much useless in a script. Consider instead the
          <a href="#RTIF">file test operators</a>.</p></dd><dt><a name="DDREF"></a><b class="COMMAND">dd</b></dt><dd><p>Though this somewhat obscure and much feared
                <b class="COMMAND">d</b>ata <b class="COMMAND">d</b>uplicator
                command originated as a utility for exchanging
                data on magnetic tapes between UNIX minicomputers
                and IBM mainframes, it still has its uses.
                The <b class="COMMAND">dd</b> command simply copies a
                file (or <tt class="FILENAME">stdin/stdout</tt>), but with
                conversions. <a name="DDCONVERSIONS"></a>Possible conversions
                include ASCII/EBCDIC,
            
      <a name="AEN14318" href="#FTN.AEN14318"><span class="footnote">[86]</span></a>
  
          upper/lower case, swapping of byte pairs between input
          and output, and skipping and/or truncating the head or
          tail of the input file.</p><p>	      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Converting a file to all uppercase:
  
  dd if=$filename conv=ucase &gt; $filename.uppercase
  #                    lcase   # For lower case conversion</pre></font></td></tr></tbody></table>
              </p><p><a name="DDOPTIONS"></a></p><p>Some basic options to <b class="COMMAND">dd</b> are:
                  </p><p></p><ul><li><p>if=INFILE</p><p>INFILE is the <i class="FIRSTTERM">source</i>
              file.</p></li><li><p>of=OUTFILE</p><p>OUTFILE is the <i class="FIRSTTERM">target</i>
              file, the file that will have the data written to it.</p></li><li><p>bs=BLOCKSIZE</p><p>This is the size of each block of data being read
              and written, usually a power of 2.</p></li><li><p>skip=BLOCKS</p><p>How many blocks of data to skip in INFILE before
              starting to copy. This is useful when the INFILE has
        <span class="QUOTE">"garbage"</span> or garbled data in its
        header or when it is desirable to copy only a portion
        of the INFILE.</p></li><li><p>seek=BLOCKS</p><p>How many blocks of data to skip in OUTFILE before
              starting to copy, leaving blank data at beginning
        of OUTFILE.</p></li><li><p>count=BLOCKS</p><p>Copy only this many blocks of data, rather than the
              entire INFILE.</p></li><li><p>conv=CONVERSION</p><p>Type of conversion to be applied to INFILE data
                          before copying operation.</p></li></ul>
              <p></p><p>A <tt class="USERINPUT"><b>dd --help</b></tt> lists all the
          options this powerful utility takes.</p><div class="EXAMPLE"><a name="SELFCOPY"></a><p><b>Example 16-57. A script that copies itself</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # self-copy.sh
  
  # This script copies itself.
  
  file_subscript=copy
  
  dd if=$0 of=$0.$file_subscript 2&gt;/dev/null
  # Suppress messages from dd:   ^^^^^^^^^^^
  
  exit $?
  
  #  A program whose only output is its own source code
  #+ is called a "quine" per Willard Quine.
  #  Does this script qualify as a quine?</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="EXERCISINGDD"></a><p><b>Example 16-58. Exercising <i class="FIRSTTERM">dd</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # exercising-dd.sh
  
  # Script by Stephane Chazelas.
  # Somewhat modified by ABS Guide author.
  
  infile=$0           # This script.
  outfile=log.txt     # Output file left behind.
  n=8
  p=11
  
  dd if=$infile of=$outfile bs=1 skip=$((n-1)) count=$((p-n+1)) 2&gt; /dev/null
  # Extracts characters n to p (8 to 11) from this script ("bash").
  
  # ----------------------------------------------------------------
  
  echo -n "hello vertical world" | dd cbs=1 conv=unblock 2&gt; /dev/null
  # Echoes "hello vertical world" vertically downward.
  # Why? A newline follows each character dd emits.
  
  exit $?</pre></font></td></tr></tbody></table></div><p><a name="DDKEYSTROKES"></a></p><p>To demonstrate just how versatile <b class="COMMAND">dd</b> is,
         let's use it to capture keystrokes.</p><div class="EXAMPLE"><a name="DDKEYPRESS"></a><p><b>Example 16-59. Capturing Keystrokes</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # dd-keypress.sh: Capture keystrokes without needing to press ENTER.
  
  
  keypresses=4                      # Number of keypresses to capture.
  
  
  old_tty_setting=$(stty -g)        # Save old terminal settings.
  
  echo "Press $keypresses keys."
  stty -icanon -echo                # Disable canonical mode.
                                    # Disable local echo.
  keys=$(dd bs=1 count=$keypresses 2&gt; /dev/null)
  # 'dd' uses stdin, if "if" (input file) not specified.
  
  stty "$old_tty_setting"           # Restore old terminal settings.
  
  echo "You pressed the \"$keys\" keys."
  
  # Thanks, Stephane Chazelas, for showing the way.
  exit 0</pre></font></td></tr></tbody></table></div><p><a name="DDRANDOM"></a></p><p>The <b class="COMMAND">dd</b> command can do random access on a
          data stream.
  
            <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">echo -n . | dd bs=1 seek=4 of=file conv=notrunc
  #  The "conv=notrunc" option means that the output file
  #+ will not be truncated.
  
  # Thanks, S.C.</pre></font></td></tr></tbody></table>
              </p><p><a name="DDCOPY"></a></p><p>The <b class="COMMAND">dd</b> command can copy raw data
          and disk images to and from devices, such as floppies and
          tape drives (<a href="#COPYCD">Example A-5</a>). A common use is
          creating boot floppies.</p><p>		<tt class="USERINPUT"><b>dd if=kernel-image of=/dev/fd0H1440</b></tt>
               </p><p>Similarly, <b class="COMMAND">dd</b> can copy the entire
           contents of a floppy, even one formatted with a
           <span class="QUOTE">"foreign"</span> OS, to the hard drive as an
           image file.</p><p>		<tt class="USERINPUT"><b>dd if=/dev/fd0 of=/home/bozo/projects/floppy.img</b></tt>
               </p><p><a name="BFS"></a>Likewise, <b class="COMMAND">dd</b>
               can create bootable flash drives and SD cards.</p><p><tt class="USERINPUT"><b>dd if=image.iso of=/dev/sdb</b></tt></p><p><a name="RPSDCARD01"></a></p><div class="EXAMPLE"><a name="RPSDCARD"></a><p><b>Example 16-60. Preparing a bootable SD card for the
          <em>Raspberry Pi</em></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # rp.sdcard.sh
  # Preparing an SD card with a bootable image for the Raspberry Pi.
  
  # $1 = imagefile name
  # $2 = sdcard (device file)
  # Otherwise defaults to the defaults, see below.
  
  DEFAULTbs=4M                                 # Block size, 4 mb default.
  DEFAULTif="2013-07-26-wheezy-raspbian.img"   # Commonly used distro.
  DEFAULTsdcard="/dev/mmcblk0"                 # May be different. Check!
  ROOTUSER_NAME=root                           # Must run as root!
  E_NOTROOT=81
  E_NOIMAGE=82
  
  username=$(id -nu)                           # Who is running this script?
  if [ "$username" != "$ROOTUSER_NAME" ]
  then
    echo "This script must run as root or with root privileges."
    exit $E_NOTROOT
  fi
  
  if [ -n "$1" ]
  then
    imagefile="$1"
  else
    imagefile="$DEFAULTif"
  fi
  
  if [ -n "$2" ]
  then
    sdcard="$2"
  else
    sdcard="$DEFAULTsdcard"
  fi
  
  if [ ! -e $imagefile ]
  then
    echo "Image file \"$imagefile\" not found!"
    exit $E_NOIMAGE
  fi
  
  echo "Last chance to change your mind!"; echo
  read -s -n1 -p "Hit a key to write $imagefile to $sdcard [Ctl-c to exit]."
  echo; echo
  
  echo "Writing $imagefile to $sdcard ..."
  dd bs=$DEFAULTbs if=$imagefile of=$sdcard
  
  exit $?
  
  # Exercises:
  # ---------
  # 1) Provide additional error checking.
  # 2) Have script autodetect device file for SD card (difficult!).
  # 3) Have script sutodetect image file (*img) in $PWD.</pre></font></td></tr></tbody></table></div><p><a name="DDSWAP"></a></p><p>	      Other applications of <b class="COMMAND">dd</b> include
          initializing temporary swap files (<a href="#EX73">Example 31-2</a>)
          and ramdisks (<a href="#RAMDISK">Example 31-3</a>). It can even do a
          low-level copy of an entire hard drive partition, although
          this is not necessarily recommended.</p><p>People (with presumably nothing better to do with
          their time) are constantly thinking of interesting
          applications of <b class="COMMAND">dd</b>.</p><p><a name="DDFDEL"></a></p><div class="EXAMPLE"><a name="BLOTOUT"></a><p><b>Example 16-61. Securely deleting a file</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # blot-out.sh: Erase "all" traces of a file.
  
  #  This script overwrites a target file alternately
  #+ with random bytes, then zeros before finally deleting it.
  #  After that, even examining the raw disk sectors by conventional methods
  #+ will not reveal the original file data.
  
  PASSES=7         #  Number of file-shredding passes.
                   #  Increasing this slows script execution,
                   #+ especially on large target files.
  BLOCKSIZE=1      #  I/O with /dev/urandom requires unit block size,
                   #+ otherwise you get weird results.
  E_BADARGS=70     #  Various error exit codes.
  E_NOT_FOUND=71
  E_CHANGED_MIND=72
  
  if [ -z "$1" ]   # No filename specified.
  then
    echo "Usage: `basename $0` filename"
    exit $E_BADARGS
  fi
  
  file=$1
  
  if [ ! -e "$file" ]
  then
    echo "File \"$file\" not found."
    exit $E_NOT_FOUND
  fi  
  
  echo; echo -n "Are you absolutely sure you want to blot out \"$file\" (y/n)? "
  read answer
  case "$answer" in
  [nN]) echo "Changed your mind, huh?"
        exit $E_CHANGED_MIND
        ;;
  *)    echo "Blotting out file \"$file\".";;
  esac
  
  
  flength=$(ls -l "$file" | awk '{print $5}')  # Field 5 is file length.
  pass_count=1
  
  chmod u+w "$file"   # Allow overwriting/deleting the file.
  
  echo
  
  while [ "$pass_count" -le "$PASSES" ]
  do
    echo "Pass #$pass_count"
    sync         # Flush buffers.
    dd if=/dev/urandom of=$file bs=$BLOCKSIZE count=$flength
                 # Fill with random bytes.
    sync         # Flush buffers again.
    dd if=/dev/zero of=$file bs=$BLOCKSIZE count=$flength
                 # Fill with zeros.
    sync         # Flush buffers yet again.
    let "pass_count += 1"
    echo
  done  
  
  
  rm -f $file    # Finally, delete scrambled and shredded file.
  sync           # Flush buffers a final time.
  
  echo "File \"$file\" blotted out and deleted."; echo
  
  
  exit 0
  
  #  This is a fairly secure, if inefficient and slow method
  #+ of thoroughly "shredding" a file.
  #  The "shred" command, part of the GNU "fileutils" package,
  #+ does the same thing, although more efficiently.
  
  #  The file cannot not be "undeleted" or retrieved by normal methods.
  #  However . . .
  #+ this simple method would *not* likely withstand
  #+ sophisticated forensic analysis.
  
  #  This script may not play well with a journaled file system.
  #  Exercise (difficult): Fix it so it does.
  
  
  
  #  Tom Vier's "wipe" file-deletion package does a much more thorough job
  #+ of file shredding than this simple script.
  #     http://www.ibiblio.org/pub/Linux/utils/file/wipe-2.0.0.tar.bz2
  
  #  For an in-depth analysis on the topic of file deletion and security,
  #+ see Peter Gutmann's paper,
  #+     "Secure Deletion of Data From Magnetic and Solid-State Memory".
  #       http://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html</pre></font></td></tr></tbody></table></div><p>See also the <a href="#DDLINK">dd
          thread</a> entry in the <a href="#BIBLIOREF">bibliography</a>.</p></dd><dt><a name="ODREF"></a><b class="COMMAND">od</b></dt><dd><p>The <b class="COMMAND">od</b>, or <i class="FIRSTTERM">octal
          dump</i> filter converts input (or files) to octal
          (base-8) or other bases. This is useful for viewing or
          processing binary data files or otherwise unreadable system
          <a href="#DEVFILEREF">device files</a>, such as
          <tt class="FILENAME">/dev/urandom</tt>, and as a filter for
          binary data.</p><p>	      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
  # Sample output: 1324725719, 3918166450, 2989231420, etc.
  
  # From rnd.sh example script, by StÃ©phane Chazelas</pre></font></td></tr></tbody></table>
      </p><p>See also <a href="#SEEDINGRANDOM">Example 9-16</a> and <a href="#INSERTIONSORT">Example A-36</a>.</p></dd><dt><a name="HEXDUMPREF"></a><b class="COMMAND">hexdump</b></dt><dd><p>Performs a hexadecimal, octal, decimal, or ASCII
          dump of a binary file. This command is the rough equivalent
          of <b class="COMMAND">od</b>, above, but not nearly as
          useful. May be used to view the contents of a binary file,
          in combination with <a href="#DDREF">dd</a> and <a href="#LESSREF">less</a>.</p><p>	  <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">dd if=/bin/ls | hexdump -C | less
  # The -C option nicely formats the output in tabular form.</pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="OBJDUMPREF"></a><b class="COMMAND">objdump</b></dt><dd><p>Displays information about an object file or binary
          executable in either hexadecimal form or as a disassembled
          listing (with the <tt class="OPTION">-d</tt> option).</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>objdump -d /bin/ls</b></tt>
  <tt class="COMPUTEROUTPUT">/bin/ls:     file format elf32-i386
  
   Disassembly of section .init:
  
   080490bc &lt;.init&gt;:
    80490bc:       55                      push   %ebp
    80490bd:       89 e5                   mov    %esp,%ebp
    . . .</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="MCOOKIEREF"></a><b class="COMMAND">mcookie</b></dt><dd><p>This command generates a <span class="QUOTE">"magic cookie,"</span> a
          128-bit (32-character) pseudorandom hexadecimal number,
          normally used as an authorization <span class="QUOTE">"signature"</span>
          by the X server. This also available for use in a script
          as a <span class="QUOTE">"quick 'n dirty"</span> random number.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">random000=$(mcookie)</pre></font></td></tr></tbody></table></p><p>Of course, a script could use <a href="#MD5SUMREF">md5sum</a> for the same purpose.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># Generate md5 checksum on the script itself.
  random001=`md5sum $0 | awk '{print $1}'`
  # Uses 'awk' to strip off the filename.</pre></font></td></tr></tbody></table></p><p>The <b class="COMMAND">mcookie</b> command gives yet another way
          to generate a <span class="QUOTE">"unique"</span> filename.</p><div class="EXAMPLE"><a name="TEMPFILENAME"></a><p><b>Example 16-62. Filename generator</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # tempfile-name.sh:  temp filename generator
  
  BASE_STR=`mcookie`   # 32-character magic cookie.
  POS=11               # Arbitrary position in magic cookie string.
  LEN=5                # Get $LEN consecutive characters.
  
  prefix=temp          #  This is, after all, a "temp" file.
                       #  For more "uniqueness," generate the
                       #+ filename prefix using the same method
                       #+ as the suffix, below.
  
  suffix=${BASE_STR:POS:LEN}
                       #  Extract a 5-character string,
                       #+ starting at position 11.
  
  temp_filename=$prefix.$suffix
                       # Construct the filename.
  
  echo "Temp filename = "$temp_filename""
  
  # sh tempfile-name.sh
  # Temp filename = temp.e19ea
  
  #  Compare this method of generating "unique" filenames
  #+ with the 'date' method in ex51.sh.
  
  exit 0</pre></font></td></tr></tbody></table></div></dd><dt><a name="UNITSREF"></a><b class="COMMAND">units</b></dt><dd><p>This utility converts between different <i class="FIRSTTERM">units
          of measure</i>. While normally invoked in interactive
          mode, <b class="COMMAND">units</b> may find use in a
          script.</p><div class="EXAMPLE"><a name="UNITCONVERSION"></a><p><b>Example 16-63. Converting meters to miles</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # unit-conversion.sh
  # Must have 'units' utility installed.
  
  
  convert_units ()  # Takes as arguments the units to convert.
  {
    cf=$(units "$1" "$2" | sed --silent -e '1p' | awk '{print $2}')
    # Strip off everything except the actual conversion factor.
    echo "$cf"
  }  
  
  Unit1=miles
  Unit2=meters
  cfactor=`convert_units $Unit1 $Unit2`
  quantity=3.73
  
  result=$(echo $quantity*$cfactor | bc)
  
  echo "There are $result $Unit2 in $quantity $Unit1."
  
  #  What happens if you pass incompatible units,
  #+ such as "acres" and "miles" to the function?
  
  exit 0
  
  # Exercise: Edit this script to accept command-line parameters,
  #           with appropriate error checking, of course.</pre></font></td></tr></tbody></table></div></dd><dt><a name="M4REF"></a><b class="COMMAND">m4</b></dt><dd><p>A hidden treasure, <b class="COMMAND">m4</b> is a
          powerful macro
       <a name="AEN14523" href="#FTN.AEN14523"><span class="footnote">[87]</span></a>
          processing filter, virtually a complete language.
          Although originally written as a pre-processor
          for <i class="FIRSTTERM">RatFor</i>, <b class="COMMAND">m4</b>
          turned out to be useful as a stand-alone utility. In
          fact, <b class="COMMAND">m4</b> combines some of the
          functionality of <a href="#EVALREF">eval</a>,
          <a href="#TRREF">tr</a>, and <a href="#AWKREF">awk</a>, in addition to its extensive
          macro expansion facilities.</p><p>The April, 2002 issue of <a href="http://www.linuxjournal.com" target="_top"><i class="CITETITLE">Linux Journal</i></a>
          has a very nice article on <b class="COMMAND">m4</b> and
          its uses.</p><div class="EXAMPLE"><a name="M4"></a><p><b>Example 16-64. Using <i class="FIRSTTERM">m4</i></b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # m4.sh: Using the m4 macro processor
  
  # Strings
  string=abcdA01
  echo "len($string)" | m4                            #   7
  echo "substr($string,4)" | m4                       # A01
  echo "regexp($string,[0-1][0-1],\&amp;Z)" | m4      # 01Z
  
  # Arithmetic
  var=99
  echo "incr($var)" | m4                              #  100
  echo "eval($var / 3)" | m4                          #   33
  
  exit</pre></font></td></tr></tbody></table></div></dd><dt><a name="XMESSAGEREF"></a><b class="COMMAND">xmessage</b></dt><dd><p>This X-based variant of
                <a href="#ECHOREF">echo</a> pops up a message/query
          window on the desktop.</p><p>	      <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">xmessage Left click to continue -button okay</pre></font></td></tr></tbody></table>
          </p></dd><dt><a name="ZENITYREF"></a><b class="COMMAND">zenity</b></dt><dd><p>The
          <a href="http://freshmeat.net/projects/zenity" target="_top">zenity</a>
          utility is adept at displaying
          <i class="FIRSTTERM">GTK+</i> dialog <a href="#WIDGETREF">widgets</a> and <a href="#ZENITYREF2">very suitable for scripting
          purposes</a>.</p></dd><dt><a name="DOEXECREF"></a><b class="COMMAND">doexec</b></dt><dd><p>The <b class="COMMAND">doexec</b> command enables passing
          an arbitrary list of arguments to a <i class="FIRSTTERM">binary
          executable</i>. In particular, passing
          <tt class="PARAMETER"><i>argv[0]</i></tt> (which corresponds to <a href="#POSPARAMREF1">$0</a> in a script) lets the
          executable be invoked by various names, and it can then
          carry out different sets of actions, according to the name
          by which it was called. What this amounts to is roundabout
          way of passing options to an executable.</p><p>For example, the <tt class="FILENAME">/usr/local/bin</tt> directory might
          contain a binary called <span class="QUOTE">"aaa"</span>.  Invoking
          <b class="COMMAND">doexec /usr/local/bin/aaa list</b>
          would <em>list</em> all those files
          in the current working directory beginning with an
          <span class="QUOTE">"a"</span>, while invoking (the same executable
          with) <b class="COMMAND">doexec /usr/local/bin/aaa delete </b>
          would <em>delete</em> those files.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The various behaviors of the executable
                must be defined within the code of the executable itself,
                analogous to something like the following in a shell script:
                  <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">case `basename $0` in
  "name1" ) do_something;;
  "name2" ) do_something_else;;
  "name3" ) do_yet_another_thing;;
  *       ) bail_out;;
  esac</pre></font></td></tr></tbody></table></p></td></tr></tbody></table></div></dd><dt><b class="COMMAND">dialog</b></dt><dd><p>The <a href="#DIALOGREF">dialog</a> family of tools
          provide a method of calling interactive
          <span class="QUOTE">"dialog"</span> boxes from a script. The more
          elaborate variations of <b class="COMMAND">dialog</b> --
          <b class="COMMAND">gdialog</b>, <b class="COMMAND">Xdialog</b>,
          and <b class="COMMAND">kdialog</b> -- actually invoke X-Windows
          <a href="#WIDGETREF">widgets</a>.</p></dd><dt><a name="SOXREF"></a><b class="COMMAND">sox</b></dt><dd><p>The <b class="COMMAND">sox</b>, or
          <span class="QUOTE">"<b class="COMMAND">so</b>und
          e<b class="COMMAND">x</b>change"</span> command plays and
          performs transformations on sound files. In fact,
          the <tt class="FILENAME">/usr/bin/play</tt> executable
          (now deprecated) is nothing but a shell wrapper for
          <i class="FIRSTTERM">sox</i>.</p><p>For example, <b class="COMMAND">sox soundfile.wav
          soundfile.au</b> changes a WAV sound file into a
          (Sun audio format) AU sound file.</p><p>Shell scripts are ideally suited for batch-processing
          <b class="COMMAND">sox</b> operations on
          sound files. For examples, see the <a href="http://osl.iu.edu/~tveldhui/radio/" target="_top"> Linux Radio
          Timeshift HOWTO</a> and the <a href="http://savannah.nongnu.org/projects/audiodo" target="_top">MP3do
          Project</a>.</p></dd></dl></div></div></div><div class="CHAPTER"><hr><h1><a name="SYSTEM"></a>Chapter 17. System and Administrative Commands</h1><p>The startup and shutdown scripts in 
    <tt class="FILENAME">/etc/rc.d</tt> illustrate the uses
    (and usefulness) of many of these comands. These are usually
    invoked by <i class="FIRSTTERM">root</i> and used for system
    maintenance or emergency filesystem repairs. Use with caution, as
    some of these commands may damage your system if misused.</p><p></p><div class="VARIABLELIST"><p><b><a name="USERSGROUPS1"></a>Users and Groups</b></p><dl><dt><a name="USERSREF"></a><b class="COMMAND">users</b></dt><dd><p>Show all logged on users. This is the approximate
          equivalent of <b class="COMMAND">who -q</b>.</p></dd><dt><a name="GROUPSCMDREF"></a><b class="COMMAND">groups</b></dt><dd><p>Lists the current user and the groups she belongs to.
           This corresponds to the <a href="#GROUPSREF">$GROUPS</a> internal variable,
           but gives the group names, rather than the numbers.</p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>groups</b></tt>
  <tt class="COMPUTEROUTPUT">bozita cdrom cdwriter audio xgrp</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $GROUPS</b></tt>
  <tt class="COMPUTEROUTPUT">501</tt></pre></font></td></tr></tbody></table></dd><dt><a name="CHOWNREF"></a><b class="COMMAND">chown</b>, <a name="CHGRPREF"></a><b class="COMMAND">chgrp</b></dt><dd><p>The <b class="COMMAND">chown</b> command changes the
          ownership of a file or files. This command is a useful
          method that <i class="FIRSTTERM">root</i> can use to
          shift file ownership from one user to another. An ordinary
          user may not change the ownership of files, not even her
          own files.
             <a name="AEN14695" href="#FTN.AEN14695"><span class="footnote">[88]</span></a>
          </p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">root# </tt><tt class="USERINPUT"><b>chown bozo *.txt</b></tt>
  <tt class="COMPUTEROUTPUT"></tt>
          </pre></font></td></tr></tbody></table>
        </p><p>The <b class="COMMAND">chgrp</b> command changes the
          <tt class="REPLACEABLE"><i>group</i></tt> ownership of a file or
          files. You must be owner of the file(s) as well as a member
          of the destination group (or <i class="FIRSTTERM">root</i>)
          to use this operation.
          <table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">chgrp --recursive dunderheads *.data
  #  The "dunderheads" group will now own all the "*.data" files
  #+ all the way down the $PWD directory tree (that's what "recursive" means).</pre></font></td></tr></tbody></table></p></dd><dt><a name="USERADDREF"></a><b class="COMMAND">useradd</b>, <b class="COMMAND">userdel</b></dt><dd><p>The <b class="COMMAND">useradd</b> administrative command
          adds a user account to the system and creates a home
          directory for that particular user, if so specified. The
          corresponding <b class="COMMAND">userdel</b> command removes
          a user account from the system
       <a name="AEN14727" href="#FTN.AEN14727"><span class="footnote">[89]</span></a>
          and deletes associated files.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">adduser</b> command is a synonym
          for <b class="COMMAND">useradd</b> and is usually a symbolic link to
          it.</p></td></tr></tbody></table></div></dd><dt><a name="USERMODREF"></a><b class="COMMAND">usermod</b></dt><dd><p>Modify a user account. Changes may be made to the password,
          group membership, expiration date, and other attributes of
          a given user's account. With this command, a user's password
          may be locked, which has the effect of disabling the
          account.</p></dd><dt><a name="GROUPMODREF"></a><b class="COMMAND">groupmod</b></dt><dd><p>Modify a given group. The group name and/or ID number may be
          changed using this command.</p></dd><dt><a name="IDREF"></a><b class="COMMAND">id</b></dt><dd><p>The <b class="COMMAND">id</b> command lists the real and
          effective user IDs and the group IDs of the user
          associated with the current process. This is the
          counterpart to the <a href="#UIDREF">$UID</a>,
          <a href="#EUIDREF">$EUID</a>, and <a href="#GROUPSREF">$GROUPS</a> internal Bash
          variables.</p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>id</b></tt>
  <tt class="COMPUTEROUTPUT">uid=501(bozo) gid=501(bozo) groups=501(bozo),22(cdrom),80(cdwriter),81(audio)</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>echo $UID</b></tt>
  <tt class="COMPUTEROUTPUT">501</tt></pre></font></td></tr></tbody></table><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>The <b class="COMMAND">id</b> command shows the
          <em>effective</em> IDs only when they differ
          from the <em>real</em> ones.</p></td></tr></tbody></table></div><p>Also see <a href="#AMIROOT">Example 9-5</a>.</p></dd><dt><a name="LIDREF"></a><b class="COMMAND">lid</b></dt><dd><p>The <i class="FIRSTTERM">lid</i> (list ID) command
          shows the group(s) that a given user belongs to, or alternately,
          the users belonging to a given group. May be invoked only by
          root.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">root# </tt><tt class="USERINPUT"><b>lid bozo</b></tt>
  <tt class="COMPUTEROUTPUT"> bozo(gid=500)</tt>
  
  
  <tt class="PROMPT">root# </tt><tt class="USERINPUT"><b>lid daemon</b></tt>
  <tt class="COMPUTEROUTPUT"> bin(gid=1)
    daemon(gid=2)
    adm(gid=4)
    lp(gid=7)</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="WHOREF"></a><b class="COMMAND">who</b></dt><dd><p>Show all users logged on to the system.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>who</b></tt>
  <tt class="COMPUTEROUTPUT">bozo  tty1     Apr 27 17:45
   bozo  pts/0    Apr 27 17:46
   bozo  pts/1    Apr 27 17:47
   bozo  pts/2    Apr 27 17:49</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>The <tt class="OPTION">-m</tt> gives detailed information about
          only the current user. Passing any two arguments to
          <b class="COMMAND">who</b> is the equivalent of <b class="COMMAND">who
          -m</b>, as in <b class="COMMAND">who am i</b> or <b class="COMMAND">who
          The Man</b>.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>who -m</b></tt>
  <tt class="COMPUTEROUTPUT">localhost.localdomain!bozo  pts/2    Apr 27 17:49</tt>
          </pre></font></td></tr></tbody></table>
        </p><p><a name="WHOAMIREF"></a><b class="COMMAND">whoami</b> is similar to <b class="COMMAND">who
          -m</b>, but only lists the user name.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>whoami</b></tt>
  <tt class="COMPUTEROUTPUT">bozo</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="WREF"></a><b class="COMMAND">w</b></dt><dd><p>Show all logged on users and the processes belonging to them. This is
          an extended version of <b class="COMMAND">who</b>. The output of <b class="COMMAND">w</b>
          may be piped to <a href="#GREPREF">grep</a> to find
          a specific user and/or process.</p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>w | grep startx</b></tt>
  <tt class="COMPUTEROUTPUT">bozo  tty1     -                 4:22pm  6:41   4.47s  0.45s  startx</tt></pre></font></td></tr></tbody></table></dd><dt><a name="LOGNAMEREF"></a><b class="COMMAND">logname</b></dt><dd><p>Show current user's login name (as found in
          <tt class="FILENAME">/var/run/utmp</tt>). This is a
          near-equivalent to <a href="#WHOAMIREF">whoami</a>,
          above.</p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>logname</b></tt>
  <tt class="COMPUTEROUTPUT">bozo</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>whoami</b></tt>
  <tt class="COMPUTEROUTPUT">bozo</tt></pre></font></td></tr></tbody></table><p>However . . .</p><p>	    <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>su</b></tt>
  <tt class="COMPUTEROUTPUT">Password: ......</tt>
  
  <tt class="PROMPT">bash# </tt><tt class="USERINPUT"><b>whoami</b></tt>
  <tt class="COMPUTEROUTPUT">root</tt>
  <tt class="PROMPT">bash# </tt><tt class="USERINPUT"><b>logname</b></tt>
  <tt class="COMPUTEROUTPUT">bozo</tt></pre></font></td></tr></tbody></table>	    
        </p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>While <b class="COMMAND">logname</b> prints the name
          of the logged in user, <b class="COMMAND">whoami</b> gives the
          name of the user attached to the current process. As we have
          just seen, sometimes these are not the same.</p></td></tr></tbody></table></div></dd><dt><a name="SUREF"></a><b class="COMMAND">su</b></dt><dd><p>Runs a program or script as a
          <b class="COMMAND">s</b>ubstitute <b class="COMMAND">u</b>ser.
          <b class="COMMAND">su rjones</b> starts a shell as user
          <em>rjones</em>. A naked <b class="COMMAND">su</b>
          defaults to <i class="FIRSTTERM">root</i>.  See <a href="#FIFO">Example A-14</a>.</p></dd><dt><a name="SUDOREF"></a><b class="COMMAND">sudo</b></dt><dd><p>Runs a command as <i class="FIRSTTERM">root</i> (or
          another user). This may be used in a script, thus permitting
          a <i class="FIRSTTERM">regular user</i> to run the script.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  
  # Some commands.
  sudo cp /root/secretfile /home/bozo/secret
  # Some more commands.</pre></font></td></tr></tbody></table></p><p>The file <tt class="FILENAME">/etc/sudoers</tt> holds
          the names of users permitted to invoke
          <b class="COMMAND">sudo</b>.</p></dd><dt><a name="PASSWDREF"></a><b class="COMMAND">passwd</b></dt><dd><p>Sets, changes, or manages a user's password.</p><p>The <b class="COMMAND">passwd</b> command can be used in
          a script, but probably <em>should not</em> be.</p><div class="EXAMPLE"><a name="SETNEWPW"></a><p><b>Example 17-1. Setting a new password</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  #  setnew-password.sh: For demonstration purposes only.
  #                      Not a good idea to actually run this script.
  #  This script must be run as root.
  
  ROOT_UID=0         # Root has $UID 0.
  E_WRONG_USER=65    # Not root?
  
  E_NOSUCHUSER=70
  SUCCESS=0
  
  
  if [ "$UID" -ne "$ROOT_UID" ]
  then
    echo; echo "Only root can run this script."; echo
    exit $E_WRONG_USER
  else
    echo
    echo "You should know better than to run this script, root."
    echo "Even root users get the blues... "
    echo
  fi  
  
  
  username=bozo
  NEWPASSWORD=security_violation
  
  # Check if bozo lives here.
  grep -q "$username" /etc/passwd
  if [ $? -ne $SUCCESS ]
  then
    echo "User $username does not exist."
    echo "No password changed."
    exit $E_NOSUCHUSER
  fi  
  
  echo "$NEWPASSWORD" | passwd --stdin "$username"
  #  The '--stdin' option to 'passwd' permits
  #+ getting a new password from stdin (or a pipe).
  
  echo; echo "User $username's password changed!"
  
  # Using the 'passwd' command in a script is dangerous.
  
  exit 0</pre></font></td></tr></tbody></table></div><p>The <b class="COMMAND">passwd</b> command's <tt class="OPTION">-l</tt>,
          <tt class="OPTION">-u</tt>, and <tt class="OPTION">-d</tt> options permit
          locking, unlocking, and deleting a user's password. Only
          <i class="FIRSTTERM">root</i> may use these options.</p></dd><dt><a name="ACREF"></a><b class="COMMAND">ac</b></dt><dd><p>Show users' logged in time, as read from
          <tt class="FILENAME">/var/log/wtmp</tt>. This is one of the GNU
          accounting utilities.</p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>ac</b></tt>
  <tt class="COMPUTEROUTPUT">        total       68.08</tt></pre></font></td></tr></tbody></table></dd><dt><a name="LASTREF"></a><b class="COMMAND">last</b></dt><dd><p>List <em>last</em> logged in users, as read from
          <tt class="FILENAME">/var/log/wtmp</tt>. This command can also
          show remote logins.</p><p>For example, to show the last few times the system
          rebooted:</p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>last reboot</b></tt>
  <tt class="COMPUTEROUTPUT">reboot   system boot  2.6.9-1.667      Fri Feb  4 18:18          (00:02)    
   reboot   system boot  2.6.9-1.667      Fri Feb  4 15:20          (01:27)    
   reboot   system boot  2.6.9-1.667      Fri Feb  4 12:56          (00:49)    
   reboot   system boot  2.6.9-1.667      Thu Feb  3 21:08          (02:17)    
   . . .
  
   wtmp begins Tue Feb  1 12:50:09 2005</tt></pre></font></td></tr></tbody></table></dd><dt><a name="NEWGRPREF"></a><b class="COMMAND">newgrp</b></dt><dd><p>Change user's <i class="FIRSTTERM">group ID</i> without
          logging out. This permits access to the new group's
          files. Since users may be members of multiple groups
          simultaneously, this command finds only limited use.</p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>Kurt Glaesemann points out that the
          <i class="FIRSTTERM">newgrp</i> command could prove helpful
          in setting the default group permissions for files a user
          writes. However, the <a href="#CHGRPREF">chgrp</a>
          command might be more convenient for this purpose.</p></td></tr></tbody></table></div></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="TERMINALSSYS1"></a>Terminals</b></p><dl><dt><a name="TTYREF"></a><b class="COMMAND">tty</b></dt><dd><p>Echoes the name (filename) of the current user's terminal.
          Note that each separate <i class="FIRSTTERM">xterm</i>
          window counts as a different terminal.</p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>tty</b></tt>
  <tt class="COMPUTEROUTPUT">/dev/pts/1</tt></pre></font></td></tr></tbody></table></dd><dt><a name="STTYREF"></a><b class="COMMAND">stty</b></dt><dd><p>Shows and/or changes terminal settings. This complex
          command, used in a script, can control terminal behavior
          and the way output displays. See the info page, and study
          it carefully.</p><div class="EXAMPLE"><a name="ERASE"></a><p><b>Example 17-2. Setting an <i class="FIRSTTERM">erase</i> character</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # erase.sh: Using "stty" to set an erase character when reading input.
  
  echo -n "What is your name? "
  read name                      #  Try to backspace
                                 #+ to erase characters of input.
                                 #  Problems?
  echo "Your name is $name."
  
  stty erase '#'                 #  Set "hashmark" (#) as erase character.
  echo -n "What is your name? "
  read name                      #  Use # to erase last character typed.
  echo "Your name is $name."
  
  exit 0
  
  # Even after the script exits, the new key value remains set.
  # Exercise: How would you reset the erase character to the default value?</pre></font></td></tr></tbody></table></div><div class="EXAMPLE"><a name="SECRETPW"></a><p><b>Example 17-3. <i class="FIRSTTERM">secret password</i>:
          Turning off terminal echoing </b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # secret-pw.sh: secret password
  
  echo
  echo -n "Enter password "
  read passwd
  echo "password is $passwd"
  echo -n "If someone had been looking over your shoulder, "
  echo "your password would have been compromised."
  
  echo &amp;&amp; echo  # Two line-feeds in an "and list."
  
  
  stty -echo    # Turns off screen echo.
  #   May also be done with
  #   read -sp passwd
  #   A big Thank You to Leigh James for pointing this out.
  
  echo -n "Enter password again "
  read passwd
  echo
  echo "password is $passwd"
  echo
  
  stty echo     # Restores screen echo.
  
  exit 0
  
  # Do an 'info stty' for more on this useful-but-tricky command.</pre></font></td></tr></tbody></table></div><p>A creative use of <b class="COMMAND">stty</b> is detecting a
          user keypress (without hitting
          <b class="KEYCAP">ENTER</b>).</p><div class="EXAMPLE"><a name="KEYPRESS"></a><p><b>Example 17-4. Keypress detection</b></p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">#!/bin/bash
  # keypress.sh: Detect a user keypress ("hot keys").
  
  echo
  
  old_tty_settings=$(stty -g)   # Save old settings (why?).
  stty -icanon
  Keypress=$(head -c1)          # or $(dd bs=1 count=1 2&gt; /dev/null)
                                # on non-GNU systems
  
  echo
  echo "Key pressed was \""$Keypress"\"."
  echo
  
  stty "$old_tty_settings"      # Restore old settings.
  
  # Thanks, Stephane Chazelas.
  
  exit 0</pre></font></td></tr></tbody></table></div><p>Also see <a href="#TIMEOUT">Example 9-3</a> and <a href="#STOPWATCH">Example A-43</a>.</p><p><a name="TERMINALSREF"></a></p><table class="SIDEBAR" border="1" cellpadding="5"><tbody><tr><td><div class="SIDEBAR"><a name="AEN15053"></a><p><b>terminals and modes</b></p><p>Normally, a terminal works in the
          <i class="FIRSTTERM">canonical</i> mode.  When a user hits a
          key, the resulting character does not immediately go to
          the program actually running in this terminal.  A buffer
          local to the terminal stores keystrokes. When the user
          hits the <b class="KEYCAP">ENTER</b> key, this sends all the
          stored keystrokes to the program running.  There is even
          a basic line editor inside the terminal.</p><p>	        <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>stty -a</b></tt>
  <tt class="COMPUTEROUTPUT">speed 9600 baud; rows 36; columns 96; line = 0;
   intr = ^C; quit = ^\; erase = ^H; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;;
   start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O;
   ...
   isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt</tt>
                  </pre></font></td></tr></tbody></table>
        </p><p>Using canonical mode, it is possible to redefine the
                special keys for the local terminal line editor.
  
            <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cat &gt; filexxx</b></tt>
  <tt class="USERINPUT"><b>wha&lt;ctl-W&gt;I&lt;ctl-H&gt;foo bar&lt;ctl-U&gt;hello world&lt;ENTER&gt;</b></tt>
  <tt class="USERINPUT"><b>&lt;ctl-D&gt;</b></tt>
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>cat filexxx</b></tt>
  <tt class="COMPUTEROUTPUT">hello world</tt>		
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>wc -c &lt; filexxx</b></tt>
  <tt class="COMPUTEROUTPUT">12</tt>		
                  </pre></font></td></tr></tbody></table>
  
                The process controlling the terminal receives only 12
                characters (11 alphabetic ones, plus a newline), although
                the user hit 26 keys.
              </p><p>In non-canonical (<span class="QUOTE">"raw"</span>) mode, every
                key hit (including special editing keys such as
                <b class="KEYCAP">ctl-H</b>) sends a character immediately to
                the controlling process.</p><p>The Bash prompt disables both <tt class="OPTION">icanon</tt>
                and <tt class="OPTION">echo</tt>, since it replaces the basic
                terminal line editor with its own more elaborate one. For
                example, when you hit <b class="KEYCAP">ctl-A</b> at the Bash
                prompt, there's no <b class="KEYCAP">^A</b> echoed by the
                terminal, but Bash gets a <b class="KEYCAP">\1</b> character,
                interprets it, and moves the cursor to the begining of
                the line.</p><p><em>StÃ©phane Chazelas</em></p></div></td></tr></tbody></table></dd><dt><a name="SETTERMREF"></a><b class="COMMAND">setterm</b></dt><dd><p>Set certain terminal attributes. This command writes
          to its terminal's <tt class="FILENAME">stdout</tt> a string that
          changes the behavior of that terminal.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>setterm -cursor off</b></tt>
  <tt class="COMPUTEROUTPUT">bash$</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>The <b class="COMMAND">setterm</b> command can be used within a
          script to change the appearance of text written to
          <tt class="FILENAME">stdout</tt>, although there are certainly
          <a href="#COLORIZINGREF">better tools</a> available
          for this purpose.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING">setterm -bold on
  echo bold hello
  
  setterm -bold off
  echo normal hello</pre></font></td></tr></tbody></table></p></dd><dt><a name="TSETREF"></a><b class="COMMAND">tset</b></dt><dd><p>Show or initialize terminal settings. 
          This is a less capable version of
          <b class="COMMAND">stty</b>.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>tset -r</b></tt>
  <tt class="COMPUTEROUTPUT">Terminal type is xterm-xfree86.
   Kill is control-U (^U).
   Interrupt is control-C (^C).</tt>
          </pre></font></td></tr></tbody></table>
        </p></dd><dt><a name="SETSERIALREF"></a><b class="COMMAND">setserial</b></dt><dd><p>Set or display serial port parameters. This command must be
          run by <i class="FIRSTTERM">root</i> and is usually found in a
          system setup script.</p><p><table border="0" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="PROGRAMLISTING"># From /etc/pcmcia/serial script:
  
  IRQ=`setserial /dev/$DEVICE | sed -e 's/.*IRQ: //'`
  setserial /dev/$DEVICE irq 0 ; setserial /dev/$DEVICE irq $IRQ</pre></font></td></tr></tbody></table></p></dd><dt><a name="GETTYREF"></a><b class="COMMAND">getty</b>, <a name="AGETTYREF"></a><b class="COMMAND">agetty</b></dt><dd><p>The initialization process for a terminal uses
          <b class="COMMAND">getty</b> or <b class="COMMAND">agetty</b>
          to set it up for login by a user. These commands are not
          used within user shell scripts. Their scripting counterpart
          is <b class="COMMAND">stty</b>.</p></dd><dt><a name="MESGREF"></a><b class="COMMAND">mesg</b></dt><dd><p>Enables or disables write access to the current user's
          terminal.  Disabling access would prevent another user
          on the network to <a href="#WRITEREF">write</a>
          to the terminal.</p><div class="TIP"><p></p><table class="TIP" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/tip.gif" hspace="5" alt="Tip"></td><td align="LEFT" valign="TOP"><p>It can be quite annoying to have a message
          about ordering pizza suddenly appear in the middle of
          the text file you are editing. On a multi-user network,
          you might therefore wish to disable write access to your
          terminal when you need to avoid interruptions.</p></td></tr></tbody></table></div></dd><dt><a name="WALLREF"></a><b class="COMMAND">wall</b></dt><dd><p>This is an acronym for <span class="QUOTE">"<a href="#WRITEREF">write</a> all,"</span> i.e., sending
          a message to all users at every terminal logged into the
          network. It is primarily a system administrator's tool,
          useful, for example, when warning everyone that the
          system will shortly go down due to a problem (see <a href="#EX70">Example 19-1</a>).</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>wall System going down for maintenance in 5 minutes!</b></tt>
  <tt class="COMPUTEROUTPUT">Broadcast message from bozo (pts/1) Sun Jul  8 13:53:27 2001...
  
   System going down for maintenance in 5 minutes!</tt>
          </pre></font></td></tr></tbody></table>
        </p><div class="NOTE"><p></p><table class="NOTE" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/note.gif" hspace="5" alt="Note"></td><td align="LEFT" valign="TOP"><p>If write access to a particular terminal has been
          disabled with <b class="COMMAND">mesg</b>, then
          <b class="COMMAND">wall</b> cannot send a message to
          that terminal.</p></td></tr></tbody></table></div></dd></dl></div><p></p><div class="VARIABLELIST"><p><b><a name="STATISTICSSYS1"></a>Information and Statistics</b></p><dl><dt><a name="UNAMEREF"></a><b class="COMMAND">uname</b></dt><dd><p>Output system specifications (OS, kernel version,
          etc.) to <tt class="FILENAME">stdout</tt>.  Invoked with the
          <tt class="OPTION">-a</tt> option, gives verbose system info
          (see <a href="#EX41">Example 16-5</a>). The <tt class="OPTION">-s</tt>
          option shows only the OS type.</p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>uname</b></tt>
  <tt class="COMPUTEROUTPUT">Linux</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>uname -s</b></tt>
  <tt class="COMPUTEROUTPUT">Linux</tt>
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>uname -a</b></tt>
  <tt class="COMPUTEROUTPUT">Linux iron.bozo 2.6.15-1.2054_FC5 #1 Tue Mar 14 15:48:33 EST 2006
   i686 i686 i386 GNU/Linux</tt></pre></font></td></tr></tbody></table></dd><dt><a name="ARCHREF"></a><b class="COMMAND">arch</b></dt><dd><p>Show system architecture.
          Equivalent to <b class="COMMAND">uname -m</b>. See <a href="#CASECMD">Example 11-27</a>.</p><table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>arch</b></tt>
  <tt class="COMPUTEROUTPUT">i686</tt>
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>uname -m</b></tt>
  <tt class="COMPUTEROUTPUT">i686</tt></pre></font></td></tr></tbody></table></dd><dt><a name="LASTCOMMREF"></a><b class="COMMAND">lastcomm</b></dt><dd><p>Gives information about previous commands, as stored
          in the <tt class="FILENAME">/var/account/pacct</tt> file. Command
          name and user name can be specified by options. This is
          one of the GNU accounting utilities.</p></dd><dt><a name="LASTLOGREF"></a><b class="COMMAND">lastlog</b></dt><dd><p>List the last login time of all system users. This
          references the <tt class="FILENAME">/var/log/lastlog</tt>
          file.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>lastlog</b></tt>
  <tt class="COMPUTEROUTPUT">root          tty1                      Fri Dec  7 18:43:21 -0700 2001
   bin                                     **Never logged in**
   daemon                                  **Never logged in**
   ...
   bozo          tty1                      Sat Dec  8 21:14:29 -0700 2001</tt>
  
  
  
  <tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>lastlog | grep root</b></tt>
  <tt class="COMPUTEROUTPUT">root          tty1                      Fri Dec  7 18:43:21 -0700 2001</tt>
          </pre></font></td></tr></tbody></table>
          </p><div class="CAUTION"><p></p><table class="CAUTION" width="90%" border="0"><tbody><tr><td width="25" align="CENTER" valign="TOP"><img src="../images/caution.gif" hspace="5" alt="Caution"></td><td align="LEFT" valign="TOP"><p>This command will fail if the user invoking
      it does not have read permission for the
      <tt class="FILENAME">/var/log/lastlog</tt> file.</p></td></tr></tbody></table></div></dd><dt><a name="LSOFREF"></a><b class="COMMAND">lsof</b></dt><dd><p>List open files. This command outputs a detailed
          table of all currently open files and gives information
          about their owner, size, the processes associated with
          them, and more. Of course, <b class="COMMAND">lsof</b> may
          be piped to <a href="#GREPREF">grep</a> and/or
          <a href="#AWKREF">awk</a> to parse and analyze
          its results.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>lsof</b></tt>
  <tt class="COMPUTEROUTPUT">COMMAND    PID    USER   FD   TYPE     DEVICE    SIZE     NODE NAME
   init         1    root  mem    REG        3,5   30748    30303 /sbin/init
   init         1    root  mem    REG        3,5   73120     8069 /lib/ld-2.1.3.so
   init         1    root  mem    REG        3,5  931668     8075 /lib/libc-2.1.3.so
   cardmgr    213    root  mem    REG        3,5   36956    30357 /sbin/cardmgr
   ...</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>The <b class="COMMAND">lsof</b> command is a useful,
          if complex administrative tool. If you are unable to
          dismount a filesystem and get an error message that it is
          still in use, then running <i class="FIRSTTERM">lsof</i> helps
          determine which files are still open on that filesystem. The
          <tt class="OPTION">-i</tt> option lists open network socket files,
          and this can help trace intrusion or hack attempts.</p><p>	      <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr><td><font color="#000000"><pre class="SCREEN"><tt class="PROMPT">bash$ </tt><tt class="USERINPUT"><b>lsof -an -i tcp</b></tt>
  <tt class="COMPUTEROUTPUT">COMMAND  PID USER  FD  TYPE DEVICE SIZE NODE NAME
   firefox 2330 bozo  32u IPv4   9956       TCP 66.0.118.137:57596-&gt;67.112.7.104:http ...
   firefox 2330 bozo  38u IPv4  10535       TCP 66.0.118.137:57708-&gt;216.79.48.24:http ...</tt>
          </pre></font></td></tr></tbody></table>
        </p><p>See <a href="#IPADDRESSES">Example 30-2</a> for an effective use
                of <b class="COMMAND">lsof</b>.</p></dd><dt><a name="STRACEREF"></a><b class="COMMAND">strace</b></dt><dd><p><b class="COMMAND">S</b>ystem <b class="COMMAND">trace</b>:
          diagnostic and debugging tool for tracing <i class="FIRSTTERM">system
          calls</i> and signals. This command and
          <b class="COMMAND">ltrace</b>, following, are useful for
          diagnosing why a given program or package fails to
          run . . . perhaps due to missing libraries or related
          causes.</p><p>	    <table border="1" bgcolor="#E0E0E0" width="90%"><tbody><tr></tr></tbody></table></p></dd></dl></div></div></div></div>